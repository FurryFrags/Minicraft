<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini INDEV Voxel (Infinite + Textures + Faster)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { display: block; }

    /* HUD */
    #hud { position: fixed; inset: 0; pointer-events: none; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,.85); }
    #crosshair {
      position: absolute; left: 50%; top: 50%;
      width: 14px; height: 14px; transform: translate(-50%,-50%); opacity: .9;
    }
    #crosshair:before, #crosshair:after {
      content: ""; position: absolute; left: 50%; top: 50%;
      background: rgba(255,255,255,.95);
      transform: translate(-50%,-50%); border-radius: 1px;
    }
    #crosshair:before { width: 14px; height: 2px; }
    #crosshair:after  { width: 2px;  height: 14px; }

    #help {
      position: absolute; left: 12px; top: 10px;
      background: rgba(0,0,0,.32);
      border: 1px solid rgba(255,255,255,.12);
      padding: 10px 12px; border-radius: 12px;
      max-width: 920px; line-height: 1.35;
      white-space: pre-wrap;
    }

    /* Hotbar (in-game) */
    #hotbarHud {
      position: absolute; left: 50%; bottom: 18px; transform: translateX(-50%);
      display: grid; grid-auto-flow: column; gap: 8px;
      background: rgba(0,0,0,.32);
      border: 1px solid rgba(255,255,255,.12);
      padding: 8px; border-radius: 12px;
      pointer-events: none;
    }

    /* Survival HUD (Minecraft-ish hearts / armor / hunger) */
    #statusHud {
      position: absolute;
      left: 50%;
      bottom: 102px;
      transform: translateX(-50%);
      display: none; /* shown in survival */
      align-items: flex-end;
      justify-content: space-between;
      gap: 40px;
      pointer-events: none;
      filter: drop-shadow(0 2px 0 rgba(0,0,0,.60)) drop-shadow(0 0 6px rgba(0,0,0,.35));
      --uiSprite: none;
    }
    .statusSide { display: grid; gap: 2px; }
    .statusRow { display: flex; gap: 0px; }
    .uiIcon {
      width: 24px; height: 24px;
      background-image: var(--uiSprite);
      background-repeat: no-repeat;
      image-rendering: pixelated;
      opacity: 0.98;
    }


/* Chat */
#chatWrap {
  position: absolute; left: 12px; bottom: 74px;
  width: min(460px, calc(100vw - 24px));
  pointer-events: none;
  font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 14px;
  line-height: 1.45;
  color: #fff;
  text-shadow: 0 2px 0 rgba(0,0,0,.65), 0 0 6px rgba(0,0,0,.35);
}
#chatLog {
  display: grid;
  gap: 4px;
  margin-bottom: 8px;
  max-height: 220px; /* tighter chat height */
  overflow-y: hidden; /* becomes scrollable when chat is open */
  padding-right: 6px;
}
.chatLine {
  display: inline-block;
  background: rgba(0,0,0,.25);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 10px;
  padding: 6px 8px;
  max-width: 100%;
  overflow-wrap: anywhere;
}
#chatInputRow { display: none; pointer-events: auto; }
#chatInput {
  width: 100%;
  appearance: none;
  border: 1px solid rgba(255,255,255,.18);
  background: rgba(0,0,0,.40);
  color: #fff;
  padding: 10px 12px;
  border-radius: 12px;
  outline: none;
  font: inherit;
  line-height: 1.2;
}
#chatHint { margin-top: 6px; opacity: .75; font-size: 10px; }
    .hb-slot {
      width: 46px; height: 46px; border-radius: 10px;
      border: 2px solid rgba(255,255,255,.22);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.25);
      display: grid; place-items: center;
    }
    .hb-slot.selected { border-color: rgba(255,255,255,.92); }
    .hb-swatch {
      width: 28px; height: 28px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,.30);
      box-shadow: 0 2px 6px rgba(0,0,0,.35);
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }

    /* Menu overlay */
    #menuOverlay {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,.35), rgba(0,0,0,.75));
      color: #fff;
      user-select: none;
      z-index: 10;
    }
    #menuPanel {
      width: min(560px, calc(100vw - 24px));
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 12px 40px rgba(0,0,0,.55);
      text-align: center;
    }
    #menuTitle { margin: 0 0 8px; font-size: 18px; font-weight: 900; }
    #menuSub   { margin: 0 0 12px; opacity: .92; line-height: 1.35; }
    .btn {
      width: 100%;
      appearance: none; border: 0;
      background: rgba(255,255,255,.92); color: #000;
      font-weight: 900; font-size: 15px;
      padding: 12px 14px; border-radius: 12px;
      cursor: pointer;
    }
    .tiny { margin-top: 10px; font-size: 12px; opacity: .75; line-height: 1.35; }

    /* Inventory overlay */
    #invOverlay {
      position: fixed; inset: 0;
      display: none;
      place-items: center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,.25), rgba(0,0,0,.85));
      color: #fff;
      user-select: none;
      z-index: 20;
    }
    #invWindow {
      width: min(980px, calc(100vw - 24px));
      height: min(680px, calc(100vh - 24px));
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 18px;
      box-shadow: 0 12px 40px rgba(0,0,0,.60);
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      overflow: hidden;
    }
    #invHeader {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      gap: 12px;
    }
    #invHeader .left { display: flex; align-items: baseline; gap: 10px; flex-wrap: wrap; }
    #invHeader b { font-weight: 900; }
    #invHeader .hint { opacity: .8; font-size: 12px; }
    #invClose {
      appearance: none; border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06); color: #fff;
      padding: 8px 10px; border-radius: 12px;
      cursor: pointer;
      font-weight: 800;
      white-space: nowrap;
    }
    #invTools {
      padding: 10px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    #search {
      appearance: none;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.25);
      color: #fff;
      padding: 10px 12px;
      border-radius: 12px;
      outline: none;
      width: min(420px, 100%);
      font-weight: 700;
    }
    #invTools .tip { font-size: 12px; opacity: .85; }

    #invBody { padding: 14px; overflow: auto; }

    .grid { display: grid; grid-template-columns: repeat(9, 44px); justify-content: center; gap: 8px; }
    .slot {
      width: 44px; height: 44px; border-radius: 10px;
      border: 2px solid rgba(255,255,255,.15);
      background: rgba(0,0,0,.22);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.35), 0 6px 16px rgba(0,0,0,.30);
      display: grid; place-items: center;
      cursor: pointer;
    }
    .slot:hover { background: rgba(255,255,255,.05); }
    .slot.sel { border-color: rgba(255,255,255,.85); }
    .slot .sw {
      width: 28px; height: 28px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,.30);
      box-shadow: 0 2px 8px rgba(0,0,0,.35);
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }
    .labelRow {
      display: flex;
      justify-content: center;
      margin: 8px 0 10px;
      font-size: 12px;
      opacity: .85;
      gap: 10px;
      flex-wrap: wrap;
    }
    .sectionTitle {
      text-align: center;
      font-size: 12px;
      letter-spacing: .08em;
      opacity: .85;
      margin: 6px 0 8px;
      text-transform: uppercase;
    }

    #paletteGrid {
      display: grid;
      grid-template-columns: repeat(9, 44px);
      justify-content: center;
      gap: 8px;
    }
    .palSlot {
      width: 44px; height: 44px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      display: grid; place-items: center;
      cursor: pointer;
      position: relative;
    }
    .palSlot:hover { border-color: rgba(255,255,255,.35); background: rgba(255,255,255,.06); }
    .palSlot .sw {
      width: 28px; height: 28px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,.28);
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }
    .palSlot[data-name]:hover::after {
      content: attr(data-name);
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 52px;
      background: rgba(0,0,0,.75);
      border: 1px solid rgba(255,255,255,.18);
      color: #fff;
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
    }

    #invFooter {
      padding: 12px 14px;
      border-top: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      font-size: 12px;
      opacity: .9;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <div id="menuOverlay">
    <div id="menuPanel">
      <div id="menuTitle">Mini INDEV Voxel</div>
      <div id="menuSub">
        Infinite chunk world + pixel textures + less CPU lag.<br/>
        Click <b>Play</b>. If mouse-capture is blocked on <code>file://</code>, it falls back to <b>RMB-drag</b>.
      </div>
      <button id="play" class="btn" type="button">Play</button>
      <div class="tiny">
        Controls: <b>WASD</b> move · <b>Shift</b> sprint · <b>Space</b> jump · <b>LMB</b> break · <b>RMB</b> place · <b>MMB</b> pick · <b>1–9</b> hotbar · <b>E</b> inventory · <b>Esc</b> menu
      </div>
    </div>
  </div>

  <div id="invOverlay">
    <div id="invWindow">
      <div id="invHeader">
        <div class="left">
          <b>Inventory</b>
          <span class="hint">Creative palette + hotbar. Press <b>E</b> to close.</span>
        </div>
        <button id="invClose" type="button">Close</button>
      </div>

      <div id="invTools">
        <input id="search" type="text" placeholder="Search blocks…" autocomplete="off" />
        <div class="tip">Click a palette block to put it into your selected hotbar slot.</div>
      </div>

      <div id="invBody">
        <div class="sectionTitle">Creative blocks</div>
        <div id="paletteGrid"></div>

        <div class="labelRow">
          <span><b>Hotbar</b> (click a slot to select)</span>
          <span>·</span>
          <span>Tip: MMB in-world copies a block into the selected slot</span>
        </div>
        <div id="invHotbar" class="grid"></div>
      </div>

      <div id="invFooter">
        <div>Perf: voxel DDA picking + chunk meshing scans full height (so builds never disappear).</div>
        <div>Tip: click the canvas after closing UI to re-capture mouse instantly.</div>
      </div>
    </div>
  </div>

  <div id="hud">
    <div id="crosshair"></div>
    <div id="help"></div>

    <div id="statusHud"></div>

<div id="chatWrap">
  <div id="chatLog"></div>
  <div id="chatInputRow">
    <input id="chatInput" type="text" maxlength="160" autocomplete="off" spellcheck="false"
           placeholder="Type message… (Enter to send, Esc to cancel)" />
    <div id="chatHint">Chat: T · Send: Enter · Cancel: Esc</div>
  </div>
</div>
    <div id="hotbarHud"></div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
  (() => {
    "use strict";

    // ======================================================
    // Blocks (toy creative set) + texture tile assignments
    // ======================================================
    const B = {
      AIR: 0,
      GRASS: 1,
      COBBLE: 2,
      LOG: 3,
      DIRT: 4,
      PLANKS: 5,
      SAND: 6,
      GLASS: 7,
      LEAVES: 8,
      BRICKS: 9,
      OBSIDIAN: 10,
      GOLD: 11,
      DIAMOND: 12,
      TNT: 13,
      WOOL_WHITE: 14,
      WOOL_RED: 15,
      WOOL_BLUE: 16,
      WOOL_GREEN: 17,
      WATER: 18, // decorative
      LAVA: 19,  // decorative
      BEDROCK: 20,
    };

    const WORLD_H = 192;      // fixed world height (taller so mountains can breathe)
    const SEA_LEVEL = 32;    // water level
    // ======================================================
    // Chunk streaming config
    // ======================================================
    const CHUNK = 16;
    const RADIUS = 4;              // view distance in chunks
    const MAX_LOADS_PER_FRAME = 1; // stability > speed

    // ======================================================
    // Player
    // ======================================================
    const PLAYER = {
      radius: 0.32,
      height: 1.72,
      eye: 1.62,
      speed: 5.0,
      jump: 7.42,
      gravity: 22.0,
      terminal: 40.0,
    };

    // ======================================================
    // DOM
    // ======================================================
    const menuOverlay = document.getElementById("menuOverlay");
    const playBtn = document.getElementById("play");
    const invOverlay = document.getElementById("invOverlay");
    const invClose = document.getElementById("invClose");
    const helpEl = document.getElementById("help");
    const hotbarHudEl = document.getElementById("hotbarHud");
    const statusHudEl = document.getElementById("statusHud");
    const paletteGridEl = document.getElementById("paletteGrid");
    const chatWrap = document.getElementById("chatWrap");
    const chatLogEl = document.getElementById("chatLog");
    const chatInputRow = document.getElementById("chatInputRow");
    const chatInputEl = document.getElementById("chatInput");
    const invHotbarEl = document.getElementById("invHotbar");
    const searchEl = document.getElementById("search");

    // ======================================================
    // Survival HUD sprite (pixel icons) + status rows
    // ======================================================
    const UI_ICON_TILE = 9;   // native pixel size
    const UI_ICON_PX = 24;    // displayed size

    function makeUiSprite() {
      const c = document.createElement("canvas");
      const cols = 9; // heart f/h/e, hunger f/h/e, armor f/h/e
      c.width = cols * UI_ICON_TILE;
      c.height = UI_ICON_TILE;
      const ctx = c.getContext("2d", { alpha: true });
      ctx.imageSmoothingEnabled = false;

      function p(ix, iy, col) {
        ctx.fillStyle = col;
        ctx.fillRect(ix, iy, 1, 1);
      }
      function drawHeart(x0, kind) {
        // 9x9 pixel-ish heart
        const O = "rgba(60,0,0,0.95)";
        const R = "rgba(200,20,20,0.95)";
        const E = "rgba(0,0,0,0)";
        const map = [
          "..##.##..",
          ".#######.",
          "#########",
          "#########",
          ".#######.",
          "..#####..",
          "...###...",
          "....#....",
          ".........",
        ];
        for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
          const ch = map[y][x];
          if (ch === '#') {
            let fill = R;
            if (kind === "empty") fill = E;
            if (kind === "half" && x >= 5) fill = E;
            if (fill !== E) p(x0+x, y, fill);
            // outline where adjacent is empty
            const on = (fill !== E);
            const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
            if (on) {
              for (const [dx,dy] of neighbors) {
                const xx=x+dx, yy=y+dy;
                const inside = (xx>=0&&xx<9&&yy>=0&&yy<9&&map[yy][xx]==='#');
                if (!inside) { p(x0+x, y, O); break; }
              }
            } else if (kind === "empty") {
              // empty heart outline only
              const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
              let near = false;
              for (const [dx,dy] of neighbors) {
                const xx=x+dx, yy=y+dy;
                if (xx>=0&&xx<9&&yy>=0&&yy<9&&map[yy][xx]==='#') near = true;
              }
              if (near && ch === '.') {
                // no-op
              }
            }
          }
        }
        if (kind === "empty" || kind === "half") {
          // outline only (empty) or outline around filled half
          for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
            if (map[y][x] !== '#') continue;
            const filled = (kind === "full") || (kind === "half" && x < 5);
            const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
            let edge = false;
            for (const [dx,dy] of neighbors) {
              const xx=x+dx, yy=y+dy;
              const inside = (xx>=0&&xx<9&&yy>=0&&yy<9&&map[yy][xx]==='#');
              const filledN = inside ? ((kind === "full") || (kind === "half" && xx < 5)) : false;
              if (!filledN) { edge = true; break; }
            }
            if (edge) p(x0+x, y, O);
            else if (kind === "empty") p(x0+x, y, "rgba(0,0,0,0)");
          }
        }
      }

      function drawArmor(x0, kind) {
        // 9x9 simple chestplate/shield-ish icon
        const O = "rgba(15,15,15,0.95)";
        const G = "rgba(205,205,205,0.95)";
        const E = "rgba(0,0,0,0)";
        const map = [
          "..#####..",
          ".#######.",
          "#########",
          "###...###",
          "###...###",
          "#########",
          ".#######.",
          "..#####..",
          ".........",
        ];
        for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
          if (map[y][x] !== '#') continue;
          let fill = G;
          if (kind === "empty") fill = E;
          if (kind === "half" && x >= 5) fill = E;
          if (fill !== E) p(x0+x, y, fill);
        }
        // outline
        for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
          if (map[y][x] !== '#') continue;
          const filled = (kind === "full") || (kind === "half" && x < 5);
          const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
          let edge = false;
          for (const [dx,dy] of neighbors) {
            const xx=x+dx, yy=y+dy;
            const inside = (xx>=0&&xx<9&&yy>=0&&yy<9&&map[yy][xx]==='#');
            const filledN = inside ? ((kind === "full") || (kind === "half" && xx < 5)) : false;
            if (!filledN) { edge = true; break; }
          }
          if (edge && filled) p(x0+x, y, O);
          if (edge && kind === "empty") p(x0+x, y, "rgba(70,70,70,0.55)");
        }
      }

      function drawHunger(x0, kind) {
        // 9x9 drumstick-ish
        const O = "rgba(25,10,0,0.95)";
        const B = "rgba(210,130,50,0.95)";
        const W = "rgba(240,240,240,0.95)";
        const E = "rgba(0,0,0,0)";
        const map = [
          "...###...",
          "..#####..",
          ".#######.",
          ".#######.",
          "..#####..",
          "...###...",
          "...##....",
          "..####...",
          "...##....",
        ];
        for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
          if (map[y][x] !== '#') continue;
          let fill = B;
          if (y >= 6) fill = W; // bone-ish
          if (kind === "empty") fill = E;
          if (kind === "half" && x >= 5) fill = E;
          if (fill !== E) p(x0+x, y, fill);
        }
        // outline
        for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
          if (map[y][x] !== '#') continue;
          const filled = (kind === "full") || (kind === "half" && x < 5);
          const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
          let edge = false;
          for (const [dx,dy] of neighbors) {
            const xx=x+dx, yy=y+dy;
            const inside = (xx>=0&&xx<9&&yy>=0&&yy<9&&map[yy][xx]==='#');
            const filledN = inside ? ((kind === "full") || (kind === "half" && xx < 5)) : false;
            if (!filledN) { edge = true; break; }
          }
          if (edge && filled) p(x0+x, y, O);
          if (edge && kind === "empty") p(x0+x, y, "rgba(90,45,10,0.55)");
        }
      }

      // draw tiles in one row
      drawHeart(0*UI_ICON_TILE, "full");
      drawHeart(1*UI_ICON_TILE, "half");
      drawHeart(2*UI_ICON_TILE, "empty");
      drawHunger(3*UI_ICON_TILE, "full");
      drawHunger(4*UI_ICON_TILE, "half");
      drawHunger(5*UI_ICON_TILE, "empty");
      drawArmor(6*UI_ICON_TILE, "full");
      drawArmor(7*UI_ICON_TILE, "half");
      drawArmor(8*UI_ICON_TILE, "empty");

      const url = c.toDataURL("image/png");
      return { url, cols };
    }

    const uiSprite = makeUiSprite();
    statusHudEl.style.setProperty("--uiSprite", `url(${uiSprite.url})`);

    statusHudEl.innerHTML = `
      <div class="statusSide">
        <div class="statusRow" id="armorRow"></div>
        <div class="statusRow" id="healthRow"></div>
      </div>
      <div class="statusSide">
        <div class="statusRow" id="hungerRow"></div>
      </div>
    `;
    const armorRowEl = statusHudEl.querySelector("#armorRow");
    const healthRowEl = statusHudEl.querySelector("#healthRow");
    const hungerRowEl = statusHudEl.querySelector("#hungerRow");

    function makeIcon(tileIndex) {
      const s = document.createElement("span");
      s.className = "uiIcon";
      s.style.backgroundSize = `${uiSprite.cols * UI_ICON_PX}px ${UI_ICON_PX}px`;
      s.style.backgroundPosition = `-${tileIndex * UI_ICON_PX}px 0px`;
      return s;
    }

    const uiIcons = {
      heartFull: 0,
      heartHalf: 1,
      heartEmpty: 2,
      hungerFull: 3,
      hungerHalf: 4,
      hungerEmpty: 5,
      armorFull: 6,
      armorHalf: 7,
      armorEmpty: 8,
    };

    const armorIcons = [], healthIcons = [], hungerIcons = [];
    for (let i=0;i<10;i++) {
      const a = makeIcon(uiIcons.armorEmpty); armorRowEl.appendChild(a); armorIcons.push(a);
      const h = makeIcon(uiIcons.heartFull);  healthRowEl.appendChild(h); healthIcons.push(h);
      const u = makeIcon(uiIcons.hungerFull); hungerRowEl.appendChild(u); hungerIcons.push(u);
    }

    // ======================================================
    // Three.js
    // ======================================================
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.domElement.tabIndex = 0;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87b7ff);
    scene.fog = new THREE.FogExp2(0x87b7ff, 0.008);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.05, 900);
    camera.rotation.order = "YXZ";

    scene.add(new THREE.HemisphereLight(0xbad6ff, 0x3a3a3a, 0.85));
    const sun = new THREE.DirectionalLight(0xffffff, 0.85);
    sun.position.set(80, 140, 40);
    scene.add(sun);

    // ======================================================
    // Texture atlas (procedural, embedded)
    // ======================================================
    const TILE = 16;
    const ATLAS_COLS = 8;
    const ATLAS_ROWS = 8;


    const ICON_PX = 28; // UI icon size; keeps tiles aligned/pixel-perfect
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    function rgb(r,g,b){ return `rgb(${r|0},${g|0},${b|0})`; }

    // deterministic hash for pixels / tiles
    function hash32(n){
      n = (n ^ (n >>> 16)) >>> 0;
      n = Math.imul(n, 0x7feb352d) >>> 0;
      n = (n ^ (n >>> 15)) >>> 0;
      n = Math.imul(n, 0x846ca68b) >>> 0;
      n = (n ^ (n >>> 16)) >>> 0;
      return n >>> 0;
    }
    function rnd01(seed){
      return (hash32(seed) & 0xFFFFFF) / 0xFFFFFF;
    }

    function drawNoiseTile(ctx, tx, ty, baseRGB, speckRGB, speckRate, shadeRate, seedBase) {
      const ox = tx * TILE, oy = ty * TILE;
      for (let y=0; y<TILE; y++) for (let x=0; x<TILE; x++) {
        const s = seedBase + x*131 + y*977;
        const r = rnd01(s);
        const sh = (rnd01(s ^ 0x9e3779b9) - 0.5) * shadeRate;
        let rr = baseRGB[0] + sh, gg = baseRGB[1] + sh, bb = baseRGB[2] + sh;
        if (r < speckRate) {
          const k = rnd01(s ^ 0xBADC0DE) * 0.6 + 0.4;
          rr = lerp(rr, speckRGB[0], k);
          gg = lerp(gg, speckRGB[1], k);
          bb = lerp(bb, speckRGB[2], k);
        }
        rr = Math.max(0, Math.min(255, rr));
        gg = Math.max(0, Math.min(255, gg));
        bb = Math.max(0, Math.min(255, bb));
        ctx.fillStyle = rgb(rr,gg,bb);
        ctx.fillRect(ox + x, oy + y, 1, 1);
      }
    }

    function drawPlanks(ctx, tx, ty, seedBase){
      const ox = tx*TILE, oy = ty*TILE;
      // base
      drawNoiseTile(ctx, tx, ty, [196,154,90], [220,188,120], 0.08, 18, seedBase);
      // plank seams
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      for (let i=0; i<3; i++) {
        const yy = oy + 3 + i*5;
        ctx.fillRect(ox, yy, TILE, 1);
      }
      // subtle vertical grain
      for (let x=0; x<TILE; x+=3) {
        const a = 0.05 + rnd01(seedBase + x*19)*0.06;
        ctx.fillStyle = `rgba(70,40,15,${a})`;
        ctx.fillRect(ox+x, oy, 1, TILE);
      }
    }

    function drawCobble(ctx, tx, ty, seedBase){
      const ox = tx*TILE, oy = ty*TILE;
      // base noise
      drawNoiseTile(ctx, tx, ty, [135, 139, 148], [90,90,95], 0.12, 35, seedBase);
      // chunky stones
      for (let i=0; i<18; i++){
        const r = rnd01(seedBase + i*999);
        const x = (rnd01(seedBase + i*123) * (TILE-4))|0;
        const y = (rnd01(seedBase + i*321) * (TILE-4))|0;
        const w = 2 + ((r*3)|0);
        const h = 2 + (((1-r)*3)|0);
        const c = 90 + (r*70)|0;
        ctx.fillStyle = rgb(c,c,c);
        ctx.fillRect(ox+x, oy+y, w, h);
        ctx.fillStyle = "rgba(0,0,0,0.18)";
        ctx.fillRect(ox+x, oy+y+h-1, w, 1);
        ctx.fillRect(ox+x+w-1, oy+y, 1, h);
      }
    }

    function drawGrassTop(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [78, 168, 74], [40, 130, 40], 0.10, 22, seedBase);
      // little lighter flecks
      const ox = tx*TILE, oy = ty*TILE;
      for (let i=0;i<14;i++){
        const x = (rnd01(seedBase + i*41) * TILE)|0;
        const y = (rnd01(seedBase + i*57) * TILE)|0;
        ctx.fillStyle = "rgba(255,255,255,0.07)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawGrassSide(ctx, tx, ty, seedBase){
      // dirt base
      drawNoiseTile(ctx, tx, ty, [138, 90, 43], [120, 70, 28], 0.10, 26, seedBase);
      // green top band
      const ox = tx*TILE, oy = ty*TILE;
      for (let y=0; y<5; y++){
        const a = 0.85 - y*0.11;
        ctx.fillStyle = `rgba(80, 175, 76, ${a})`;
        ctx.fillRect(ox, oy+y, TILE, 1);
      }
      // green specks in band
      for (let i=0;i<18;i++){
        const x = (rnd01(seedBase + i*91) * TILE)|0;
        const y = (rnd01(seedBase + i*37) * 5)|0;
        ctx.fillStyle = "rgba(30,90,30,0.35)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawLogSide(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [164, 116, 60], [120, 80, 35], 0.10, 20, seedBase);
      const ox = tx*TILE, oy = ty*TILE;
      // vertical stripes
      for (let x=0; x<TILE; x++){
        const a = 0.05 + rnd01(seedBase + x*17)*0.10;
        ctx.fillStyle = `rgba(70,40,15,${a})`;
        ctx.fillRect(ox+x, oy, 1, TILE);
      }
    }

    function drawLogTop(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [175, 130, 75], [130, 90, 40], 0.08, 18, seedBase);
      // rings (cheap)
      for (let r=2; r<=7; r+=2){
        const a = 0.20 - r*0.015;
        ctx.strokeStyle = `rgba(80,45,20,${a})`;
        ctx.beginPath();
        ctx.arc(ox+8, oy+8, r + rnd01(seedBase+r*133)*0.35, 0, Math.PI*2);
        ctx.stroke();
      }
      // darker bark edge
      ctx.strokeStyle = "rgba(55,30,15,0.35)";
      ctx.strokeRect(ox+0.5, oy+0.5, TILE-1, TILE-1);
    }

    function drawBricks(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [178, 92, 77], [140, 60, 55], 0.08, 20, seedBase);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      for (let y=0; y<TILE; y+=4){
        ctx.fillRect(ox, oy+y, TILE, 1);
      }
      for (let row=0; row<4; row++){
        const y = oy + row*4;
        const offset = (row%2)*4;
        for (let x=offset; x<TILE; x+=8){
          ctx.fillRect(ox+x, y, 1, 4);
        }
      }
    }

    function drawObsidian(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [35, 25, 50], [80, 40, 120], 0.10, 10, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      for (let i=0;i<18;i++){
        const x=(rnd01(seedBase+i*31)*TILE)|0;
        const y=(rnd01(seedBase+i*67)*TILE)|0;
        ctx.fillStyle="rgba(150,90,220,0.10)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawSand(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [218, 203, 131], [240, 230, 170], 0.10, 16, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      for (let i=0;i<10;i++){
        const x=(rnd01(seedBase+i*19)*TILE)|0;
        const y=(rnd01(seedBase+i*23)*TILE)|0;
        ctx.fillStyle="rgba(120,100,40,0.10)";
        ctx.fillRect(ox+x, oy+y, 2, 1);
      }
    }

    function drawLeaves(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [55, 145, 65], [25, 90, 35], 0.14, 22, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      for (let i=0;i<24;i++){
        const x=(rnd01(seedBase+i*53)*TILE)|0;
        const y=(rnd01(seedBase+i*79)*TILE)|0;
        ctx.fillStyle="rgba(0,0,0,0.10)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawGlass(ctx, tx, ty){
      // Cutout/dithered "see-through" glass:
      // - Most pixels are fully transparent (so you can see through)
      // - A sparse dither + border lines are opaque enough to read as glass
      // This avoids per-instance transparent sorting artifacts (no more x-ray glitches).
      const ox=tx*TILE, oy=ty*TILE;

      // clear tile (fully transparent)
      ctx.clearRect(ox, oy, TILE, TILE);

      // subtle dither dots
      for (let y=0; y<TILE; y++){
        for (let x=0; x<TILE; x++){
          // ordered-ish pattern + a bit of noise
          const k = ((x*3 + y*5) & 7);
          if (k === 0 || k === 5) {
            ctx.fillStyle="rgba(185,230,255,0.70)";
            ctx.fillRect(ox+x, oy+y, 1, 1);
          }
        }
      }

      // crisp border and highlights
      ctx.strokeStyle="rgba(255,255,255,0.95)";
      ctx.strokeRect(ox+0.5, oy+0.5, TILE-1, TILE-1);

      ctx.strokeStyle="rgba(255,255,255,0.75)";
      ctx.beginPath();
      ctx.moveTo(ox+3, oy+2); ctx.lineTo(ox+13, oy+12);
      ctx.moveTo(ox+2, oy+6); ctx.lineTo(ox+10, oy+14);
      ctx.stroke();
    }

    function drawMetal(ctx, tx, ty, base, seedBase){
      drawNoiseTile(ctx, tx, ty, base, [255,255,255], 0.06, 18, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      ctx.fillStyle="rgba(255,255,255,0.12)";
      ctx.fillRect(ox+2, oy+2, 5, 2);
      ctx.fillRect(ox+3, oy+4, 3, 1);
      ctx.fillStyle="rgba(0,0,0,0.18)";
      ctx.fillRect(ox+1, oy+13, 14, 1);
    }

    function drawTNT(ctx, tx, ty, variant){
      const ox=tx*TILE, oy=ty*TILE;
      if (variant === "top") {
        drawNoiseTile(ctx, tx, ty, [205, 82, 82], [255,255,255], 0.02, 10, 12345);
        ctx.fillStyle="rgba(0,0,0,0.35)";
        ctx.fillRect(ox, oy+5, TILE, 1);
        ctx.fillRect(ox, oy+10, TILE, 1);
      } else if (variant === "bottom") {
        drawNoiseTile(ctx, tx, ty, [150, 60, 60], [255,255,255], 0.01, 10, 54321);
        ctx.fillStyle="rgba(0,0,0,0.25)";
        ctx.fillRect(ox, oy+7, TILE, 1);
      } else {
        // side
        drawNoiseTile(ctx, tx, ty, [215, 88, 88], [255,255,255], 0.02, 10, 9999);
        ctx.fillStyle="rgba(255,255,255,0.55)";
        ctx.fillRect(ox, oy+5, TILE, 6);
        ctx.fillStyle="rgba(0,0,0,0.55)";
        ctx.fillRect(ox, oy+5, TILE, 1);
        ctx.fillRect(ox, oy+10, TILE, 1);
        // fake "TNT" letters (pixel-ish)
        ctx.fillStyle="rgba(0,0,0,0.65)";
        ctx.fillRect(ox+3, oy+7, 10, 2);
      }
    }

    function drawWool(ctx, tx, ty, base, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, base, [255,255,255], 0.06, 12, seedBase);
      // weave
      for (let y=0; y<TILE; y+=2){
        for (let x=(y%4===0?0:1); x<TILE; x+=2){
          ctx.fillStyle="rgba(0,0,0,0.06)";
          ctx.fillRect(ox+x, oy+y, 1, 1);
        }
      }
    }

    function drawWater(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [50, 120, 240], [90, 160, 255], 0.12, 14, seedBase);
      for (let y=0; y<TILE; y++){
        const a = 0.10 + (y/TILE)*0.12;
        ctx.fillStyle = `rgba(255,255,255,${a})`;
        ctx.fillRect(ox, oy+y, TILE, 1);
      }
    }

    function drawLava(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [255, 120, 40], [255, 220, 120], 0.18, 18, seedBase);
      for (let i=0;i<18;i++){
        const x=(rnd01(seedBase+i*101)*TILE)|0;
        const y=(rnd01(seedBase+i*203)*TILE)|0;
        ctx.fillStyle="rgba(0,0,0,0.12)";
        ctx.fillRect(ox+x, oy+y, 2, 1);
      }
    }

    function drawBedrock(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [55,55,55], [25,25,25], 0.22, 30, seedBase);
    }

    // tile registry
    const T = {};
    function setTile(name, idx){ T[name]=idx; }

    function tileXY(idx){ return { tx: idx % ATLAS_COLS, ty: Math.floor(idx / ATLAS_COLS) }; }

    function generateAtlas() {
      const c = document.createElement("canvas");
      c.width = ATLAS_COLS * TILE;
      c.height = ATLAS_ROWS * TILE;
      const ctx = c.getContext("2d", { alpha: true });

      // assign indices
      let i=0;
      const names = [
        "grass_top","grass_side","dirt","cobble","log_side","log_top","planks","leaves",
        "sand","glass","bricks","obsidian","gold","diamond","tnt_side","tnt_top",
        "tnt_bottom","wool_white","wool_red","wool_blue","wool_green","water","lava","bedrock"
      ];
      for (const n of names) setTile(n, i++);

      // draw tiles
      {
        const a = tileXY(T.grass_top);  drawGrassTop(ctx, a.tx, a.ty, 101);
        const b = tileXY(T.grass_side); drawGrassSide(ctx, b.tx, b.ty, 202);
        const c2 = tileXY(T.dirt);      drawNoiseTile(ctx, c2.tx, c2.ty, [138, 90, 43], [120, 70, 28], 0.10, 26, 303);
        const d = tileXY(T.cobble);     drawCobble(ctx, d.tx, d.ty, 404);
        const e = tileXY(T.log_side);   drawLogSide(ctx, e.tx, e.ty, 505);
        const f = tileXY(T.log_top);    drawLogTop(ctx, f.tx, f.ty, 606);
        const g = tileXY(T.planks);     drawPlanks(ctx, g.tx, g.ty, 707);
        const h = tileXY(T.leaves);     drawLeaves(ctx, h.tx, h.ty, 808);
        const s = tileXY(T.sand);       drawSand(ctx, s.tx, s.ty, 909);
        const gl = tileXY(T.glass);     drawGlass(ctx, gl.tx, gl.ty);
        const br = tileXY(T.bricks);    drawBricks(ctx, br.tx, br.ty, 1111);
        const ob = tileXY(T.obsidian);  drawObsidian(ctx, ob.tx, ob.ty, 1212);
        const go = tileXY(T.gold);      drawMetal(ctx, go.tx, go.ty, [240, 205, 75], 1313);
        const di = tileXY(T.diamond);   drawMetal(ctx, di.tx, di.ty, [90, 230, 210], 1414);

        const ts = tileXY(T.tnt_side);  drawTNT(ctx, ts.tx, ts.ty, "side");
        const tt = tileXY(T.tnt_top);   drawTNT(ctx, tt.tx, tt.ty, "top");
        const tb = tileXY(T.tnt_bottom);drawTNT(ctx, tb.tx, tb.ty, "bottom");

        const ww = tileXY(T.wool_white);drawWool(ctx, ww.tx, ww.ty, [240,240,240], 1515);
        const wr = tileXY(T.wool_red);  drawWool(ctx, wr.tx, wr.ty, [210,75,75], 1616);
        const wb = tileXY(T.wool_blue); drawWool(ctx, wb.tx, wb.ty, [70,110,220], 1717);
        const wg = tileXY(T.wool_green);drawWool(ctx, wg.tx, wg.ty, [60,175,90], 1818);

        const wa = tileXY(T.water);     drawWater(ctx, wa.tx, wa.ty, 1919);
        const la = tileXY(T.lava);      drawLava(ctx, la.tx, la.ty, 2020);
        const be = tileXY(T.bedrock);   drawBedrock(ctx, be.tx, be.ty, 2121);
      }

      // small atlas padding: crisp borders (optional)
      // no-op; we rely on nearest filtering + exact UVs.

      return c;
    }

    const atlasCanvas = generateAtlas();
    const atlasURL = atlasCanvas.toDataURL("image/png");

    // Create Three.js texture
    const atlasTex = new THREE.CanvasTexture(atlasCanvas);
    atlasTex.colorSpace = THREE.SRGBColorSpace;
    atlasTex.magFilter = THREE.NearestFilter;
    atlasTex.minFilter = THREE.NearestFilter;
    atlasTex.generateMipmaps = false;

    // ======================================================
    // UV-mapped box geometries per block
    // ======================================================
    const atlasW = ATLAS_COLS * TILE;
    const atlasH = ATLAS_ROWS * TILE;

    function tileUVRect(tileIdx) {
      const tx = tileIdx % ATLAS_COLS;
      const ty = Math.floor(tileIdx / ATLAS_COLS);
      const u0 = (tx * TILE) / atlasW;
      const v0 = 1 - ((ty + 1) * TILE) / atlasH;
      const u1 = ((tx + 1) * TILE) / atlasW;
      const v1 = 1 - (ty * TILE) / atlasH;
      return {u0,v0,u1,v1};
    }

    function makeUVBox(tilesByFace) {
      // Face order for BoxGeometry: +x, -x, +y, -y, +z, -z (24 uvs, 4 per face)
      const g = new THREE.BoxGeometry(1,1,1);
      const uv = g.attributes.uv;
      const faces = [0,1,2,3,4,5];
      for (const f of faces) {
        const t = tilesByFace[f];
        const r = tileUVRect(t);
        const base = f * 4;
        // BoxGeometry uses 4 verts per face; assign in a consistent winding.
        // (u0,v1) (u1,v1) (u0,v0) (u1,v0) matches typical quad mapping.
        uv.setXY(base + 0, r.u0, r.v1);
        uv.setXY(base + 1, r.u1, r.v1);
        uv.setXY(base + 2, r.u0, r.v0);
        uv.setXY(base + 3, r.u1, r.v0);
      }
      uv.needsUpdate = true;
      return g;
    }

    // Per-block face tiles
    // faces: 0 +x, 1 -x, 2 +y(top), 3 -y(bottom), 4 +z, 5 -z
    function allFaces(tile) { return [tile,tile,tile,tile,tile,tile]; }

    const geomFor = new Map();
    const faceTilesFor = new Map();
    function defGeom(blockId, faceTiles) {
      faceTilesFor.set(blockId, faceTiles);
      geomFor.set(blockId, makeUVBox(faceTiles));
    }

// define tile sets
    defGeom(B.GRASS,  [T.grass_side, T.grass_side, T.grass_top, T.dirt,      T.grass_side, T.grass_side]);
    defGeom(B.DIRT,   allFaces(T.dirt));
    defGeom(B.COBBLE, allFaces(T.cobble));
    defGeom(B.LOG,    [T.log_side,   T.log_side,   T.log_top,   T.log_top,   T.log_side,   T.log_side]);
    defGeom(B.PLANKS, allFaces(T.planks));
    defGeom(B.LEAVES, allFaces(T.leaves));
    defGeom(B.SAND,   allFaces(T.sand));
    defGeom(B.GLASS,  allFaces(T.glass));
    defGeom(B.BRICKS, allFaces(T.bricks));
    defGeom(B.OBSIDIAN, allFaces(T.obsidian));
    defGeom(B.GOLD,   allFaces(T.gold));
    defGeom(B.DIAMOND,allFaces(T.diamond));
    defGeom(B.TNT,    [T.tnt_side,   T.tnt_side,   T.tnt_top,   T.tnt_bottom,T.tnt_side,   T.tnt_side]);
    defGeom(B.WOOL_WHITE, allFaces(T.wool_white));
    defGeom(B.WOOL_RED,   allFaces(T.wool_red));
    defGeom(B.WOOL_BLUE,  allFaces(T.wool_blue));
    defGeom(B.WOOL_GREEN, allFaces(T.wool_green));
    defGeom(B.WATER,  allFaces(T.water));
    defGeom(B.LAVA,   allFaces(T.lava));
    defGeom(B.BEDROCK,allFaces(T.bedrock));

    // shared materials
    const matOpaque = new THREE.MeshLambertMaterial({ map: atlasTex });
    const matGlass  = new THREE.MeshLambertMaterial({ map: atlasTex, alphaTest: 0.30, transparent: false, depthWrite: true, depthTest: true });
    const matWater  = new THREE.MeshLambertMaterial({ map: atlasTex, transparent: true, opacity: 0.65, depthWrite: true });
    const matLava   = new THREE.MeshLambertMaterial({ map: atlasTex, transparent: true, opacity: 0.85, depthWrite: true });

    function materialFor(id) {
      if (id === B.GLASS) return matGlass;
      if (id === B.WATER) return matWater;
      if (id === B.LAVA)  return matLava;
      return matOpaque;
    }

    // palette list with icons + names
    const BLOCK_LIST = [
      { id: B.GRASS, name: "Grass", icon: T.grass_top },
      { id: B.DIRT, name: "Dirt", icon: T.dirt },
      { id: B.COBBLE, name: "Cobblestone", icon: T.cobble },
      { id: B.LOG, name: "Oak Log", icon: T.log_top },
      { id: B.PLANKS, name: "Oak Planks", icon: T.planks },
      { id: B.LEAVES, name: "Leaves", icon: T.leaves },
      { id: B.SAND, name: "Sand", icon: T.sand },
      { id: B.GLASS, name: "Glass", icon: T.glass },
      { id: B.BRICKS, name: "Bricks", icon: T.bricks },
      { id: B.OBSIDIAN, name: "Obsidian", icon: T.obsidian },
      { id: B.GOLD, name: "Gold Block", icon: T.gold },
      { id: B.DIAMOND, name: "Diamond Block", icon: T.diamond },
      { id: B.TNT, name: "TNT", icon: T.tnt_side },
      { id: B.WOOL_WHITE, name: "White Wool", icon: T.wool_white },
      { id: B.WOOL_RED, name: "Red Wool", icon: T.wool_red },
      { id: B.WOOL_BLUE, name: "Blue Wool", icon: T.wool_blue },
      { id: B.WOOL_GREEN, name: "Green Wool", icon: T.wool_green },
      { id: B.WATER, name: "Water (static)", icon: T.water },
      { id: B.LAVA, name: "Lava (static)", icon: T.lava },
      { id: B.BEDROCK, name: "Bedrock", icon: T.bedrock },
    ];

    function blockName(id) {
      const f = BLOCK_LIST.find(b => b.id === id);
      return f ? f.name : "?";
    }
    function blockIcon(id) {
      const f = BLOCK_LIST.find(b => b.id === id);
      return f ? f.icon : T.dirt;
    }

    function applyTileStyle(el, tileIdx) {
      // IMPORTANT: scale atlas so a 16px tile maps cleanly into the UI icon box.
      // Otherwise a 28x28 element would show parts of neighboring tiles (glitchy icons).
      const tx = tileIdx % ATLAS_COLS;
      const ty = Math.floor(tileIdx / ATLAS_COLS);
      el.style.backgroundImage = `url(${atlasURL})`;
      el.style.backgroundRepeat = "no-repeat";
      el.style.backgroundSize = `${ATLAS_COLS*ICON_PX}px ${ATLAS_ROWS*ICON_PX}px`;
      el.style.backgroundPosition = `-${tx*ICON_PX}px -${ty*ICON_PX}px`;
    }

    // ======================================================
    // Look controls
    // ======================================================
    let lookMode = "drag";
    let yaw = 0, pitch = 0;
    const SENS = 0.0025;
    const PITCH_LIMIT = Math.PI/2 - 0.01;

    function applyLook() { camera.rotation.y = yaw; camera.rotation.x = pitch; }
    function rotateBy(dx, dy) {
      yaw   -= dx * SENS;
      pitch -= dy * SENS;
      pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      applyLook();
    }
    function isLocked() { return document.pointerLockElement === renderer.domElement; }

    let rmbDown = false;
    let rmbMoved = 0;
    let rmbStartT = 0;
    let lastX = 0, lastY = 0;

    function startDragLook(clientX, clientY) {
      rmbDown = true; rmbMoved = 0; rmbStartT = performance.now();
      lastX = clientX; lastY = clientY;
      renderer.domElement.style.cursor = "none";
      updateHelp();
    }
    function stopDragLook() {
      rmbDown = false;
      renderer.domElement.style.cursor = "";
      updateHelp();
    }

    // ======================================================
    // UI state
    // ======================================================
    let inventoryOpen = false;

    let chatOpen = false;
    const chatMessages = [];
    const CHAT_MAX = 30;
    const CHAT_SHOW_MS = 12000;

    // ======================================================
    // Game mode + Survival stats
    // ======================================================
    let gameMode = "creative"; // "creative" | "survival"
    const SURV_MAX = 20; // 20 HP (10 hearts) / 20 hunger (10 drumsticks)
    let health = SURV_MAX;
    let hunger = SURV_MAX;
    let armor = 0; // reserved (no armor items yet)
    let exhaustion = 0; // drains hunger over time
    let regenTimer = 0;
    let starveTimer = 0;

    // fall tracking (survival)
    let fallPeakY = 0;
    let wasOnGround = false;

    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    function renderStatusHud() {
      const show = (gameMode === "survival");
      statusHudEl.style.display = show ? "flex" : "none";
      if (!show) return;

      // Armor row is only shown in Minecraft when armor > 0.
      armorRowEl.style.display = (armor > 0) ? "flex" : "none";

      for (let i=0;i<10;i++) {
        const a = armor - i*2;
        armorIcons[i].style.backgroundPosition = `-${(a>=2?uiIcons.armorFull:(a===1?uiIcons.armorHalf:uiIcons.armorEmpty))*UI_ICON_PX}px 0px`;

        const hp = health - i*2;
        healthIcons[i].style.backgroundPosition = `-${(hp>=2?uiIcons.heartFull:(hp===1?uiIcons.heartHalf:uiIcons.heartEmpty))*UI_ICON_PX}px 0px`;

        const hu = hunger - i*2;
        hungerIcons[i].style.backgroundPosition = `-${(hu>=2?uiIcons.hungerFull:(hu===1?uiIcons.hungerHalf:uiIcons.hungerEmpty))*UI_ICON_PX}px 0px`;
      }
    }

    function setGameMode(mode, announce=true) {
      const m = (mode === "c" ? "creative" : mode === "s" ? "survival" : mode);
      if (m !== "creative" && m !== "survival") return false;
      if (gameMode === m) { renderStatusHud(); return true; }
      gameMode = m;
      if (gameMode === "survival") {
        // Survival: ensure flight is off and reset fall tracking.
        flyMode = false;
        fallPeakY = player ? player.pos.y : 0;
        wasOnGround = false;
      }
      if (announce) {
        addChatMessage(`Set own game mode to ${gameMode === "creative" ? "Creative" : "Survival"}`);
      }
      renderStatusHud();
      updateHelp();
      return true;
    }

    function damagePlayer(amount, cause="") {
      if (gameMode !== "survival") return;
      const a = Math.max(0, amount|0);
      if (!a) return;
      health = clamp(health - a, 0, SURV_MAX);
      renderStatusHud();
      if (health <= 0) {
        addChatMessage("You died");
        // Respawn at local surface.
        try {
          health = SURV_MAX;
          hunger = SURV_MAX;
          exhaustion = 0;
          regenTimer = 0;
          starveTimer = 0;
          const sx = Math.floor(player.pos.x);
          const sz = Math.floor(player.pos.z);
          const top = surfaceY(sx, sz);
          player.pos.set(sx + 0.5, top + 2.0, sz + 0.5);
          player.velY = 0;
          player.onGround = false;
          fallPeakY = player.pos.y;
          syncCamera();
        } catch (_) {
          // If anything about spawn isn't ready, just reset stats.
        }
        renderStatusHud();
      }
    }
    function exitPointerLock() {
      try { if (document.pointerLockElement) document.exitPointerLock(); } catch (_) {}
    }
    function gameActive() { return menuOverlay.style.display === "none" && !inventoryOpen && !chatOpen; }

    function setMenu(open) {
      menuOverlay.style.display = open ? "grid" : "none";
      if (open && chatOpen) setChat(false);
      lmbHeld = false; rmbHeld = false;
      if (open) exitPointerLock();
      updateHelp();
    }
    function setInventory(open) {
      inventoryOpen = open;
      if (open && chatOpen) setChat(false);
      invOverlay.style.display = open ? "grid" : "none";
      lmbHeld = false; rmbHeld = false;
      if (open) {
        exitPointerLock();
        rmbDown = false;
        renderer.domElement.style.cursor = "";
        setTimeout(() => { try { searchEl.focus(); } catch(_) {} }, 0);
      }
      updateHelp();
    }

// ======================================================
// Chat (Minecraft-ish)
// ======================================================
function addChatMessage(text) {
  chatMessages.push({ text, t: performance.now() });
  if (chatMessages.length > CHAT_MAX) chatMessages.splice(0, chatMessages.length - CHAT_MAX);
  renderChat();
}

function renderChat() {
  const now = performance.now();
  const showAll = chatOpen;

  // If the user has scrolled up in open chat, don't yank them back down.
  const wasAtBottom = !showAll ? true
    : (chatLogEl.scrollTop + chatLogEl.clientHeight >= chatLogEl.scrollHeight - 6);

  chatLogEl.innerHTML = "";

  if (showAll) {
    // Show full recent history (CHAT_MAX), scrollable.
    for (const m of chatMessages) {
      const div = document.createElement("div");
      div.className = "chatLine";
      div.style.opacity = "1";
      div.textContent = m.text;
      chatLogEl.appendChild(div);
    }
    chatLogEl.style.overflowY = "auto";
  } else {
    // Show a few recent lines with fade-out.
    const lines = [];
    for (let i = chatMessages.length - 1; i >= 0; i--) {
      const m = chatMessages[i];
      const age = now - m.t;
      if (age > CHAT_SHOW_MS) break;

      const op = Math.max(0, Math.min(1, 1 - age / CHAT_SHOW_MS));
      lines.push({ text: m.text, op });

      // Keep the on-screen chat compact (about half the previous height).
      if (lines.length >= 6) break;
    }
    lines.reverse();

    for (const l of lines) {
      const div = document.createElement("div");
      div.className = "chatLine";
      div.style.opacity = String(l.op);
      div.textContent = l.text;
      chatLogEl.appendChild(div);
    }

    chatLogEl.style.overflowY = "hidden";
    chatLogEl.scrollTop = chatLogEl.scrollHeight;
  }

  chatInputRow.style.display = chatOpen ? "block" : "none";
  chatWrap.style.pointerEvents = chatOpen ? "auto" : "none";

  // Auto-scroll to bottom when opening chat / sending messages (unless user scrolled up).
  if (chatOpen && wasAtBottom) {
    chatLogEl.scrollTop = chatLogEl.scrollHeight;
  }
}

function setChat(open) {
  chatOpen = open;
  if (open) {
    exitPointerLock();
    rmbDown = false;
    renderer.domElement.style.cursor = "";
    setTimeout(() => { try { chatInputEl.focus(); } catch(_) {} }, 0);
  } else {
    try { chatInputEl.blur(); } catch(_) {}
    if (menuOverlay.style.display === "none" && !inventoryOpen) resumeGameTryLock();
  }
  renderChat();
  updateHelp();
}

function handleChatSend(msg) {
  // Commands
  if (msg.startsWith("/")) {
    const parts = msg.slice(1).trim().split(/\s+/).filter(Boolean);
    const cmd = (parts[0] || "").toLowerCase();
    if (cmd === "gamemode" || cmd === "gm") {
      const arg = (parts[1] || "").toLowerCase();
      if (!arg) {
        addChatMessage("Usage: /gamemode <survival|s|creative|c>");
        return;
      }
      if (arg === "survival" || arg === "s" || arg === "0") {
        setGameMode("survival");
        return;
      }
      if (arg === "creative" || arg === "c" || arg === "1") {
        setGameMode("creative");
        return;
      }
      addChatMessage(`Unknown game mode: ${arg}`);
      return;
    }
    addChatMessage(`Unknown command: ${msg}`);
    return;
  }

  addChatMessage(msg);
}

chatInputEl.addEventListener("keydown", (e) => {
  if (e.code === "Enter") {
    e.preventDefault();
    const msg = chatInputEl.value.trim();
    if (msg) handleChatSend(msg);
    chatInputEl.value = "";
    setChat(false);
  } else if (e.code === "Escape") {
    e.preventDefault();
    chatInputEl.value = "";
    setChat(false);
  }
  e.stopPropagation();
});

    function requestPointerLock() {
      try { renderer.domElement.requestPointerLock(); } catch (_) {}
    }
    function resumeGameTryLock() {
      if (!gameActive()) return;
      lookMode = "drag";
      requestPointerLock();
      setTimeout(() => { if (!isLocked()) lookMode = "drag"; updateHelp(); }, 180);
    }

    function startGame() {
      setMenu(false);
      setInventory(false);
      renderer.domElement.focus({ preventScroll: true });
      resumeGameTryLock();
      updateHelp();
    }

    playBtn.addEventListener("click", (e) => { e.preventDefault(); startGame(); });
    invClose.addEventListener("click", (e) => { e.preventDefault(); setInventory(false); resumeGameTryLock(); });
    renderer.domElement.addEventListener("mousedown", () => { if (gameActive() && !isLocked()) resumeGameTryLock(); });

    document.addEventListener("pointerlockchange", () => {
      if (isLocked()) lookMode = "pointerlock";
      else if (lookMode === "pointerlock" && gameActive()) setMenu(true);
      updateHelp();
    });
    document.addEventListener("pointerlockerror", () => { lookMode = "drag"; updateHelp(); });

    // ======================================================
    // Input
    // ======================================================
    const keys = new Set();

// Creative fly mode (double-tap Space to toggle)
let flyMode = false;
let lastSpaceTapTime = 0;
const DOUBLE_SPACE_MS = 260;
const FLY_SPEED_MULT = 3.0; // ~3x run speed (run = sprint speed)

function toggleFly() {
  if (gameMode !== "creative") return;
  flyMode = !flyMode;
  // Ensure stable transitions
  try { player.velY = 0; player.onGround = false; } catch(_) {}
  updateHelp();
}


// Mouse hold actions (continuous mine/place)
let lmbHeld = false;
let rmbHeld = false;
let lastMineTime = 0;
let lastPlaceTime = 0;
const MINE_INTERVAL_MS = 110;  // continuous mining rate
const PLACE_INTERVAL_MS = 120; // continuous placing rate


    window.addEventListener("keydown", (e) => {

// Chat toggle
if (chatOpen) {
  if (e.code === "Escape") { e.preventDefault(); setChat(false); return; }
  return; // don't feed movement/hotkeys while chatting
}
if (e.code === "KeyT") {
  e.preventDefault();
  keys.delete("KeyT");
  if (menuOverlay.style.display !== "none") return;
  if (inventoryOpen) return;
  setChat(true);
  return;
}
      if (e.code === "KeyE" || e.code === "Escape") e.preventDefault();
      keys.add(e.code);

      if (e.code === "KeyE") {
        keys.delete("KeyE");
        if (menuOverlay.style.display !== "none") return;
        setInventory(!inventoryOpen);
        if (!inventoryOpen) resumeGameTryLock();
        return;
      }

      if (e.code === "Escape" && !isLocked()) {
        keys.delete("Escape");
        if (inventoryOpen) { setInventory(false); resumeGameTryLock(); }
        else setMenu(true);
        return;
      }

      if (e.code.startsWith("Digit")) {
        const n = Number(e.code.slice(5));
        if (n >= 1 && n <= 9) selectHotbar(n - 1);
      }

      // Double-tap Space to toggle creative fly mode
      if (e.code === "Space" && !e.repeat && gameActive() && gameMode === "creative") {
        e.preventDefault();
        const now = performance.now();
        if (now - lastSpaceTapTime <= DOUBLE_SPACE_MS) {
          lastSpaceTapTime = 0;
          toggleFly();
        } else {
          lastSpaceTapTime = now;
        }
      }
    });
    window.addEventListener("keyup", (e) => keys.delete(e.code));
    window.addEventListener("contextmenu", (e) => e.preventDefault());

    window.addEventListener("mousemove", (e) => {
      if (!gameActive()) return;
      if (isLocked()) { rotateBy(e.movementX || 0, e.movementY || 0); return; }
      if (lookMode === "drag" && rmbDown) {
        const dx = (typeof e.movementX === "number") ? e.movementX : (e.clientX - lastX);
        const dy = (typeof e.movementY === "number") ? e.movementY : (e.clientY - lastY);
        lastX = e.clientX; lastY = e.clientY;
        rmbMoved += Math.abs(dx) + Math.abs(dy);
        rotateBy(dx, dy);
      }
    }, { passive: true });

    // ======================================================
    // Minecraft-ish fractal world gen (FBM + ridged noise)
    // - Much larger scale features (real mountains)
    // - Taller WORLD_H so peaks don't get squashed
    // - Column memo so meshing doesn't re-run noise per-voxel
    // ======================================================
        // World seed (random by default; set ?seed=12345 to reproduce)
    const WORLD_SEED = (() => {
      const qs = new URLSearchParams(location.search);
      const raw = qs.get("seed");

      function fnv1a32(str) {
        let h = 0x811c9dc5;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 0x01000193);
        }
        return h >>> 0;
      }

      if (raw !== null && raw !== "") {
        const n = Number(raw);
        if (Number.isFinite(n)) return (n >>> 0);
        return fnv1a32(raw);
      }

      try {
        const a = new Uint32Array(1);
        crypto.getRandomValues(a);
        return a[0] >>> 0;
      } catch (_) {
        return ((Date.now() ^ (Math.random() * 0xFFFFFFFF)) >>> 0);
      }
    })();


    
function smoothstep(edge0, edge1, x) {
  const t = clamp01((x - edge0) / (edge1 - edge0));
  return t * t * (3 - 2 * t);
}

function hash2i(x, z) {
      const SA = WORLD_SEED | 0;
      const SB = Math.imul(WORLD_SEED, 0x9e3779b9) | 0;
      let n = Math.imul(((x | 0) ^ SA), 374761393) + Math.imul(((z | 0) ^ SB), 668265263);
n = (n ^ (n >>> 13)) >>> 0;
      n = Math.imul(n, 1274126177) >>> 0;
      n = (n ^ (n >>> 16)) >>> 0;
      return n >>> 0;
    }
    function hash2f(x, z) { return hash2i(x, z) / 4294967295; }

    function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    function grad2(h, x, y) {
      // 8-ish gradient directions (cheap + stable)
      switch (h & 7) {
        case 0: return  x + y;
        case 1: return -x + y;
        case 2: return  x - y;
        case 3: return -x - y;
        case 4: return  x;
        case 5: return -x;
        case 6: return  y;
        default: return -y;
      }
    }
    function perlin2(x, y) {
      const xi = Math.floor(x), yi = Math.floor(y);
      const xf = x - xi,      yf = y - yi;
      const u = fade(xf),     v = fade(yf);

      const aa = hash2i(xi,     yi);
      const ba = hash2i(xi + 1, yi);
      const ab = hash2i(xi,     yi + 1);
      const bb = hash2i(xi + 1, yi + 1);

      const x1 = lerp(grad2(aa, xf,     yf),     grad2(ba, xf - 1, yf),     u);
      const x2 = lerp(grad2(ab, xf,     yf - 1), grad2(bb, xf - 1, yf - 1), u);
      // roughly normalize into [-1,1]
      return lerp(x1, x2, v) * 0.70710678;
    }

    function fbm2(x, y, octaves = 5, lacunarity = 2.0, gain = 0.5) {
      let sum = 0, amp = 1, freq = 1, norm = 0;
      for (let i = 0; i < octaves; i++) {
        sum += amp * perlin2(x * freq, y * freq);
        norm += amp;
        amp *= gain;
        freq *= lacunarity;
      }
      return sum / (norm || 1);
    }

    function ridged2(x, y, octaves = 4, lacunarity = 2.0, gain = 0.55) {
      let sum = 0, amp = 0.9, freq = 1, norm = 0;
      for (let i = 0; i < octaves; i++) {
        let n = perlin2(x * freq, y * freq);
        n = 1.0 - Math.abs(n);
        n *= n;
        sum += n * amp;
        norm += amp;
        amp *= gain;
        freq *= lacunarity;
      }
      return sum / (norm || 1);
    }

    // Column memo to avoid doing noise repeatedly for each y in the same (x,z) column.
    // This keeps WORLD_H large without tanking chunk meshing.
    const columnMemo = new Map(); // "x,z" -> {top, biome, tree}

function getColumn(x, z) {
  const key = x + "," + z;
  let c = columnMemo.get(key);
  if (c) return c;

  // --- Minecraft-ish terrain shaping (lite) ---
  // Continents (ocean vs inland), hills (roughness), and ridged peaks (mountains).
  const cont = fbm2(x * 0.0014, z * 0.0014, 4, 2.05, 0.5);   // ~[-1,1]
  const cont01 = (cont + 1) * 0.5;

  const hills = fbm2(x * 0.0060, z * 0.0060, 5, 2.0, 0.5);   // ~[-1,1]
  const ridBase = ridged2(x * 0.0032, z * 0.0032, 5, 2.0, 0.55); // [0,1]
  const ridSharp = Math.pow(ridBase, 1.7);

  // Mountain mask: makes mountains rarer + prevents continent-wide ridge biomes.
  const m0 = fbm2(x * 0.00085 + 300.0, z * 0.00085 - 120.0, 3, 2.0, 0.5); // ~[-1,1]
  const m01 = (m0 + 1) * 0.5;
  let mMask = smoothstep(0.72, 0.86, m01); // "rarity" gate (higher = rarer)

  // Breakup field: punches valleys/gaps through ranges so mountains don't become walls.
  const b0 = fbm2(x * 0.0016 - 50.0, z * 0.0016 + 90.0, 3, 2.0, 0.5); // ~[-1,1]
  const b01 = (b0 + 1) * 0.5;
  const gap = smoothstep(0.55, 0.78, b01);
  mMask *= (1.0 - gap * 0.75);

  // Height model:
  // - plains/hills stay grassy
  // - mountains become tall, but only where mMask says so (keeps width under control)
  let top = Math.floor(
    SEA_LEVEL
    + (cont01 - 0.5) * 34
    + hills * 12
    + (mMask * ridSharp) * 92
  );
  top = Math.max(3, Math.min(WORLD_H - 5, top));

  // Biomes: temperature + moisture fields
  const temp  = fbm2(x * 0.0012 + 100.0, z * 0.0012 - 40.0, 3, 2.0, 0.5);
  const moist = fbm2(x * 0.0012 - 50.0,  z * 0.0012 + 80.0, 3, 2.0, 0.5);

  // Terrain class:
  // 0 plains, 1 forest, 2 desert, 3 mountains (peaks only!)
  let biome = 0;

  // Deserts and forests set the *baseline* biome.
  if (temp > 0.35 && moist < -0.05) biome = 2;
  else if (moist > 0.25) biome = 1;

  // Mountains only on sharp/high ridgelines (prevents "plains covered in cobble").
  const isMountainPeak = (mMask > 0.35) && (ridSharp > 0.62) && (top > SEA_LEVEL + 18);
  if (isMountainPeak) biome = 3;

  // Hilliness proxy: helps place "rare trees on hills" while keeping plains mostly empty.
  const hilliness = clamp01(Math.abs(hills) * 0.65 + ridSharp * 0.55);

  // Trees (avoid deserts/mountains + avoid underwater)
  let tree = null;
  if (biome !== 2 && biome !== 3 && top >= SEA_LEVEL + 1 && top <= WORLD_H - 10) {
    // Prefer hills: plains almost bare; hills have rare trees; forests still have more (but not spammy).
    const hillOK = (hilliness > 0.38);
    const r = hash2f(x * 3, z * 3);

    let p = 0.002; // very rare on flat plains
    if (biome === 1) p = 0.018;        // forest (still spaced, but present)
    else if (hillOK) p = 0.010;        // rare trees on hills

    if (r < p) {
      const trunkH = 4 + Math.floor(hash2f(x - 11, z + 7) * 4); // 4..7
      const ly = Math.min(WORLD_H - 2, top + trunkH);
      tree = { top, trunkH, ly };
    }
  }

  c = { top, biome, tree };
  columnMemo.set(key, c);
  if (columnMemo.size > 60000) columnMemo.clear(); // bounded memory, deterministic refill
  return c;
}

    function surfaceY(x, z) { return getColumn(x, z).top; }
    function treeInfo(tx, tz) { return getColumn(tx, tz).tree; }

    function baseBlockAt(x, y, z) {
      if (y < 0 || y >= WORLD_H) return B.AIR;
      if (y === 0) return B.BEDROCK;

      const col = getColumn(x, z);
      const top = col.top;

      // trunk
      const ti = col.tree;
      if (ti && y > ti.top && y <= ti.top + ti.trunkH) return B.LOG;

      // leaves (keep the previous "plus" canopy style)
      if (y >= 4) {
        const candidates = [[x, z], [x - 1, z], [x + 1, z], [x, z - 1], [x, z + 1]];
        for (const [tx, tz] of candidates) {
          const inf = treeInfo(tx, tz);
          if (!inf) continue;
          if (y !== inf.ly) continue;
          const dx = x - tx, dz = z - tz;
          if ((dx === 0 && Math.abs(dz) <= 1) || (dz === 0 && Math.abs(dx) <= 1)) {
            if (!(dx === 0 && dz === 0)) return B.LEAVES;
          }
        }
      }

      // above ground
      if (y > top) {
        // oceans/lakes: fill up to SEA_LEVEL
        if (top < SEA_LEVEL && y <= SEA_LEVEL) return B.WATER;
        return B.AIR;
      }

      const biome = col.biome;
      const beach = (top <= SEA_LEVEL + 1);

      const surface =
        beach ? B.SAND :
        (biome === 2 ? B.SAND :
         biome === 3 ? B.COBBLE :
         B.GRASS);

      if (y === top) return surface;

      const depth = top - y;

      // sands: deeper sand before stone
      if (surface === B.SAND) {
        if (depth <= 4) return B.SAND;
        return B.COBBLE;
      }

      // mountains: more stone showing
      if (biome === 3) {
        if (depth <= 1) return B.COBBLE;
        if (depth <= 3) return B.DIRT;
        return B.COBBLE;
      }

      // plains/forest
      if (depth <= 2) return B.DIRT;
      return B.COBBLE;
    }


    // ======================================================
    // Chunk edits only (infinite world persistence in-memory)
    // ======================================================
    const chunkEdits = new Map(); // "cx,cz" -> Map(localIndex -> blockId)
    const chunkEditMaxY = new Map(); // \"cx,cz\" -> highest edited Y (for mesh scan cap)
    function chunkKey(cx, cz) { return cx + "," + cz; }

    function floorDiv(a, b) {
      const q = Math.trunc(a / b);
      return (a < 0 && a % b !== 0) ? (q - 1) : q;
    }
    function mod(a, b) {
      const m = a % b;
      return m < 0 ? m + b : m;
    }
    function localIndex(lx, y, lz) {
      return (y * CHUNK + lz) * CHUNK + lx;
    }

    function getEdit(cx, cz, lx, y, lz) {
      const m = chunkEdits.get(chunkKey(cx, cz));
      if (!m) return null;
      const v = m.get(localIndex(lx, y, lz));
      return (v === undefined) ? null : v;
    }

    function setEdit(wx, y, wz, blockId) {
      const cx = floorDiv(wx, CHUNK);
      const cz = floorDiv(wz, CHUNK);
      const lx = mod(wx, CHUNK);
      const lz = mod(wz, CHUNK);
      const key = chunkKey(cx, cz);
      let m = chunkEdits.get(key);
      if (!m) { m = new Map(); chunkEdits.set(key, m); }
      m.set(localIndex(lx, y, lz), blockId);
      // Track highest edited altitude so chunk meshing doesn't scan empty sky.
      if (blockId !== B.AIR) {
        const prev = chunkEditMaxY.get(key);
        if (prev === undefined || y > prev) chunkEditMaxY.set(key, y);
      }
    }

    function getBlock(wx, y, wz) {
      if (y < 0 || y >= WORLD_H) return B.AIR;
      const cx = floorDiv(wx, CHUNK);
      const cz = floorDiv(wz, CHUNK);
      const lx = mod(wx, CHUNK);
      const lz = mod(wz, CHUNK);
      const ev = getEdit(cx, cz, lx, y, lz);
      if (ev !== null) return ev;
      return baseBlockAt(wx, y, wz);
    }

    function isSolid(t) { return t !== B.AIR; }

    // Blocks that are visually "non-occluding" (you should still see blocks behind them).
    // If we treat these as fully solid for chunk exposure tests, blocks behind glass/water/lava
    // can disappear from the mesh and look like "x-ray" glitches.
    function isTransparentBlock(t) {
      return (t === B.GLASS || t === B.WATER || t === B.LAVA);
    }
    function occludesFace(cur, neigh) {
      // true means "neigh hides cur's face between the two blocks"
      if (!isSolid(neigh)) return false;

      const curTrans = isTransparentBlock(cur);
      const neighTrans = isTransparentBlock(neigh);

      if (!curTrans) {
        // Opaque blocks should still show faces next to transparent blocks (glass/water/lava),
        // so only opaque neighbors occlude.
        return !neighTrans;
      }

      // Transparent blocks: opaque neighbors occlude them (water against stone shouldn't draw an interior face).
      if (!neighTrans) return true;

      // Two transparent blocks only occlude if they're the same "medium" (water-water, glass-glass, lava-lava).
      return neigh === cur;
    }

    // ======================================================
    // Chunk objects + meshing (faster build via local voxel cache)
    // ======================================================
    const chunks = new Map(); // key -> {cx,cz, meshes:[]}

    function disposeChunk(chunk) {
      for (const m of chunk.meshes) {
        scene.remove(m);
        // Only dispose geometries that are generated per-chunk (face-only transparent meshes).
        if (m && m.userData && m.userData._chunkGeo && m.geometry) {
          try { m.geometry.dispose(); } catch (_) {}
        }
      }
      chunk.meshes.length = 0;
    }

function estimateChunkYMax(cx, cz) {
  const wx0 = cx * CHUNK;
  const wz0 = cz * CHUNK;

  // Always include at least around sea level so shores/water surface mesh correctly.
  let maxY = SEA_LEVEL + 10;

  for (let lz=0; lz<CHUNK; lz++) for (let lx=0; lx<CHUNK; lx++) {
    const wx = wx0 + lx;
    const wz = wz0 + lz;
    const col = getColumn(wx, wz);
    let t = col.top;
    if (col.tree) t = Math.max(t, col.top + col.tree.trunkH + 4);
    if (t > maxY) maxY = t;
  }

  const k = chunkKey(cx, cz);
  const editMax = chunkEditMaxY.get(k);
  if (editMax !== undefined) maxY = Math.max(maxY, editMax + 3);

  // Margin for player edits / overhangs (cheap safety).
  maxY = Math.min(WORLD_H - 1, maxY + 6);
  maxY = Math.max(24, maxY);
  return maxY | 0;
}

        function buildChunkMeshes(cx, cz) {
      const wx0 = cx * CHUNK;
      const wz0 = cz * CHUNK;

      // cache voxel values for the chunk (avoid scanning empty sky)
      const yMax = estimateChunkYMax(cx, cz);

      // cache voxel values for the chunk (16*16*(H) = small, avoids scanning empty sky)
      const H = Math.min(WORLD_H, yMax + 3);
      const data = new Uint8Array(CHUNK * CHUNK * H);
      const idx = (lx, lz, y) => (y * CHUNK + lz) * CHUNK + lx;

      for (let y=0; y<H; y++) {
        for (let lz=0; lz<CHUNK; lz++) for (let lx=0; lx<CHUNK; lx++) {
          const wx = wx0 + lx;
          const wz = wz0 + lz;
          data[idx(lx,lz,y)] = getBlock(wx, y, wz);
        }
      }

      function getLocal(lx,lz,y){
        if (y < 0) return B.AIR;
        if (lx>=0 && lx<CHUNK && lz>=0 && lz<CHUNK && y>=0 && y<H) return data[idx(lx,lz,y)];
        // neighbor chunk OR above cached range
        const wx = wx0 + lx;
        const wz = wz0 + lz;
        return getBlock(wx, y, wz);
      }

      // ------------------------------------------------------
      // Opaque blocks: keep instancing (fast)
      // Transparent blocks (glass/water/lava): build face-only meshes
      // so sides between adjacent transparent blocks are never visible.
      // ------------------------------------------------------

      const positions = new Map(); // opaque id -> array of {x,y,z}

      // face-only buffers for transparent blocks
      function makeBuf(){ return { pos: [], norm: [], uv: [], idx: [], v: 0 }; }
      const tbuf = new Map([
        [B.GLASS, makeBuf()],
        [B.WATER, makeBuf()],
        [B.LAVA,  makeBuf()],
      ]);

      // Transparent face visibility:
      // - Glass never draws internal faces against any solid neighbor (prevents "cross-transparency" holes).
      // - Water/Lava draw faces against AIR and against GLASS so they remain visible behind glass.
      // - Water beats Lava at water-lava boundaries to avoid coplanar z-fighting artifacts.
      function transFaceVisible(cur, neigh) {
        if (neigh === B.AIR) return true;

        if (cur === B.GLASS) return false;

        if (cur === B.WATER) {
          if (neigh === B.WATER) return false;
          if (neigh === B.LAVA)  return true;   // water wins boundary
          if (neigh === B.GLASS) return true;   // visible behind glass
          return false; // against opaque solids: hidden
        }

        if (cur === B.LAVA) {
          if (neigh === B.LAVA)  return false;
          if (neigh === B.WATER) return false;  // water wins boundary
          if (neigh === B.GLASS) return true;   // visible behind glass
          return false;
        }

        return false;
      }

      function pushFace(buf, x, y, z, face, tileIdx) {
        const r = tileUVRect(tileIdx);
        let nx=0, ny=0, nz=0;

        // 4 vertices per face (positions)
        // Vertex order is chosen so triangles are CCW when viewed from outside.
        let v0, v1, v2, v3;
        switch (face) {
          case 0: // +X
            nx=1;
            v0=[x+1, y+1, z  ]; v1=[x+1, y+1, z+1]; v2=[x+1, y,   z  ]; v3=[x+1, y,   z+1];
            break;
          case 1: // -X
            nx=-1;
            v0=[x, y+1, z+1]; v1=[x, y+1, z  ]; v2=[x, y,   z+1]; v3=[x, y,   z  ];
            break;
          case 2: // +Y (top)
            ny=1;
            // IMPORTANT: winding must be CCW when viewed from above (+Y), otherwise the face is back-culled.
            v0=[x,   y+1, z+1]; v1=[x+1, y+1, z+1]; v2=[x,   y+1, z  ]; v3=[x+1, y+1, z  ];
            break;
          case 3: // -Y (bottom)
            ny=-1;
            // CCW when viewed from below (-Y).
            v0=[x,   y, z  ]; v1=[x+1, y, z  ]; v2=[x,   y, z+1]; v3=[x+1, y, z+1];
            break;
          case 4: // +Z
            nz=1;
            v0=[x+1, y+1, z+1]; v1=[x,   y+1, z+1]; v2=[x+1, y,   z+1]; v3=[x,   y,   z+1];
            break;
          default: // 5 -Z
            nz=-1;
            v0=[x,   y+1, z  ]; v1=[x+1, y+1, z  ]; v2=[x,   y,   z  ]; v3=[x+1, y,   z  ];
            break;
        }

        const base = buf.v;

        buf.pos.push(...v0, ...v1, ...v2, ...v3);
        for (let i=0;i<4;i++) buf.norm.push(nx,ny,nz);

        // UVs: (u0,v1) (u1,v1) (u0,v0) (u1,v0)
        buf.uv.push(r.u0, r.v1,  r.u1, r.v1,  r.u0, r.v0,  r.u1, r.v0);

        // two triangles
        buf.idx.push(base, base+1, base+2,  base+2, base+1, base+3);

        buf.v += 4;
      }

      for (let lz=0; lz<CHUNK; lz++) for (let lx=0; lx<CHUNK; lx++) {
        const wx = wx0 + lx;
        const wz = wz0 + lz;

        for (let y=0; y<=yMax; y++) {
          const t = getLocal(lx,lz,y);
          if (!isSolid(t)) continue;

          // Transparent blocks: draw only faces that are actually visible (AIR, and fluids behind glass).
          if (isTransparentBlock(t)) {
            const buf = tbuf.get(t);
            if (!buf) continue;

            const tiles = faceTilesFor.get(t) || faceTilesFor.get(B.DIRT);

            // Neighbor offsets in the same face order as the tile array:
            // 0 +x, 1 -x, 2 +y, 3 -y, 4 +z, 5 -z
            const n0 = getLocal(lx+1,lz,y);
            const n1 = getLocal(lx-1,lz,y);
            const n2 = getLocal(lx,lz,y+1);
            const n3 = getLocal(lx,lz,y-1);
            const n4 = getLocal(lx,lz+1,y);
            const n5 = getLocal(lx,lz-1,y);

            if (transFaceVisible(t, n0)) pushFace(buf, wx, y, wz, 0, tiles[0]);
            if (transFaceVisible(t, n1)) pushFace(buf, wx, y, wz, 1, tiles[1]);
            if (transFaceVisible(t, n2)) pushFace(buf, wx, y, wz, 2, tiles[2]);
            if (transFaceVisible(t, n3)) pushFace(buf, wx, y, wz, 3, tiles[3]);
            if (transFaceVisible(t, n4)) pushFace(buf, wx, y, wz, 4, tiles[4]);
            if (transFaceVisible(t, n5)) pushFace(buf, wx, y, wz, 5, tiles[5]);

            continue;
          }

          // Opaque blocks: keep the existing "exposed block" test and instancing.
          const exposed =
            !occludesFace(t, getLocal(lx+1,lz,y)) || !occludesFace(t, getLocal(lx-1,lz,y)) ||
            !occludesFace(t, getLocal(lx,lz,y+1)) || !occludesFace(t, getLocal(lx,lz,y-1)) ||
            !occludesFace(t, getLocal(lx,lz+1,y)) || !occludesFace(t, getLocal(lx,lz-1,y));

          if (!exposed) continue;

          if (!positions.has(t)) positions.set(t, []);
          positions.get(t).push({x: wx, y, z: wz});
        }
      }

      const meshes = [];
      const mtx = new THREE.Matrix4();

      // Opaque instanced meshes
      for (const [id, list] of positions.entries()) {
        const g = geomFor.get(id) || geomFor.get(B.DIRT);
        const mat = materialFor(id);
        const mesh = new THREE.InstancedMesh(g, mat, list.length);
        mesh.frustumCulled = true;
        for (let i=0; i<list.length; i++) {
          const p = list[i];
          mtx.makeTranslation(p.x + 0.5, p.y + 0.5, p.z + 0.5);
          mesh.setMatrixAt(i, mtx);
        }
        mesh.instanceMatrix.needsUpdate = true;
        meshes.push(mesh);
      }

      // Transparent face-only meshes
      function makeMeshFromBuf(id, buf) {
        if (!buf || buf.v === 0) return null;
        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.BufferAttribute(new Float32Array(buf.pos), 3));
        g.setAttribute("normal",   new THREE.BufferAttribute(new Float32Array(buf.norm), 3));
        g.setAttribute("uv",       new THREE.BufferAttribute(new Float32Array(buf.uv), 2));
        // indices
        const IndexArr = (buf.v > 65535) ? Uint32Array : Uint16Array;
        g.setIndex(new THREE.BufferAttribute(new IndexArr(buf.idx), 1));
        g.computeBoundingSphere();
        const mesh = new THREE.Mesh(g, materialFor(id));
        mesh.userData._chunkGeo = true;
        mesh.frustumCulled = true;
        return mesh;
      }

      for (const [id, buf] of tbuf.entries()) {
        const mesh = makeMeshFromBuf(id, buf);
        if (mesh) meshes.push(mesh);
      }

      return meshes;
    }

    function loadChunk(cx, cz) {
      const key = chunkKey(cx, cz);
      if (chunks.has(key)) return;
      const chunk = { cx, cz, meshes: [] };
      chunk.meshes = buildChunkMeshes(cx, cz);
      for (const m of chunk.meshes) scene.add(m);
      chunks.set(key, chunk);
    }

    function rebuildChunk(cx, cz) {
      const key = chunkKey(cx, cz);
      const chunk = chunks.get(key);
      if (!chunk) return;
      disposeChunk(chunk);
      chunk.meshes = buildChunkMeshes(cx, cz);
      for (const m of chunk.meshes) scene.add(m);
    }

    function markChunksDirtyForBlock(wx, wz) {
      const cx = floorDiv(wx, CHUNK);
      const cz = floorDiv(wz, CHUNK);
      rebuildChunk(cx, cz);

      const lx = mod(wx, CHUNK);
      const lz = mod(wz, CHUNK);
      if (lx === 0) rebuildChunk(cx - 1, cz);
      if (lx === CHUNK - 1) rebuildChunk(cx + 1, cz);
      if (lz === 0) rebuildChunk(cx, cz - 1);
      if (lz === CHUNK - 1) rebuildChunk(cx, cz + 1);
    }

    function updateChunkStreaming(playerX, playerZ) {
      const pcx = floorDiv(Math.floor(playerX), CHUNK);
      const pcz = floorDiv(Math.floor(playerZ), CHUNK);

      const want = new Set();
      for (let dz=-RADIUS; dz<=RADIUS; dz++) for (let dx=-RADIUS; dx<=RADIUS; dx++) {
        want.add(chunkKey(pcx + dx, pcz + dz));
      }

      // unload
      for (const [key, chunk] of chunks.entries()) {
        if (!want.has(key)) {
          disposeChunk(chunk);
          chunks.delete(key);
        }
      }

      // load missing nearest-first (limited per frame)
      const missing = [];
      for (let dz=-RADIUS; dz<=RADIUS; dz++) for (let dx=-RADIUS; dx<=RADIUS; dx++) {
        const cx = pcx + dx, cz = pcz + dz;
        const key = chunkKey(cx, cz);
        if (!chunks.has(key)) missing.push({cx, cz, d2: dx*dx + dz*dz});
      }
      missing.sort((a,b) => a.d2 - b.d2);

      for (let i=0; i<Math.min(MAX_LOADS_PER_FRAME, missing.length); i++) {
        loadChunk(missing[i].cx, missing[i].cz);
      }
    }

    // ======================================================
    // Highlight
    // ======================================================
    const highlight = new THREE.Mesh(
      new THREE.BoxGeometry(1.01, 1.01, 1.01),
      new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.35 })
    );
    highlight.visible = false;
    scene.add(highlight);

    function blockCenter(x,y,z) { return new THREE.Vector3(x+0.5, y+0.5, z+0.5); }

    // ======================================================
    // Fast voxel raycast (DDA): replaces Three.js raycaster
    // ======================================================
    function voxelRaycast(origin, dir, maxDist) {
      // origin: Vector3; dir: normalized Vector3
      let x = Math.floor(origin.x);
      let y = Math.floor(origin.y);
      let z = Math.floor(origin.z);

      const stepX = dir.x > 0 ? 1 : -1;
      const stepY = dir.y > 0 ? 1 : -1;
      const stepZ = dir.z > 0 ? 1 : -1;

      const tDeltaX = dir.x === 0 ? 1e30 : Math.abs(1 / dir.x);
      const tDeltaY = dir.y === 0 ? 1e30 : Math.abs(1 / dir.y);
      const tDeltaZ = dir.z === 0 ? 1e30 : Math.abs(1 / dir.z);

      const nextVoxelBoundary = (p, i, step) => step > 0 ? (i + 1) : i; // boundary coordinate
      let tMaxX = dir.x === 0 ? 1e30 : (nextVoxelBoundary(origin.x, x, stepX) - origin.x) / dir.x;
      let tMaxY = dir.y === 0 ? 1e30 : (nextVoxelBoundary(origin.y, y, stepY) - origin.y) / dir.y;
      let tMaxZ = dir.z === 0 ? 1e30 : (nextVoxelBoundary(origin.z, z, stepZ) - origin.z) / dir.z;

      // If we start inside a solid block, count it.
      if (y >= 0 && y < WORLD_H && isSolid(getBlock(x,y,z))) {
        return { x, y, z, nx: 0, ny: 0, nz: 0, dist: 0 };
      }

      let nx=0, ny=0, nz=0;
      let t = 0;

      // upper bound on steps
      const maxSteps = 256;
      for (let i=0; i<maxSteps; i++) {
        if (t > maxDist) break;

        if (tMaxX < tMaxY && tMaxX < tMaxZ) {
          x += stepX;
          t = tMaxX;
          tMaxX += tDeltaX;
          nx = -stepX; ny = 0; nz = 0;
        } else if (tMaxY < tMaxZ) {
          y += stepY;
          t = tMaxY;
          tMaxY += tDeltaY;
          nx = 0; ny = -stepY; nz = 0;
        } else {
          z += stepZ;
          t = tMaxZ;
          tMaxZ += tDeltaZ;
          nx = 0; ny = 0; nz = -stepZ;
        }

        if (y < 0 || y >= WORLD_H) continue;
        const b = getBlock(x, y, z);
        if (isSolid(b)) {
          return { x, y, z, nx, ny, nz, dist: t };
        }
      }
      return null;
    }

    // ======================================================
    // Player physics
    // ======================================================
    const player = { pos: new THREE.Vector3(0.5, WORLD_H - 4, 0.5), velY: 0, onGround: false };

    function aabbCollides(feetPos) {
      const r=PLAYER.radius, h=PLAYER.height;
      const minX=feetPos.x-r, maxX=feetPos.x+r;
      const minY=feetPos.y,   maxY=feetPos.y+h;
      const minZ=feetPos.z-r, maxZ=feetPos.z+r;

      const x0=Math.floor(minX), x1=Math.floor(maxX);
      const y0=Math.floor(minY), y1=Math.floor(maxY);
      const z0=Math.floor(minZ), z1=Math.floor(maxZ);

      for (let x=x0; x<=x1; x++) for (let y=y0; y<=y1; y++) for (let z=z0; z<=z1; z++) {
        if (!isSolid(getBlock(x,y,z))) continue;
        if ((minX < x+1 && maxX > x) && (minY < y+1 && maxY > y) && (minZ < z+1 && maxZ > z)) return true;
      }
      return false;
    }

    function tryMoveAxis(axis, amount) {
      if (!amount) return false;
      player.pos[axis] += amount;
      if (aabbCollides(player.pos)) { player.pos[axis] -= amount; return true; }
      return false;
    }

    function playerOverlapsBlock(x,y,z) {
      const r=PLAYER.radius, h=PLAYER.height;
      const minX=player.pos.x-r, maxX=player.pos.x+r;
      const minY=player.pos.y,   maxY=player.pos.y+h;
      const minZ=player.pos.z-r, maxZ=player.pos.z+r;
      return (minX < x+1 && maxX > x) && (minY < y+1 && maxY > y) && (minZ < z+1 && maxZ > z);
    }

    function syncCamera() { camera.position.set(player.pos.x, player.pos.y + PLAYER.eye, player.pos.z); }
    syncCamera();
    applyLook();

    // ======================================================
    // Hotbar + inventory UI (now uses atlas icons)
    // ======================================================
    const HOTBAR_SIZE = 9;
    const hotbar = new Array(HOTBAR_SIZE).fill(B.GRASS);
    hotbar[0]=B.GRASS; hotbar[1]=B.COBBLE; hotbar[2]=B.LOG; hotbar[3]=B.PLANKS; hotbar[4]=B.DIRT;
    hotbar[5]=B.SAND;  hotbar[6]=B.GLASS;  hotbar[7]=B.BRICKS; hotbar[8]=B.LEAVES;
    let hotbarIndex = 0;

    function renderHotbarHud() {
      hotbarHudEl.innerHTML = "";
      for (let i=0; i<HOTBAR_SIZE; i++) {
        const d = document.createElement("div");
        d.className = "hb-slot" + (i === hotbarIndex ? " selected" : "");
        const sw = document.createElement("div");
        sw.className = "hb-swatch";
        applyTileStyle(sw, blockIcon(hotbar[i]));
        d.appendChild(sw);
        hotbarHudEl.appendChild(d);
      }
    }

    function renderInvHotbar() {
      invHotbarEl.innerHTML = "";
      for (let i=0; i<HOTBAR_SIZE; i++) {
        const d = document.createElement("div");
        d.className = "slot" + (i === hotbarIndex ? " sel" : "");
        const sw = document.createElement("div");
        sw.className = "sw";
        applyTileStyle(sw, blockIcon(hotbar[i]));
        d.appendChild(sw);
        d.addEventListener("click", () => selectHotbar(i));
        invHotbarEl.appendChild(d);
      }
    }

    function selectHotbar(i) {
      hotbarIndex = Math.max(0, Math.min(HOTBAR_SIZE - 1, i));
      renderHotbarHud();
      renderInvHotbar();
    renderChat();
      updateHelp();
    }
    function selectedBlock() { return hotbar[hotbarIndex]; }
    function putInSelectedSlot(blockId) {
      hotbar[hotbarIndex] = blockId;
      renderHotbarHud();
      renderInvHotbar();
      updateHelp();
    }

    function renderPalette(filterText = "") {
      const q = filterText.trim().toLowerCase();
      paletteGridEl.innerHTML = "";
      const list = q ? BLOCK_LIST.filter(b => b.name.toLowerCase().includes(q)) : BLOCK_LIST;

      for (const it of list) {
        const d = document.createElement("div");
        d.className = "palSlot";
        d.dataset.name = it.name;
        const sw = document.createElement("div");
        sw.className = "sw";
        applyTileStyle(sw, it.icon);
        d.appendChild(sw);
        d.addEventListener("click", () => putInSelectedSlot(it.id));
        paletteGridEl.appendChild(d);
      }
    }

    searchEl.addEventListener("input", () => renderPalette(searchEl.value));

    renderPalette("");
    renderHotbarHud();
    renderInvHotbar();

    // ======================================================
    // Block interactions (use DDA hit)
    // ======================================================
    function currentHit() {
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      dir.normalize();
      return voxelRaycast(camera.position, dir, 7.0);
    }

    function breakAt(hit) {
      if (!hit) return;
      if (hit.y === 0) return; // bedrock
      setEdit(hit.x, hit.y, hit.z, B.AIR);
      markChunksDirtyForBlock(hit.x, hit.z);
    }

    function placeAt(hit) {
      if (!hit) return;
      const px = hit.x + hit.nx;
      const py = hit.y + hit.ny;
      const pz = hit.z + hit.nz;
      if (py < 0 || py >= WORLD_H) return;
      if (getBlock(px, py, pz) !== B.AIR) return;
      if (playerOverlapsBlock(px, py, pz)) return;
      setEdit(px, py, pz, selectedBlock());
      markChunksDirtyForBlock(px, pz);
    }

    function pickBlockIntoSlot(hit) {
      if (!hit) return;
      const t = getBlock(hit.x, hit.y, hit.z);
      if (t !== B.AIR) putInSelectedSlot(t);
    }

    window.addEventListener("mousedown", (e) => {
      if (!gameActive()) return;
    
      if (e.button === 0) { // break (continuous while held)
        lmbHeld = true;
        const hit = currentHit();
        breakAt(hit);
        lastMineTime = performance.now();
      }
    
      if (e.button === 1) { // pick
        const hit = currentHit();
        pickBlockIntoSlot(hit);
      }
    
      if (e.button === 2) { // place (continuous while held) OR drag look fallback
        if (isLocked()) {
          rmbHeld = true;
          const hit = currentHit();
          placeAt(hit);
          lastPlaceTime = performance.now();
        } else {
          startDragLook(e.clientX, e.clientY);
        }
      }
    });
    
    window.addEventListener("mouseup", (e) => {
      if (e.button === 0) {
        lmbHeld = false;
        return;
      }
    
      if (e.button !== 2) return;
    
      // RMB release
      rmbHeld = false;
    
      if (!gameActive()) return;
    
      // If pointer-lock is active, RMB was placing; no drag-look click logic needed.
      if (isLocked()) return;
    
      // Drag-look click-to-place fallback
      if (!rmbDown) return;
    
      const dt = performance.now() - rmbStartT;
      const moved = rmbMoved;
      stopDragLook();
    
      if (dt < 300 && moved < 10) {
        const hit = currentHit();
        placeAt(hit);
      }
    });
    
    window.addEventListener("blur", () => { lmbHeld = false; rmbHeld = false; try { stopDragLook(); } catch(_){} });

    // ======================================================
    // HUD help
    // ======================================================
    function updateHelp() {
      const state = inventoryOpen ? "Inventory" : (menuOverlay.style.display !== "none" ? "Menu" : (isLocked() ? "Mouse Look" : "Drag Look"));
      const sel = selectedBlock();
      const pcx = floorDiv(Math.floor(player.pos.x), CHUNK);
      const pcz = floorDiv(Math.floor(player.pos.z), CHUNK);

      const lockHint = (!inventoryOpen && menuOverlay.style.display === "none" && !isLocked())
        ? "Click canvas to recapture (or RMB-drag to look)\n"
        : "";

      const isFly = (flyMode && gameMode === "creative");

      helpEl.textContent =
        `Mini INDEV Voxel — Infinite + Textures\n` +
        `State: ${state}\n` +
        `Gamemode: ${gameMode === "creative" ? "Creative" : "Survival"}\n` +
        `Move: ${(flyMode && gameMode === "creative") ? "Fly" : "Walk"}\n` +
        `Seed: ${WORLD_SEED}
` + `Selected: [${hotbarIndex+1}] ${blockName(sel)}\n` +
        `Chunk: (${pcx}, ${pcz})  Loaded: ${chunks.size}\n` +
        (isFly
          ? `WASD move · Space up · Shift down · Double Space fly · LMB break · RMB place · MMB pick · 1–9 hotbar · E inventory · Esc menu\n`
          : (gameMode === "creative"
              ? `WASD move · Shift sprint · Space jump · Double Space fly · LMB break · RMB place · MMB pick · 1–9 hotbar · E inventory · Esc menu\n`
              : `WASD move · Shift sprint · Space jump · LMB break · RMB place · MMB pick · 1–9 hotbar · E inventory · Esc menu\n`
            )) +
        `Perf: voxel DDA picking + chunk-local caches\n` +
        lockHint;
    }

    // ======================================================
    // Resize
    // ======================================================
    window.addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ======================================================
    // Spawn + initial chunks
    // ======================================================
    (function spawnOnSurface() {
      function goodSpawn(x, z) {
        const top = surfaceY(x, z);
        if (top < SEA_LEVEL + 1) return false; // dry land only
        const t = getBlock(x, top, z);
        if (t === B.WATER || t === B.LAVA) return false;

        // avoid nasty cliffs right at spawn
        const d1 = Math.abs(surfaceY(x + 1, z) - top);
        const d2 = Math.abs(surfaceY(x - 1, z) - top);
        const d3 = Math.abs(surfaceY(x, z + 1) - top);
        const d4 = Math.abs(surfaceY(x, z - 1) - top);
        if (Math.max(d1, d2, d3, d4) > 3) return false;

        // headroom (should already be air, but keep it explicit)
        if (getBlock(x, top + 1, z) !== B.AIR) return false;
        if (getBlock(x, top + 2, z) !== B.AIR) return false;
        return true;
      }

      let sx = 0, sz = 0;
      if (!goodSpawn(sx, sz)) {
        let found = false;
        const maxR = 192;
        for (let r = 4; r <= maxR && !found; r += 4) {
          for (let dz = -r; dz <= r && !found; dz += 4) {
            for (let dx = -r; dx <= r && !found; dx += 4) {
              const x = sx + dx, z = sz + dz;
              if (goodSpawn(x, z)) { sx = x; sz = z; found = true; }
            }
          }
        }
      }

      const top = surfaceY(sx, sz);
      player.pos.set(sx + 0.5, top + 2.0, sz + 0.5);
      syncCamera();
    })();

    (function primeChunks() {
      const pcx = floorDiv(Math.floor(player.pos.x), CHUNK);
      const pcz = floorDiv(Math.floor(player.pos.z), CHUNK);

      // Warm-start a small neighborhood immediately (fast startup even with taller WORLD_H).
      const WARM_RADIUS = 1;
      for (let dz=-WARM_RADIUS; dz<=WARM_RADIUS; dz++) for (let dx=-WARM_RADIUS; dx<=WARM_RADIUS; dx++) {
        loadChunk(pcx + dx, pcz + dz);
      }
      updateHelp();
    })();

    // ======================================================
    // Main loop
    // ======================================================
    const clock = new THREE.Clock();
    let hudTimer = 0;

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());

      if (gameActive()) {
        const forward = (keys.has("KeyW") ? 1 : 0) - (keys.has("KeyS") ? 1 : 0);
        const strafe  = (keys.has("KeyD") ? 1 : 0) - (keys.has("KeyA") ? 1 : 0);

        const dir = new THREE.Vector3();
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        camDir.y = 0; camDir.normalize();
        const right = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0,1,0)).normalize();

        dir.addScaledVector(camDir, forward);
        dir.addScaledVector(right, strafe);
        const moveLenSq = dir.lengthSq();
        if (moveLenSq > 0) dir.normalize();
        const moving = (moveLenSq > 0);

        if (flyMode && gameMode === "creative") {
          // Creative flight: no gravity, fast movement, Space up / Shift down.
          const flyMove = (PLAYER.speed * 1.75 * FLY_SPEED_MULT) * dt; // ~3x run speed
          tryMoveAxis("x", dir.x * flyMove);
          tryMoveAxis("z", dir.z * flyMove);

          const up = keys.has("Space") ? 1 : 0;
          const down = (keys.has("ShiftLeft") || keys.has("ShiftRight")) ? 1 : 0;
          const vy = (up - down) * flyMove;

          player.velY = 0;
          player.onGround = false;
          if (vy) tryMoveAxis("y", vy);
        } else {
          const sprinting = (keys.has("ShiftLeft") || keys.has("ShiftRight")) && moving;
          const sprint = sprinting ? 1.75 : 1.0;
          const move = (PLAYER.speed * sprint) * dt;
          tryMoveAxis("x", dir.x * move);
          tryMoveAxis("z", dir.z * move);

          const prevGround = player.onGround;
          if (gameMode === "survival" && prevGround) {
            fallPeakY = player.pos.y;
          }

          player.velY -= PLAYER.gravity * dt;
          player.velY = Math.max(-PLAYER.terminal, player.velY);

          let didJump = false;
          if (player.onGround && keys.has("Space")) {
            player.velY = PLAYER.jump;
            player.onGround = false;
            didJump = true;
          }

          player.onGround = false;
          const dy = player.velY * dt;
          const collidedY = tryMoveAxis("y", dy);
          if (collidedY && dy < 0) { player.onGround = true; player.velY = 0; }
          else if (collidedY && dy > 0) { player.velY = 0; }

          // Survival: fall damage on landing
          if (gameMode === "survival") {
            if (!prevGround && !player.onGround) {
              // track peak while airborne (jump apex or step-off start)
              fallPeakY = Math.max(fallPeakY, player.pos.y);
            }
            if (!prevGround && player.onGround && dy < 0) {
              const fallDist = (fallPeakY - player.pos.y);
              const dmg = Math.floor(fallDist - 3.0);
              if (dmg > 0) damagePlayer(dmg, "fall");
            }

            // Hunger drain + regen + starvation
            const hungerBefore = hunger;
            const healthBefore = health;

            // Exhaustion: moving costs, sprint costs more, jumps cost a chunk
            const baseEx = moving ? 0.08 : 0.01; // per second
            exhaustion += dt * baseEx * (sprinting ? 2.2 : 1.0);
            if (didJump) exhaustion += 0.35;

            while (exhaustion >= 4.0) {
              exhaustion -= 4.0;
              hunger = Math.max(0, hunger - 1);
            }

            if (hunger >= 18 && health < SURV_MAX) {
              regenTimer += dt;
              if (regenTimer >= 4.0) {
                regenTimer = 0;
                health = Math.min(SURV_MAX, health + 1);
                hunger = Math.max(0, hunger - 1);
              }
            } else {
              regenTimer = 0;
            }

            if (hunger <= 0) {
              starveTimer += dt;
              if (starveTimer >= 4.0) {
                starveTimer = 0;
                if (health > 1) health -= 1;
              }
            } else {
              starveTimer = 0;
            }

            if (health !== healthBefore || hunger !== hungerBefore) renderStatusHud();
          }
        }

        syncCamera();

updateChunkStreaming(player.pos.x, player.pos.z);

// Continuous mine/place while holding mouse buttons
{
  const now = performance.now();
  if (lmbHeld && (now - lastMineTime) >= MINE_INTERVAL_MS) {
    const hit = currentHit();
    breakAt(hit);
    lastMineTime = now;
  }
  if (rmbHeld && isLocked() && (now - lastPlaceTime) >= PLACE_INTERVAL_MS) {
    const hit = currentHit();
    placeAt(hit);
    lastPlaceTime = now;
  }
}

// highlight using DDA hit (no raycaster)
        const hit = currentHit();
        if (hit && getBlock(hit.x, hit.y, hit.z) !== B.AIR) {
          highlight.visible = true;
          highlight.position.copy(blockCenter(hit.x, hit.y, hit.z));
        } else {
          highlight.visible = false;
        }
      } else {
        highlight.visible = false;
      }

      renderer.render(scene, camera);

      hudTimer += dt;
      if (hudTimer > 0.15) { hudTimer = 0; updateHelp(); renderStatusHud(); renderChat(); }
    }
    animate();

    // Start at menu
    setMenu(true);

  })();
  </script>
</body>
</html>
