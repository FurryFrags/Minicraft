<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini INDEV Voxel (Infinite + Textures + Faster)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { display: block; }

    /* HUD */
    #hud { position: fixed; inset: 0; pointer-events: none; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,.85); }
    #crosshair {
      position: absolute; left: 50%; top: 50%;
      width: 14px; height: 14px; transform: translate(-50%,-50%); opacity: .9;
    }
    #crosshair:before, #crosshair:after {
      content: ""; position: absolute; left: 50%; top: 50%;
      background: rgba(255,255,255,.95);
      transform: translate(-50%,-50%); border-radius: 1px;
    }
    #crosshair:before { width: 14px; height: 2px; }
    #crosshair:after  { width: 2px;  height: 14px; }

    #help {
      position: absolute; left: 12px; top: 10px;
      background: rgba(0,0,0,.32);
      border: 1px solid rgba(255,255,255,.12);
      padding: 10px 12px; border-radius: 12px;
      max-width: 920px; line-height: 1.35;
      white-space: pre-wrap;
    }

    /* Hotbar (in-game) */
    #hotbarHud {
      position: absolute; left: 50%; bottom: 18px; transform: translateX(-50%);
      display: grid; grid-auto-flow: column; gap: 8px;
      background: rgba(0,0,0,.32);
      border: 1px solid rgba(255,255,255,.12);
      padding: 8px; border-radius: 12px;
      pointer-events: none;
    }
    .hb-slot {
      width: 46px; height: 46px; border-radius: 10px;
      border: 2px solid rgba(255,255,255,.22);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.25);
      display: grid; place-items: center;
    }
    .hb-slot.selected { border-color: rgba(255,255,255,.92); }
    .hb-swatch {
      width: 28px; height: 28px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,.30);
      box-shadow: 0 2px 6px rgba(0,0,0,.35);
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }

    /* Menu overlay */
    #menuOverlay {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,.35), rgba(0,0,0,.75));
      color: #fff;
      user-select: none;
      z-index: 10;
    }
    #menuPanel {
      width: min(560px, calc(100vw - 24px));
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 12px 40px rgba(0,0,0,.55);
      text-align: center;
    }
    #menuTitle { margin: 0 0 8px; font-size: 18px; font-weight: 900; }
    #menuSub   { margin: 0 0 12px; opacity: .92; line-height: 1.35; }
    .btn {
      width: 100%;
      appearance: none; border: 0;
      background: rgba(255,255,255,.92); color: #000;
      font-weight: 900; font-size: 15px;
      padding: 12px 14px; border-radius: 12px;
      cursor: pointer;
    }
    .tiny { margin-top: 10px; font-size: 12px; opacity: .75; line-height: 1.35; }

    /* Inventory overlay */
    #invOverlay {
      position: fixed; inset: 0;
      display: none;
      place-items: center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,.25), rgba(0,0,0,.85));
      color: #fff;
      user-select: none;
      z-index: 20;
    }
    #invWindow {
      width: min(980px, calc(100vw - 24px));
      height: min(680px, calc(100vh - 24px));
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 18px;
      box-shadow: 0 12px 40px rgba(0,0,0,.60);
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      overflow: hidden;
    }
    #invHeader {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      gap: 12px;
    }
    #invHeader .left { display: flex; align-items: baseline; gap: 10px; flex-wrap: wrap; }
    #invHeader b { font-weight: 900; }
    #invHeader .hint { opacity: .8; font-size: 12px; }
    #invClose {
      appearance: none; border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06); color: #fff;
      padding: 8px 10px; border-radius: 12px;
      cursor: pointer;
      font-weight: 800;
      white-space: nowrap;
    }
    #invTools {
      padding: 10px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    #search {
      appearance: none;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.25);
      color: #fff;
      padding: 10px 12px;
      border-radius: 12px;
      outline: none;
      width: min(420px, 100%);
      font-weight: 700;
    }
    #invTools .tip { font-size: 12px; opacity: .85; }

    #invBody { padding: 14px; overflow: auto; }

    .grid { display: grid; grid-template-columns: repeat(9, 44px); justify-content: center; gap: 8px; }
    .slot {
      width: 44px; height: 44px; border-radius: 10px;
      border: 2px solid rgba(255,255,255,.15);
      background: rgba(0,0,0,.22);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.35), 0 6px 16px rgba(0,0,0,.30);
      display: grid; place-items: center;
      cursor: pointer;
    }
    .slot:hover { background: rgba(255,255,255,.05); }
    .slot.sel { border-color: rgba(255,255,255,.85); }
    .slot .sw {
      width: 28px; height: 28px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,.30);
      box-shadow: 0 2px 8px rgba(0,0,0,.35);
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }
    .labelRow {
      display: flex;
      justify-content: center;
      margin: 8px 0 10px;
      font-size: 12px;
      opacity: .85;
      gap: 10px;
      flex-wrap: wrap;
    }
    .sectionTitle {
      text-align: center;
      font-size: 12px;
      letter-spacing: .08em;
      opacity: .85;
      margin: 6px 0 8px;
      text-transform: uppercase;
    }

    #paletteGrid {
      display: grid;
      grid-template-columns: repeat(9, 44px);
      justify-content: center;
      gap: 8px;
    }
    .palSlot {
      width: 44px; height: 44px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      display: grid; place-items: center;
      cursor: pointer;
      position: relative;
    }
    .palSlot:hover { border-color: rgba(255,255,255,.35); background: rgba(255,255,255,.06); }
    .palSlot .sw {
      width: 28px; height: 28px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,.28);
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }
    .palSlot[data-name]:hover::after {
      content: attr(data-name);
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 52px;
      background: rgba(0,0,0,.75);
      border: 1px solid rgba(255,255,255,.18);
      color: #fff;
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
    }

    #invFooter {
      padding: 12px 14px;
      border-top: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      font-size: 12px;
      opacity: .9;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <div id="menuOverlay">
    <div id="menuPanel">
      <div id="menuTitle">Mini INDEV Voxel</div>
      <div id="menuSub">
        Infinite chunk world + pixel textures + less CPU lag.<br/>
        Click <b>Play</b>. If mouse-capture is blocked on <code>file://</code>, it falls back to <b>RMB-drag</b>.
      </div>
      <button id="play" class="btn" type="button">Play</button>
      <div class="tiny">
        Controls: <b>WASD</b> move · <b>Shift</b> sprint · <b>Space</b> jump · <b>LMB</b> break · <b>RMB</b> place · <b>MMB</b> pick · <b>1–9</b> hotbar · <b>E</b> inventory · <b>Esc</b> menu
      </div>
    </div>
  </div>

  <div id="invOverlay">
    <div id="invWindow">
      <div id="invHeader">
        <div class="left">
          <b>Inventory</b>
          <span class="hint">Creative palette + hotbar. Press <b>E</b> to close.</span>
        </div>
        <button id="invClose" type="button">Close</button>
      </div>

      <div id="invTools">
        <input id="search" type="text" placeholder="Search blocks…" autocomplete="off" />
        <div class="tip">Click a palette block to put it into your selected hotbar slot.</div>
      </div>

      <div id="invBody">
        <div class="sectionTitle">Creative blocks</div>
        <div id="paletteGrid"></div>

        <div class="labelRow">
          <span><b>Hotbar</b> (click a slot to select)</span>
          <span>·</span>
          <span>Tip: MMB in-world copies a block into the selected slot</span>
        </div>
        <div id="invHotbar" class="grid"></div>
      </div>

      <div id="invFooter">
        <div>Perf: voxel DDA picking + chunk meshing scans full height (so builds never disappear).</div>
        <div>Tip: click the canvas after closing UI to re-capture mouse instantly.</div>
      </div>
    </div>
  </div>

  <div id="hud">
    <div id="crosshair"></div>
    <div id="help"></div>
    <div id="hotbarHud"></div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
  (() => {
    "use strict";

    // ======================================================
    // Blocks (toy creative set) + texture tile assignments
    // ======================================================
    const B = {
      AIR: 0,
      GRASS: 1,
      COBBLE: 2,
      LOG: 3,
      DIRT: 4,
      PLANKS: 5,
      SAND: 6,
      GLASS: 7,
      LEAVES: 8,
      BRICKS: 9,
      OBSIDIAN: 10,
      GOLD: 11,
      DIAMOND: 12,
      TNT: 13,
      WOOL_WHITE: 14,
      WOOL_RED: 15,
      WOOL_BLUE: 16,
      WOOL_GREEN: 17,
      WATER: 18, // decorative
      LAVA: 19,  // decorative
      BEDROCK: 20,
    };

    const WORLD_H = 32;       // fixed world height
    const SURFACE_Y_BASE = 8; // baseline terrain height

    // ======================================================
    // Chunk streaming config
    // ======================================================
    const CHUNK = 16;
    const RADIUS = 4;              // view distance in chunks
    const MAX_LOADS_PER_FRAME = 1; // stability > speed

    // ======================================================
    // Player
    // ======================================================
    const PLAYER = {
      radius: 0.32,
      height: 1.72,
      eye: 1.62,
      speed: 5.0,
      jump: 6.5,
      gravity: 15.0,
      terminal: 40.0,
    };

    // ======================================================
    // DOM
    // ======================================================
    const menuOverlay = document.getElementById("menuOverlay");
    const playBtn = document.getElementById("play");
    const invOverlay = document.getElementById("invOverlay");
    const invClose = document.getElementById("invClose");
    const helpEl = document.getElementById("help");
    const hotbarHudEl = document.getElementById("hotbarHud");
    const paletteGridEl = document.getElementById("paletteGrid");
    const invHotbarEl = document.getElementById("invHotbar");
    const searchEl = document.getElementById("search");

    // ======================================================
    // Three.js
    // ======================================================
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.domElement.tabIndex = 0;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87b7ff);
    scene.fog = new THREE.FogExp2(0x87b7ff, 0.008);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.05, 900);
    camera.rotation.order = "YXZ";

    scene.add(new THREE.HemisphereLight(0xbad6ff, 0x3a3a3a, 0.85));
    const sun = new THREE.DirectionalLight(0xffffff, 0.85);
    sun.position.set(80, 140, 40);
    scene.add(sun);

    // ======================================================
    // Texture atlas (procedural, embedded)
    // ======================================================
    const TILE = 16;
    const ATLAS_COLS = 8;
    const ATLAS_ROWS = 8;


    const ICON_PX = 28; // UI icon size; keeps tiles aligned/pixel-perfect
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    function rgb(r,g,b){ return `rgb(${r|0},${g|0},${b|0})`; }

    // deterministic hash for pixels / tiles
    function hash32(n){
      n = (n ^ (n >>> 16)) >>> 0;
      n = Math.imul(n, 0x7feb352d) >>> 0;
      n = (n ^ (n >>> 15)) >>> 0;
      n = Math.imul(n, 0x846ca68b) >>> 0;
      n = (n ^ (n >>> 16)) >>> 0;
      return n >>> 0;
    }
    function rnd01(seed){
      return (hash32(seed) & 0xFFFFFF) / 0xFFFFFF;
    }

    function drawNoiseTile(ctx, tx, ty, baseRGB, speckRGB, speckRate, shadeRate, seedBase) {
      const ox = tx * TILE, oy = ty * TILE;
      for (let y=0; y<TILE; y++) for (let x=0; x<TILE; x++) {
        const s = seedBase + x*131 + y*977;
        const r = rnd01(s);
        const sh = (rnd01(s ^ 0x9e3779b9) - 0.5) * shadeRate;
        let rr = baseRGB[0] + sh, gg = baseRGB[1] + sh, bb = baseRGB[2] + sh;
        if (r < speckRate) {
          const k = rnd01(s ^ 0xBADC0DE) * 0.6 + 0.4;
          rr = lerp(rr, speckRGB[0], k);
          gg = lerp(gg, speckRGB[1], k);
          bb = lerp(bb, speckRGB[2], k);
        }
        rr = Math.max(0, Math.min(255, rr));
        gg = Math.max(0, Math.min(255, gg));
        bb = Math.max(0, Math.min(255, bb));
        ctx.fillStyle = rgb(rr,gg,bb);
        ctx.fillRect(ox + x, oy + y, 1, 1);
      }
    }

    function drawPlanks(ctx, tx, ty, seedBase){
      const ox = tx*TILE, oy = ty*TILE;
      // base
      drawNoiseTile(ctx, tx, ty, [196,154,90], [220,188,120], 0.08, 18, seedBase);
      // plank seams
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      for (let i=0; i<3; i++) {
        const yy = oy + 3 + i*5;
        ctx.fillRect(ox, yy, TILE, 1);
      }
      // subtle vertical grain
      for (let x=0; x<TILE; x+=3) {
        const a = 0.05 + rnd01(seedBase + x*19)*0.06;
        ctx.fillStyle = `rgba(70,40,15,${a})`;
        ctx.fillRect(ox+x, oy, 1, TILE);
      }
    }

    function drawCobble(ctx, tx, ty, seedBase){
      const ox = tx*TILE, oy = ty*TILE;
      // base noise
      drawNoiseTile(ctx, tx, ty, [135, 139, 148], [90,90,95], 0.12, 35, seedBase);
      // chunky stones
      for (let i=0; i<18; i++){
        const r = rnd01(seedBase + i*999);
        const x = (rnd01(seedBase + i*123) * (TILE-4))|0;
        const y = (rnd01(seedBase + i*321) * (TILE-4))|0;
        const w = 2 + ((r*3)|0);
        const h = 2 + (((1-r)*3)|0);
        const c = 90 + (r*70)|0;
        ctx.fillStyle = rgb(c,c,c);
        ctx.fillRect(ox+x, oy+y, w, h);
        ctx.fillStyle = "rgba(0,0,0,0.18)";
        ctx.fillRect(ox+x, oy+y+h-1, w, 1);
        ctx.fillRect(ox+x+w-1, oy+y, 1, h);
      }
    }

    function drawGrassTop(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [78, 168, 74], [40, 130, 40], 0.10, 22, seedBase);
      // little lighter flecks
      const ox = tx*TILE, oy = ty*TILE;
      for (let i=0;i<14;i++){
        const x = (rnd01(seedBase + i*41) * TILE)|0;
        const y = (rnd01(seedBase + i*57) * TILE)|0;
        ctx.fillStyle = "rgba(255,255,255,0.07)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawGrassSide(ctx, tx, ty, seedBase){
      // dirt base
      drawNoiseTile(ctx, tx, ty, [138, 90, 43], [120, 70, 28], 0.10, 26, seedBase);
      // green top band
      const ox = tx*TILE, oy = ty*TILE;
      for (let y=0; y<5; y++){
        const a = 0.85 - y*0.11;
        ctx.fillStyle = `rgba(80, 175, 76, ${a})`;
        ctx.fillRect(ox, oy+y, TILE, 1);
      }
      // green specks in band
      for (let i=0;i<18;i++){
        const x = (rnd01(seedBase + i*91) * TILE)|0;
        const y = (rnd01(seedBase + i*37) * 5)|0;
        ctx.fillStyle = "rgba(30,90,30,0.35)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawLogSide(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [164, 116, 60], [120, 80, 35], 0.10, 20, seedBase);
      const ox = tx*TILE, oy = ty*TILE;
      // vertical stripes
      for (let x=0; x<TILE; x++){
        const a = 0.05 + rnd01(seedBase + x*17)*0.10;
        ctx.fillStyle = `rgba(70,40,15,${a})`;
        ctx.fillRect(ox+x, oy, 1, TILE);
      }
    }

    function drawLogTop(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [175, 130, 75], [130, 90, 40], 0.08, 18, seedBase);
      // rings (cheap)
      for (let r=2; r<=7; r+=2){
        const a = 0.20 - r*0.015;
        ctx.strokeStyle = `rgba(80,45,20,${a})`;
        ctx.beginPath();
        ctx.arc(ox+8, oy+8, r + rnd01(seedBase+r*133)*0.35, 0, Math.PI*2);
        ctx.stroke();
      }
      // darker bark edge
      ctx.strokeStyle = "rgba(55,30,15,0.35)";
      ctx.strokeRect(ox+0.5, oy+0.5, TILE-1, TILE-1);
    }

    function drawBricks(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [178, 92, 77], [140, 60, 55], 0.08, 20, seedBase);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      for (let y=0; y<TILE; y+=4){
        ctx.fillRect(ox, oy+y, TILE, 1);
      }
      for (let row=0; row<4; row++){
        const y = oy + row*4;
        const offset = (row%2)*4;
        for (let x=offset; x<TILE; x+=8){
          ctx.fillRect(ox+x, y, 1, 4);
        }
      }
    }

    function drawObsidian(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [35, 25, 50], [80, 40, 120], 0.10, 10, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      for (let i=0;i<18;i++){
        const x=(rnd01(seedBase+i*31)*TILE)|0;
        const y=(rnd01(seedBase+i*67)*TILE)|0;
        ctx.fillStyle="rgba(150,90,220,0.10)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawSand(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [218, 203, 131], [240, 230, 170], 0.10, 16, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      for (let i=0;i<10;i++){
        const x=(rnd01(seedBase+i*19)*TILE)|0;
        const y=(rnd01(seedBase+i*23)*TILE)|0;
        ctx.fillStyle="rgba(120,100,40,0.10)";
        ctx.fillRect(ox+x, oy+y, 2, 1);
      }
    }

    function drawLeaves(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [55, 145, 65], [25, 90, 35], 0.14, 22, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      for (let i=0;i<24;i++){
        const x=(rnd01(seedBase+i*53)*TILE)|0;
        const y=(rnd01(seedBase+i*79)*TILE)|0;
        ctx.fillStyle="rgba(0,0,0,0.10)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawGlass(ctx, tx, ty){
      // Cutout/dithered "see-through" glass:
      // - Most pixels are fully transparent (so you can see through)
      // - A sparse dither + border lines are opaque enough to read as glass
      // This avoids per-instance transparent sorting artifacts (no more x-ray glitches).
      const ox=tx*TILE, oy=ty*TILE;

      // clear tile (fully transparent)
      ctx.clearRect(ox, oy, TILE, TILE);

      // subtle dither dots
      for (let y=0; y<TILE; y++){
        for (let x=0; x<TILE; x++){
          // ordered-ish pattern + a bit of noise
          const k = ((x*3 + y*5) & 7);
          if (k === 0 || k === 5) {
            ctx.fillStyle="rgba(185,230,255,0.70)";
            ctx.fillRect(ox+x, oy+y, 1, 1);
          }
        }
      }

      // crisp border and highlights
      ctx.strokeStyle="rgba(255,255,255,0.95)";
      ctx.strokeRect(ox+0.5, oy+0.5, TILE-1, TILE-1);

      ctx.strokeStyle="rgba(255,255,255,0.75)";
      ctx.beginPath();
      ctx.moveTo(ox+3, oy+2); ctx.lineTo(ox+13, oy+12);
      ctx.moveTo(ox+2, oy+6); ctx.lineTo(ox+10, oy+14);
      ctx.stroke();
    }

    function drawMetal(ctx, tx, ty, base, seedBase){
      drawNoiseTile(ctx, tx, ty, base, [255,255,255], 0.06, 18, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      ctx.fillStyle="rgba(255,255,255,0.12)";
      ctx.fillRect(ox+2, oy+2, 5, 2);
      ctx.fillRect(ox+3, oy+4, 3, 1);
      ctx.fillStyle="rgba(0,0,0,0.18)";
      ctx.fillRect(ox+1, oy+13, 14, 1);
    }

    function drawTNT(ctx, tx, ty, variant){
      const ox=tx*TILE, oy=ty*TILE;
      if (variant === "top") {
        drawNoiseTile(ctx, tx, ty, [205, 82, 82], [255,255,255], 0.02, 10, 12345);
        ctx.fillStyle="rgba(0,0,0,0.35)";
        ctx.fillRect(ox, oy+5, TILE, 1);
        ctx.fillRect(ox, oy+10, TILE, 1);
      } else if (variant === "bottom") {
        drawNoiseTile(ctx, tx, ty, [150, 60, 60], [255,255,255], 0.01, 10, 54321);
        ctx.fillStyle="rgba(0,0,0,0.25)";
        ctx.fillRect(ox, oy+7, TILE, 1);
      } else {
        // side
        drawNoiseTile(ctx, tx, ty, [215, 88, 88], [255,255,255], 0.02, 10, 9999);
        ctx.fillStyle="rgba(255,255,255,0.55)";
        ctx.fillRect(ox, oy+5, TILE, 6);
        ctx.fillStyle="rgba(0,0,0,0.55)";
        ctx.fillRect(ox, oy+5, TILE, 1);
        ctx.fillRect(ox, oy+10, TILE, 1);
        // fake "TNT" letters (pixel-ish)
        ctx.fillStyle="rgba(0,0,0,0.65)";
        ctx.fillRect(ox+3, oy+7, 10, 2);
      }
    }

    function drawWool(ctx, tx, ty, base, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, base, [255,255,255], 0.06, 12, seedBase);
      // weave
      for (let y=0; y<TILE; y+=2){
        for (let x=(y%4===0?0:1); x<TILE; x+=2){
          ctx.fillStyle="rgba(0,0,0,0.06)";
          ctx.fillRect(ox+x, oy+y, 1, 1);
        }
      }
    }

    function drawWater(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [50, 120, 240], [90, 160, 255], 0.12, 14, seedBase);
      for (let y=0; y<TILE; y++){
        const a = 0.10 + (y/TILE)*0.12;
        ctx.fillStyle = `rgba(255,255,255,${a})`;
        ctx.fillRect(ox, oy+y, TILE, 1);
      }
    }

    function drawLava(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [255, 120, 40], [255, 220, 120], 0.18, 18, seedBase);
      for (let i=0;i<18;i++){
        const x=(rnd01(seedBase+i*101)*TILE)|0;
        const y=(rnd01(seedBase+i*203)*TILE)|0;
        ctx.fillStyle="rgba(0,0,0,0.12)";
        ctx.fillRect(ox+x, oy+y, 2, 1);
      }
    }

    function drawBedrock(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [55,55,55], [25,25,25], 0.22, 30, seedBase);
    }

    // tile registry
    const T = {};
    function setTile(name, idx){ T[name]=idx; }

    function tileXY(idx){ return { tx: idx % ATLAS_COLS, ty: Math.floor(idx / ATLAS_COLS) }; }

    function generateAtlas() {
      const c = document.createElement("canvas");
      c.width = ATLAS_COLS * TILE;
      c.height = ATLAS_ROWS * TILE;
      const ctx = c.getContext("2d", { alpha: true });

      // assign indices
      let i=0;
      const names = [
        "grass_top","grass_side","dirt","cobble","log_side","log_top","planks","leaves",
        "sand","glass","bricks","obsidian","gold","diamond","tnt_side","tnt_top",
        "tnt_bottom","wool_white","wool_red","wool_blue","wool_green","water","lava","bedrock"
      ];
      for (const n of names) setTile(n, i++);

      // draw tiles
      {
        const a = tileXY(T.grass_top);  drawGrassTop(ctx, a.tx, a.ty, 101);
        const b = tileXY(T.grass_side); drawGrassSide(ctx, b.tx, b.ty, 202);
        const c2 = tileXY(T.dirt);      drawNoiseTile(ctx, c2.tx, c2.ty, [138, 90, 43], [120, 70, 28], 0.10, 26, 303);
        const d = tileXY(T.cobble);     drawCobble(ctx, d.tx, d.ty, 404);
        const e = tileXY(T.log_side);   drawLogSide(ctx, e.tx, e.ty, 505);
        const f = tileXY(T.log_top);    drawLogTop(ctx, f.tx, f.ty, 606);
        const g = tileXY(T.planks);     drawPlanks(ctx, g.tx, g.ty, 707);
        const h = tileXY(T.leaves);     drawLeaves(ctx, h.tx, h.ty, 808);
        const s = tileXY(T.sand);       drawSand(ctx, s.tx, s.ty, 909);
        const gl = tileXY(T.glass);     drawGlass(ctx, gl.tx, gl.ty);
        const br = tileXY(T.bricks);    drawBricks(ctx, br.tx, br.ty, 1111);
        const ob = tileXY(T.obsidian);  drawObsidian(ctx, ob.tx, ob.ty, 1212);
        const go = tileXY(T.gold);      drawMetal(ctx, go.tx, go.ty, [240, 205, 75], 1313);
        const di = tileXY(T.diamond);   drawMetal(ctx, di.tx, di.ty, [90, 230, 210], 1414);

        const ts = tileXY(T.tnt_side);  drawTNT(ctx, ts.tx, ts.ty, "side");
        const tt = tileXY(T.tnt_top);   drawTNT(ctx, tt.tx, tt.ty, "top");
        const tb = tileXY(T.tnt_bottom);drawTNT(ctx, tb.tx, tb.ty, "bottom");

        const ww = tileXY(T.wool_white);drawWool(ctx, ww.tx, ww.ty, [240,240,240], 1515);
        const wr = tileXY(T.wool_red);  drawWool(ctx, wr.tx, wr.ty, [210,75,75], 1616);
        const wb = tileXY(T.wool_blue); drawWool(ctx, wb.tx, wb.ty, [70,110,220], 1717);
        const wg = tileXY(T.wool_green);drawWool(ctx, wg.tx, wg.ty, [60,175,90], 1818);

        const wa = tileXY(T.water);     drawWater(ctx, wa.tx, wa.ty, 1919);
        const la = tileXY(T.lava);      drawLava(ctx, la.tx, la.ty, 2020);
        const be = tileXY(T.bedrock);   drawBedrock(ctx, be.tx, be.ty, 2121);
      }

      // small atlas padding: crisp borders (optional)
      // no-op; we rely on nearest filtering + exact UVs.

      return c;
    }

    const atlasCanvas = generateAtlas();
    const atlasURL = atlasCanvas.toDataURL("image/png");

    // Create Three.js texture
    const atlasTex = new THREE.CanvasTexture(atlasCanvas);
    atlasTex.colorSpace = THREE.SRGBColorSpace;
    atlasTex.magFilter = THREE.NearestFilter;
    atlasTex.minFilter = THREE.NearestFilter;
    atlasTex.generateMipmaps = false;

    // ======================================================
    // UV-mapped box geometries per block
    // ======================================================
    const atlasW = ATLAS_COLS * TILE;
    const atlasH = ATLAS_ROWS * TILE;

    function tileUVRect(tileIdx) {
      const tx = tileIdx % ATLAS_COLS;
      const ty = Math.floor(tileIdx / ATLAS_COLS);
      const u0 = (tx * TILE) / atlasW;
      const v0 = 1 - ((ty + 1) * TILE) / atlasH;
      const u1 = ((tx + 1) * TILE) / atlasW;
      const v1 = 1 - (ty * TILE) / atlasH;
      return {u0,v0,u1,v1};
    }

    function makeUVBox(tilesByFace) {
      // Face order for BoxGeometry: +x, -x, +y, -y, +z, -z (24 uvs, 4 per face)
      const g = new THREE.BoxGeometry(1,1,1);
      const uv = g.attributes.uv;
      const faces = [0,1,2,3,4,5];
      for (const f of faces) {
        const t = tilesByFace[f];
        const r = tileUVRect(t);
        const base = f * 4;
        // BoxGeometry uses 4 verts per face; assign in a consistent winding.
        // (u0,v1) (u1,v1) (u0,v0) (u1,v0) matches typical quad mapping.
        uv.setXY(base + 0, r.u0, r.v1);
        uv.setXY(base + 1, r.u1, r.v1);
        uv.setXY(base + 2, r.u0, r.v0);
        uv.setXY(base + 3, r.u1, r.v0);
      }
      uv.needsUpdate = true;
      return g;
    }

    // Per-block face tiles
    // faces: 0 +x, 1 -x, 2 +y(top), 3 -y(bottom), 4 +z, 5 -z
    function allFaces(tile) { return [tile,tile,tile,tile,tile,tile]; }

    const geomFor = new Map();
    function defGeom(blockId, faceTiles) {
      geomFor.set(blockId, makeUVBox(faceTiles));
    }

    // define tile sets
    defGeom(B.GRASS,  [T.grass_side, T.grass_side, T.grass_top, T.dirt,      T.grass_side, T.grass_side]);
    defGeom(B.DIRT,   allFaces(T.dirt));
    defGeom(B.COBBLE, allFaces(T.cobble));
    defGeom(B.LOG,    [T.log_side,   T.log_side,   T.log_top,   T.log_top,   T.log_side,   T.log_side]);
    defGeom(B.PLANKS, allFaces(T.planks));
    defGeom(B.LEAVES, allFaces(T.leaves));
    defGeom(B.SAND,   allFaces(T.sand));
    defGeom(B.GLASS,  allFaces(T.glass));
    defGeom(B.BRICKS, allFaces(T.bricks));
    defGeom(B.OBSIDIAN, allFaces(T.obsidian));
    defGeom(B.GOLD,   allFaces(T.gold));
    defGeom(B.DIAMOND,allFaces(T.diamond));
    defGeom(B.TNT,    [T.tnt_side,   T.tnt_side,   T.tnt_top,   T.tnt_bottom,T.tnt_side,   T.tnt_side]);
    defGeom(B.WOOL_WHITE, allFaces(T.wool_white));
    defGeom(B.WOOL_RED,   allFaces(T.wool_red));
    defGeom(B.WOOL_BLUE,  allFaces(T.wool_blue));
    defGeom(B.WOOL_GREEN, allFaces(T.wool_green));
    defGeom(B.WATER,  allFaces(T.water));
    defGeom(B.LAVA,   allFaces(T.lava));
    defGeom(B.BEDROCK,allFaces(T.bedrock));

    // shared materials
    const matOpaque = new THREE.MeshLambertMaterial({ map: atlasTex });
    const matGlass  = new THREE.MeshLambertMaterial({ map: atlasTex, alphaTest: 0.30, transparent: false, depthWrite: true, depthTest: true });
    const matWater  = new THREE.MeshLambertMaterial({ map: atlasTex, transparent: true, opacity: 0.65, depthWrite: false });
    const matLava   = new THREE.MeshLambertMaterial({ map: atlasTex, transparent: true, opacity: 0.85, depthWrite: false });

    function materialFor(id) {
      if (id === B.GLASS) return matGlass;
      if (id === B.WATER) return matWater;
      if (id === B.LAVA)  return matLava;
      return matOpaque;
    }

    // palette list with icons + names
    const BLOCK_LIST = [
      { id: B.GRASS, name: "Grass", icon: T.grass_top },
      { id: B.DIRT, name: "Dirt", icon: T.dirt },
      { id: B.COBBLE, name: "Cobblestone", icon: T.cobble },
      { id: B.LOG, name: "Oak Log", icon: T.log_top },
      { id: B.PLANKS, name: "Oak Planks", icon: T.planks },
      { id: B.LEAVES, name: "Leaves", icon: T.leaves },
      { id: B.SAND, name: "Sand", icon: T.sand },
      { id: B.GLASS, name: "Glass", icon: T.glass },
      { id: B.BRICKS, name: "Bricks", icon: T.bricks },
      { id: B.OBSIDIAN, name: "Obsidian", icon: T.obsidian },
      { id: B.GOLD, name: "Gold Block", icon: T.gold },
      { id: B.DIAMOND, name: "Diamond Block", icon: T.diamond },
      { id: B.TNT, name: "TNT", icon: T.tnt_side },
      { id: B.WOOL_WHITE, name: "White Wool", icon: T.wool_white },
      { id: B.WOOL_RED, name: "Red Wool", icon: T.wool_red },
      { id: B.WOOL_BLUE, name: "Blue Wool", icon: T.wool_blue },
      { id: B.WOOL_GREEN, name: "Green Wool", icon: T.wool_green },
      { id: B.WATER, name: "Water (static)", icon: T.water },
      { id: B.LAVA, name: "Lava (static)", icon: T.lava },
      { id: B.BEDROCK, name: "Bedrock", icon: T.bedrock },
    ];

    function blockName(id) {
      const f = BLOCK_LIST.find(b => b.id === id);
      return f ? f.name : "?";
    }
    function blockIcon(id) {
      const f = BLOCK_LIST.find(b => b.id === id);
      return f ? f.icon : T.dirt;
    }

    function applyTileStyle(el, tileIdx) {
      // IMPORTANT: scale atlas so a 16px tile maps cleanly into the UI icon box.
      // Otherwise a 28x28 element would show parts of neighboring tiles (glitchy icons).
      const tx = tileIdx % ATLAS_COLS;
      const ty = Math.floor(tileIdx / ATLAS_COLS);
      el.style.backgroundImage = `url(${atlasURL})`;
      el.style.backgroundRepeat = "no-repeat";
      el.style.backgroundSize = `${ATLAS_COLS*ICON_PX}px ${ATLAS_ROWS*ICON_PX}px`;
      el.style.backgroundPosition = `-${tx*ICON_PX}px -${ty*ICON_PX}px`;
    }

    // ======================================================
    // Look controls
    // ======================================================
    let lookMode = "drag";
    let yaw = 0, pitch = 0;
    const SENS = 0.0025;
    const PITCH_LIMIT = Math.PI/2 - 0.01;

    function applyLook() { camera.rotation.y = yaw; camera.rotation.x = pitch; }
    function rotateBy(dx, dy) {
      yaw   -= dx * SENS;
      pitch -= dy * SENS;
      pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      applyLook();
    }
    function isLocked() { return document.pointerLockElement === renderer.domElement; }

    let rmbDown = false;
    let rmbMoved = 0;
    let rmbStartT = 0;
    let lastX = 0, lastY = 0;

    function startDragLook(clientX, clientY) {
      rmbDown = true; rmbMoved = 0; rmbStartT = performance.now();
      lastX = clientX; lastY = clientY;
      renderer.domElement.style.cursor = "none";
      updateHelp();
    }
    function stopDragLook() {
      rmbDown = false;
      renderer.domElement.style.cursor = "";
      updateHelp();
    }

    // ======================================================
    // UI state
    // ======================================================
    let inventoryOpen = false;

    function exitPointerLock() {
      try { if (document.pointerLockElement) document.exitPointerLock(); } catch (_) {}
    }
    function gameActive() { return menuOverlay.style.display === "none" && !inventoryOpen; }

    function setMenu(open) {
      menuOverlay.style.display = open ? "grid" : "none";
      if (open) exitPointerLock();
      updateHelp();
    }
    function setInventory(open) {
      inventoryOpen = open;
      invOverlay.style.display = open ? "grid" : "none";
      if (open) {
        exitPointerLock();
        rmbDown = false;
        renderer.domElement.style.cursor = "";
        setTimeout(() => { try { searchEl.focus(); } catch(_) {} }, 0);
      }
      updateHelp();
    }

    function requestPointerLock() {
      try { renderer.domElement.requestPointerLock(); } catch (_) {}
    }
    function resumeGameTryLock() {
      if (!gameActive()) return;
      lookMode = "drag";
      requestPointerLock();
      setTimeout(() => { if (!isLocked()) lookMode = "drag"; updateHelp(); }, 180);
    }

    function startGame() {
      setMenu(false);
      setInventory(false);
      renderer.domElement.focus({ preventScroll: true });
      resumeGameTryLock();
      updateHelp();
    }

    playBtn.addEventListener("click", (e) => { e.preventDefault(); startGame(); });
    invClose.addEventListener("click", (e) => { e.preventDefault(); setInventory(false); resumeGameTryLock(); });
    renderer.domElement.addEventListener("mousedown", () => { if (gameActive() && !isLocked()) resumeGameTryLock(); });

    document.addEventListener("pointerlockchange", () => {
      if (isLocked()) lookMode = "pointerlock";
      else if (lookMode === "pointerlock" && gameActive()) setMenu(true);
      updateHelp();
    });
    document.addEventListener("pointerlockerror", () => { lookMode = "drag"; updateHelp(); });

    // ======================================================
    // Input
    // ======================================================
    const keys = new Set();

    window.addEventListener("keydown", (e) => {
      if (e.code === "KeyE" || e.code === "Escape") e.preventDefault();
      keys.add(e.code);

      if (e.code === "KeyE") {
        keys.delete("KeyE");
        if (menuOverlay.style.display !== "none") return;
        setInventory(!inventoryOpen);
        if (!inventoryOpen) resumeGameTryLock();
        return;
      }

      if (e.code === "Escape" && !isLocked()) {
        keys.delete("Escape");
        if (inventoryOpen) { setInventory(false); resumeGameTryLock(); }
        else setMenu(true);
        return;
      }

      if (e.code.startsWith("Digit")) {
        const n = Number(e.code.slice(5));
        if (n >= 1 && n <= 9) selectHotbar(n - 1);
      }
    });
    window.addEventListener("keyup", (e) => keys.delete(e.code));
    window.addEventListener("contextmenu", (e) => e.preventDefault());

    window.addEventListener("mousemove", (e) => {
      if (!gameActive()) return;
      if (isLocked()) { rotateBy(e.movementX || 0, e.movementY || 0); return; }
      if (lookMode === "drag" && rmbDown) {
        const dx = (typeof e.movementX === "number") ? e.movementX : (e.clientX - lastX);
        const dy = (typeof e.movementY === "number") ? e.movementY : (e.clientY - lastY);
        lastX = e.clientX; lastY = e.clientY;
        rmbMoved += Math.abs(dx) + Math.abs(dy);
        rotateBy(dx, dy);
      }
    }, { passive: true });

    // ======================================================
    // Deterministic world gen (same as before)
    // ======================================================
    function hash2(x,z) {
      let n = (x|0) * 374761393 + (z|0) * 668265263;
      n = (n ^ (n >> 13)) * 1274126177;
      return ((n ^ (n >> 16)) >>> 0) / 4294967295;
    }

    function surfaceY(x,z) {
      const a = hash2(x, z);
      const b = hash2(x + 101, z - 77);
      const c = hash2(x * 2 + 13, z * 2 - 9);
      let h = SURFACE_Y_BASE
        + Math.floor((a - 0.5) * 6)
        + Math.floor((b - 0.5) * 4)
        + Math.floor((c - 0.5) * 3);
      h = Math.max(3, Math.min(WORLD_H - 4, h));
      return h;
    }

    function treeInfo(tx, tz) {
      const top = surfaceY(tx, tz);
      const r = hash2(tx * 3, tz * 3);
      if (r <= 0.992) return null;
      const trunkH = 3 + Math.floor(hash2(tx - 11, tz + 7) * 3);
      const ly = Math.min(WORLD_H - 2, top + trunkH);
      return { top, trunkH, ly };
    }

    function baseBlockAt(x, y, z) {
      if (y < 0 || y >= WORLD_H) return B.AIR;
      if (y === 0) return B.BEDROCK;

      const top = surfaceY(x, z);

      const ti = treeInfo(x, z);
      if (ti && y > ti.top && y <= ti.top + ti.trunkH) return B.LOG;

      if (y >= 4) {
        const candidates = [[x,z],[x-1,z],[x+1,z],[x,z-1],[x,z+1]];
        for (const [tx,tz] of candidates) {
          const inf = treeInfo(tx, tz);
          if (!inf) continue;
          if (y !== inf.ly) continue;
          const dx = x - tx, dz = z - tz;
          if ((dx === 0 && Math.abs(dz) <= 1) || (dz === 0 && Math.abs(dx) <= 1)) {
            if (!(dx === 0 && dz === 0)) return B.LEAVES;
          }
        }
      }

      if (y === top) return B.GRASS;
      if (y === top - 1 || y === top - 2) return B.DIRT;
      if (y < top - 2) return B.COBBLE;
      return B.AIR;
    }

    // ======================================================
    // Chunk edits only (infinite world persistence in-memory)
    // ======================================================
    const chunkEdits = new Map(); // "cx,cz" -> Map(localIndex -> blockId)
    function chunkKey(cx, cz) { return cx + "," + cz; }

    function floorDiv(a, b) {
      const q = Math.trunc(a / b);
      return (a < 0 && a % b !== 0) ? (q - 1) : q;
    }
    function mod(a, b) {
      const m = a % b;
      return m < 0 ? m + b : m;
    }
    function localIndex(lx, y, lz) {
      return (y * CHUNK + lz) * CHUNK + lx;
    }

    function getEdit(cx, cz, lx, y, lz) {
      const m = chunkEdits.get(chunkKey(cx, cz));
      if (!m) return null;
      const v = m.get(localIndex(lx, y, lz));
      return (v === undefined) ? null : v;
    }

    function setEdit(wx, y, wz, blockId) {
      const cx = floorDiv(wx, CHUNK);
      const cz = floorDiv(wz, CHUNK);
      const lx = mod(wx, CHUNK);
      const lz = mod(wz, CHUNK);
      const key = chunkKey(cx, cz);
      let m = chunkEdits.get(key);
      if (!m) { m = new Map(); chunkEdits.set(key, m); }
      m.set(localIndex(lx, y, lz), blockId);
    }

    function getBlock(wx, y, wz) {
      if (y < 0 || y >= WORLD_H) return B.AIR;
      const cx = floorDiv(wx, CHUNK);
      const cz = floorDiv(wz, CHUNK);
      const lx = mod(wx, CHUNK);
      const lz = mod(wz, CHUNK);
      const ev = getEdit(cx, cz, lx, y, lz);
      if (ev !== null) return ev;
      return baseBlockAt(wx, y, wz);
    }

    function isSolid(t) { return t !== B.AIR; }

    // ======================================================
    // Chunk objects + meshing (faster build via local voxel cache)
    // ======================================================
    const chunks = new Map(); // key -> {cx,cz, meshes:[]}

    function disposeChunk(chunk) {
      for (const m of chunk.meshes) scene.remove(m);
      chunk.meshes.length = 0;
    }

    function buildChunkMeshes(cx, cz) {
      const wx0 = cx * CHUNK;
      const wz0 = cz * CHUNK;

      // cache voxel values for the chunk (16*16*WORLD_H = small)
      const data = new Uint8Array(CHUNK * CHUNK * WORLD_H);
      const idx = (lx, lz, y) => (y * CHUNK + lz) * CHUNK + lx;

      for (let y=0; y<WORLD_H; y++) {
        for (let lz=0; lz<CHUNK; lz++) for (let lx=0; lx<CHUNK; lx++) {
          const wx = wx0 + lx;
          const wz = wz0 + lz;
          data[idx(lx,lz,y)] = getBlock(wx, y, wz);
        }
      }

      function getLocal(lx,lz,y){
        if (y < 0 || y >= WORLD_H) return B.AIR;
        if (lx>=0 && lx<CHUNK && lz>=0 && lz<CHUNK) return data[idx(lx,lz,y)];
        // neighbor chunk
        const wx = wx0 + lx;
        const wz = wz0 + lz;
        return getBlock(wx, y, wz);
      }

      const positions = new Map(); // id -> array of {x,y,z}
      for (let lz=0; lz<CHUNK; lz++) for (let lx=0; lx<CHUNK; lx++) {
        const wx = wx0 + lx;
        const wz = wz0 + lz;

        // scan full height so edits render at any Y (fixes 'random' glass x-ray / build-limit glitches)
        for (let y=0; y<WORLD_H; y++) {
          const t = getLocal(lx,lz,y);
          if (!isSolid(t)) continue;

          const exposed =
            !isSolid(getLocal(lx+1,lz,y)) || !isSolid(getLocal(lx-1,lz,y)) ||
            !isSolid(getLocal(lx,lz,y+1)) || !isSolid(getLocal(lx,lz,y-1)) ||
            !isSolid(getLocal(lx,lz+1,y)) || !isSolid(getLocal(lx,lz-1,y));

          if (!exposed) continue;

          if (!positions.has(t)) positions.set(t, []);
          positions.get(t).push({x: wx, y, z: wz});
        }
      }

      const meshes = [];
      const mtx = new THREE.Matrix4();
      for (const [id, list] of positions.entries()) {
        const g = geomFor.get(id) || geomFor.get(B.DIRT);
        const mat = materialFor(id);
        const mesh = new THREE.InstancedMesh(g, mat, list.length);
        mesh.frustumCulled = true;
        for (let i=0; i<list.length; i++) {
          const p = list[i];
          mtx.makeTranslation(p.x + 0.5, p.y + 0.5, p.z + 0.5);
          mesh.setMatrixAt(i, mtx);
        }
        mesh.instanceMatrix.needsUpdate = true;
        meshes.push(mesh);
      }
      return meshes;
    }

    function loadChunk(cx, cz) {
      const key = chunkKey(cx, cz);
      if (chunks.has(key)) return;
      const chunk = { cx, cz, meshes: [] };
      chunk.meshes = buildChunkMeshes(cx, cz);
      for (const m of chunk.meshes) scene.add(m);
      chunks.set(key, chunk);
    }

    function rebuildChunk(cx, cz) {
      const key = chunkKey(cx, cz);
      const chunk = chunks.get(key);
      if (!chunk) return;
      disposeChunk(chunk);
      chunk.meshes = buildChunkMeshes(cx, cz);
      for (const m of chunk.meshes) scene.add(m);
    }

    function markChunksDirtyForBlock(wx, wz) {
      const cx = floorDiv(wx, CHUNK);
      const cz = floorDiv(wz, CHUNK);
      rebuildChunk(cx, cz);

      const lx = mod(wx, CHUNK);
      const lz = mod(wz, CHUNK);
      if (lx === 0) rebuildChunk(cx - 1, cz);
      if (lx === CHUNK - 1) rebuildChunk(cx + 1, cz);
      if (lz === 0) rebuildChunk(cx, cz - 1);
      if (lz === CHUNK - 1) rebuildChunk(cx, cz + 1);
    }

    function updateChunkStreaming(playerX, playerZ) {
      const pcx = floorDiv(Math.floor(playerX), CHUNK);
      const pcz = floorDiv(Math.floor(playerZ), CHUNK);

      const want = new Set();
      for (let dz=-RADIUS; dz<=RADIUS; dz++) for (let dx=-RADIUS; dx<=RADIUS; dx++) {
        want.add(chunkKey(pcx + dx, pcz + dz));
      }

      // unload
      for (const [key, chunk] of chunks.entries()) {
        if (!want.has(key)) {
          disposeChunk(chunk);
          chunks.delete(key);
        }
      }

      // load missing nearest-first (limited per frame)
      const missing = [];
      for (let dz=-RADIUS; dz<=RADIUS; dz++) for (let dx=-RADIUS; dx<=RADIUS; dx++) {
        const cx = pcx + dx, cz = pcz + dz;
        const key = chunkKey(cx, cz);
        if (!chunks.has(key)) missing.push({cx, cz, d2: dx*dx + dz*dz});
      }
      missing.sort((a,b) => a.d2 - b.d2);

      for (let i=0; i<Math.min(MAX_LOADS_PER_FRAME, missing.length); i++) {
        loadChunk(missing[i].cx, missing[i].cz);
      }
    }

    // ======================================================
    // Highlight
    // ======================================================
    const highlight = new THREE.Mesh(
      new THREE.BoxGeometry(1.01, 1.01, 1.01),
      new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.35 })
    );
    highlight.visible = false;
    scene.add(highlight);

    function blockCenter(x,y,z) { return new THREE.Vector3(x+0.5, y+0.5, z+0.5); }

    // ======================================================
    // Fast voxel raycast (DDA): replaces Three.js raycaster
    // ======================================================
    function voxelRaycast(origin, dir, maxDist) {
      // origin: Vector3; dir: normalized Vector3
      let x = Math.floor(origin.x);
      let y = Math.floor(origin.y);
      let z = Math.floor(origin.z);

      const stepX = dir.x > 0 ? 1 : -1;
      const stepY = dir.y > 0 ? 1 : -1;
      const stepZ = dir.z > 0 ? 1 : -1;

      const tDeltaX = dir.x === 0 ? 1e30 : Math.abs(1 / dir.x);
      const tDeltaY = dir.y === 0 ? 1e30 : Math.abs(1 / dir.y);
      const tDeltaZ = dir.z === 0 ? 1e30 : Math.abs(1 / dir.z);

      const nextVoxelBoundary = (p, i, step) => step > 0 ? (i + 1) : i; // boundary coordinate
      let tMaxX = dir.x === 0 ? 1e30 : (nextVoxelBoundary(origin.x, x, stepX) - origin.x) / dir.x;
      let tMaxY = dir.y === 0 ? 1e30 : (nextVoxelBoundary(origin.y, y, stepY) - origin.y) / dir.y;
      let tMaxZ = dir.z === 0 ? 1e30 : (nextVoxelBoundary(origin.z, z, stepZ) - origin.z) / dir.z;

      // If we start inside a solid block, count it.
      if (y >= 0 && y < WORLD_H && isSolid(getBlock(x,y,z))) {
        return { x, y, z, nx: 0, ny: 0, nz: 0, dist: 0 };
      }

      let nx=0, ny=0, nz=0;
      let t = 0;

      // upper bound on steps
      const maxSteps = 256;
      for (let i=0; i<maxSteps; i++) {
        if (t > maxDist) break;

        if (tMaxX < tMaxY && tMaxX < tMaxZ) {
          x += stepX;
          t = tMaxX;
          tMaxX += tDeltaX;
          nx = -stepX; ny = 0; nz = 0;
        } else if (tMaxY < tMaxZ) {
          y += stepY;
          t = tMaxY;
          tMaxY += tDeltaY;
          nx = 0; ny = -stepY; nz = 0;
        } else {
          z += stepZ;
          t = tMaxZ;
          tMaxZ += tDeltaZ;
          nx = 0; ny = 0; nz = -stepZ;
        }

        if (y < 0 || y >= WORLD_H) continue;
        const b = getBlock(x, y, z);
        if (isSolid(b)) {
          return { x, y, z, nx, ny, nz, dist: t };
        }
      }
      return null;
    }

    // ======================================================
    // Player physics
    // ======================================================
    const player = { pos: new THREE.Vector3(0.5, WORLD_H - 4, 0.5), velY: 0, onGround: false };

    function aabbCollides(feetPos) {
      const r=PLAYER.radius, h=PLAYER.height;
      const minX=feetPos.x-r, maxX=feetPos.x+r;
      const minY=feetPos.y,   maxY=feetPos.y+h;
      const minZ=feetPos.z-r, maxZ=feetPos.z+r;

      const x0=Math.floor(minX), x1=Math.floor(maxX);
      const y0=Math.floor(minY), y1=Math.floor(maxY);
      const z0=Math.floor(minZ), z1=Math.floor(maxZ);

      for (let x=x0; x<=x1; x++) for (let y=y0; y<=y1; y++) for (let z=z0; z<=z1; z++) {
        if (!isSolid(getBlock(x,y,z))) continue;
        if ((minX < x+1 && maxX > x) && (minY < y+1 && maxY > y) && (minZ < z+1 && maxZ > z)) return true;
      }
      return false;
    }

    function tryMoveAxis(axis, amount) {
      if (!amount) return false;
      player.pos[axis] += amount;
      if (aabbCollides(player.pos)) { player.pos[axis] -= amount; return true; }
      return false;
    }

    function playerOverlapsBlock(x,y,z) {
      const r=PLAYER.radius, h=PLAYER.height;
      const minX=player.pos.x-r, maxX=player.pos.x+r;
      const minY=player.pos.y,   maxY=player.pos.y+h;
      const minZ=player.pos.z-r, maxZ=player.pos.z+r;
      return (minX < x+1 && maxX > x) && (minY < y+1 && maxY > y) && (minZ < z+1 && maxZ > z);
    }

    function syncCamera() { camera.position.set(player.pos.x, player.pos.y + PLAYER.eye, player.pos.z); }
    syncCamera();
    applyLook();

    // ======================================================
    // Hotbar + inventory UI (now uses atlas icons)
    // ======================================================
    const HOTBAR_SIZE = 9;
    const hotbar = new Array(HOTBAR_SIZE).fill(B.GRASS);
    hotbar[0]=B.GRASS; hotbar[1]=B.COBBLE; hotbar[2]=B.LOG; hotbar[3]=B.PLANKS; hotbar[4]=B.DIRT;
    hotbar[5]=B.SAND;  hotbar[6]=B.GLASS;  hotbar[7]=B.BRICKS; hotbar[8]=B.LEAVES;
    let hotbarIndex = 0;

    function renderHotbarHud() {
      hotbarHudEl.innerHTML = "";
      for (let i=0; i<HOTBAR_SIZE; i++) {
        const d = document.createElement("div");
        d.className = "hb-slot" + (i === hotbarIndex ? " selected" : "");
        const sw = document.createElement("div");
        sw.className = "hb-swatch";
        applyTileStyle(sw, blockIcon(hotbar[i]));
        d.appendChild(sw);
        hotbarHudEl.appendChild(d);
      }
    }

    function renderInvHotbar() {
      invHotbarEl.innerHTML = "";
      for (let i=0; i<HOTBAR_SIZE; i++) {
        const d = document.createElement("div");
        d.className = "slot" + (i === hotbarIndex ? " sel" : "");
        const sw = document.createElement("div");
        sw.className = "sw";
        applyTileStyle(sw, blockIcon(hotbar[i]));
        d.appendChild(sw);
        d.addEventListener("click", () => selectHotbar(i));
        invHotbarEl.appendChild(d);
      }
    }

    function selectHotbar(i) {
      hotbarIndex = Math.max(0, Math.min(HOTBAR_SIZE - 1, i));
      renderHotbarHud();
      renderInvHotbar();
      updateHelp();
    }
    function selectedBlock() { return hotbar[hotbarIndex]; }
    function putInSelectedSlot(blockId) {
      hotbar[hotbarIndex] = blockId;
      renderHotbarHud();
      renderInvHotbar();
      updateHelp();
    }

    function renderPalette(filterText = "") {
      const q = filterText.trim().toLowerCase();
      paletteGridEl.innerHTML = "";
      const list = q ? BLOCK_LIST.filter(b => b.name.toLowerCase().includes(q)) : BLOCK_LIST;

      for (const it of list) {
        const d = document.createElement("div");
        d.className = "palSlot";
        d.dataset.name = it.name;
        const sw = document.createElement("div");
        sw.className = "sw";
        applyTileStyle(sw, it.icon);
        d.appendChild(sw);
        d.addEventListener("click", () => putInSelectedSlot(it.id));
        paletteGridEl.appendChild(d);
      }
    }

    searchEl.addEventListener("input", () => renderPalette(searchEl.value));

    renderPalette("");
    renderHotbarHud();
    renderInvHotbar();

    // ======================================================
    // Block interactions (use DDA hit)
    // ======================================================
    function currentHit() {
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      dir.normalize();
      return voxelRaycast(camera.position, dir, 7.0);
    }

    function breakAt(hit) {
      if (!hit) return;
      if (hit.y === 0) return; // bedrock
      setEdit(hit.x, hit.y, hit.z, B.AIR);
      markChunksDirtyForBlock(hit.x, hit.z);
    }

    function placeAt(hit) {
      if (!hit) return;
      const px = hit.x + hit.nx;
      const py = hit.y + hit.ny;
      const pz = hit.z + hit.nz;
      if (py < 0 || py >= WORLD_H) return;
      if (getBlock(px, py, pz) !== B.AIR) return;
      if (playerOverlapsBlock(px, py, pz)) return;
      setEdit(px, py, pz, selectedBlock());
      markChunksDirtyForBlock(px, pz);
    }

    function pickBlockIntoSlot(hit) {
      if (!hit) return;
      const t = getBlock(hit.x, hit.y, hit.z);
      if (t !== B.AIR) putInSelectedSlot(t);
    }

    window.addEventListener("mousedown", (e) => {
      if (!gameActive()) return;

      if (e.button === 0) { // break
        const hit = currentHit();
        breakAt(hit);
      }

      if (e.button === 1) { // pick
        const hit = currentHit();
        pickBlockIntoSlot(hit);
      }

      if (e.button === 2) { // place or drag look
        if (isLocked()) {
          const hit = currentHit();
          placeAt(hit);
        } else {
          startDragLook(e.clientX, e.clientY);
        }
      }
    });

    window.addEventListener("mouseup", (e) => {
      if (e.button !== 2) return;
      if (!gameActive()) return;
      if (!rmbDown) return;

      const dt = performance.now() - rmbStartT;
      const moved = rmbMoved;
      stopDragLook();

      if (dt < 300 && moved < 10) {
        const hit = currentHit();
        placeAt(hit);
      }
    });

    // ======================================================
    // Mob (simple)
    // ======================================================
    const mob = new THREE.Mesh(
      new THREE.BoxGeometry(0.9, 0.9, 0.9),
      new THREE.MeshLambertMaterial({ map: atlasTex, transparent: false })
    );
    mob.geometry = makeUVBox(allFaces(T.planks)); // re-use a wood-ish look
    mob.position.set(6.5, SURFACE_Y_BASE + 3.0, 6.5);
    scene.add(mob);

    const mobState = { t: 0, dir: new THREE.Vector2(1,0), speed: 1.0 };
    function updateMob(dt) {
      mobState.t += dt;
      if (Math.floor(mobState.t * 2) % 12 === 0) {
        const a = (hash2(Math.floor(mob.position.x*7), Math.floor(mob.position.z*7)) * Math.PI * 2);
        mobState.dir.set(Math.cos(a), Math.sin(a));
      }
      const step = mobState.speed * dt;
      mob.position.x = THREE.MathUtils.clamp(mob.position.x + mobState.dir.x * step, -20, 20);
      mob.position.z = THREE.MathUtils.clamp(mob.position.z + mobState.dir.y * step, -20, 20);

      const bx = Math.floor(mob.position.x);
      const bz = Math.floor(mob.position.z);
      mob.position.y = surfaceY(bx,bz) + 1.0;

      mob.rotation.y += dt * 0.7;
    }

    // ======================================================
    // HUD help
    // ======================================================
    function updateHelp() {
      const state = inventoryOpen ? "Inventory" : (menuOverlay.style.display !== "none" ? "Menu" : (isLocked() ? "Mouse Look" : "Drag Look"));
      const sel = selectedBlock();
      const pcx = floorDiv(Math.floor(player.pos.x), CHUNK);
      const pcz = floorDiv(Math.floor(player.pos.z), CHUNK);

      const lockHint = (!inventoryOpen && menuOverlay.style.display === "none" && !isLocked())
        ? "Click canvas to recapture (or RMB-drag to look)\n"
        : "";

      helpEl.textContent =
        `Mini INDEV Voxel — Infinite + Textures\n` +
        `State: ${state}\n` +
        `Selected: [${hotbarIndex+1}] ${blockName(sel)}\n` +
        `Chunk: (${pcx}, ${pcz})  Loaded: ${chunks.size}\n` +
        `WASD move · Shift sprint · Space jump · LMB break · RMB place · MMB pick · 1–9 hotbar · E inventory · Esc menu\n` +
        `Perf: voxel DDA picking + chunk-local caches\n` +
        lockHint;
    }

    // ======================================================
    // Resize
    // ======================================================
    window.addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ======================================================
    // Spawn + initial chunks
    // ======================================================
    (function spawnOnSurface() {
      const sx = 0, sz = 0;
      const top = surfaceY(sx, sz);
      player.pos.set(sx + 0.5, top + 2.0, sz + 0.5);
      syncCamera();
    })();

    (function primeChunks() {
      const pcx = floorDiv(Math.floor(player.pos.x), CHUNK);
      const pcz = floorDiv(Math.floor(player.pos.z), CHUNK);
      for (let dz=-RADIUS; dz<=RADIUS; dz++) for (let dx=-RADIUS; dx<=RADIUS; dx++) {
        loadChunk(pcx + dx, pcz + dz);
      }
      updateHelp();
    })();

    // ======================================================
    // Main loop
    // ======================================================
    const clock = new THREE.Clock();
    let hudTimer = 0;

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());

      if (gameActive()) {
        const forward = (keys.has("KeyW") ? 1 : 0) - (keys.has("KeyS") ? 1 : 0);
        const strafe  = (keys.has("KeyD") ? 1 : 0) - (keys.has("KeyA") ? 1 : 0);

        const dir = new THREE.Vector3();
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        camDir.y = 0; camDir.normalize();
        const right = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0,1,0)).normalize();

        dir.addScaledVector(camDir, forward);
        dir.addScaledVector(right, strafe);
        if (dir.lengthSq() > 0) dir.normalize();

        const sprint = (keys.has("ShiftLeft") || keys.has("ShiftRight")) ? 1.75 : 1.0;
        const move = (PLAYER.speed * sprint) * dt;
        tryMoveAxis("x", dir.x * move);
        tryMoveAxis("z", dir.z * move);

        player.velY -= PLAYER.gravity * dt;
        player.velY = Math.max(-PLAYER.terminal, player.velY);

        if (player.onGround && keys.has("Space")) {
          player.velY = PLAYER.jump;
          player.onGround = false;
        }

        player.onGround = false;
        const dy = player.velY * dt;
        const collidedY = tryMoveAxis("y", dy);
        if (collidedY && dy < 0) { player.onGround = true; player.velY = 0; }
        else if (collidedY && dy > 0) { player.velY = 0; }

        syncCamera();

        updateChunkStreaming(player.pos.x, player.pos.z);

        // highlight using DDA hit (no raycaster)
        const hit = currentHit();
        if (hit && getBlock(hit.x, hit.y, hit.z) !== B.AIR) {
          highlight.visible = true;
          highlight.position.copy(blockCenter(hit.x, hit.y, hit.z));
        } else {
          highlight.visible = false;
        }

        updateMob(dt);
      } else {
        highlight.visible = false;
      }

      renderer.render(scene, camera);

      hudTimer += dt;
      if (hudTimer > 0.15) { hudTimer = 0; updateHelp(); }
    }
    animate();

    // Start at menu
    setMenu(true);

  })();
  </script>
</body>
</html>
