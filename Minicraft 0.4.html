<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini INDEV Voxel (Infinite + Textures + Faster)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { display: block; }


    /* Fluid tint overlay (underwater/lava) */
    #fluidTint {
      position: fixed; inset: 0;
      pointer-events: none;
      background: rgba(18, 70, 190, 0.42);
      opacity: 0;
      transition: opacity 80ms linear;
      z-index: 2;
    }
    #hitFlash {
      position: fixed; inset: 0;
      pointer-events: none;
      background: rgba(255, 255, 255, 0.35);
      opacity: 0;
      transition: opacity 120ms ease;
      z-index: 3;
    }
    #hitFlash.active { opacity: 1; }

    /* HUD */
    #hud { position: fixed; inset: 0; pointer-events: none; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,.85); }
    #crosshair {
      position: absolute; left: 50%; top: 50%;
      width: 14px; height: 14px; transform: translate(-50%,-50%); opacity: .9;
    }
    #crosshair:before, #crosshair:after {
      content: ""; position: absolute; left: 50%; top: 50%;
      background: rgba(255,255,255,.95);
      transform: translate(-50%,-50%); border-radius: 1px;
    }
    #crosshair:before { width: 14px; height: 2px; }
    #crosshair:after  { width: 2px;  height: 14px; }

    #help {
      position: absolute; left: 12px; top: 10px;
      background: rgba(0,0,0,.32);
      border: 1px solid rgba(255,255,255,.12);
      padding: 10px 12px; border-radius: 12px;
      max-width: 920px; line-height: 1.35;
      white-space: pre-wrap;
    }

    /* Hotbar (in-game) */
    #hotbarHud {
      position: absolute; left: 50%; bottom: 18px; transform: translateX(-50%);
      display: grid; grid-auto-flow: column; gap: 8px;
      background: rgba(0,0,0,.32);
      border: 1px solid rgba(255,255,255,.12);
      padding: 8px; border-radius: 12px;
      pointer-events: none;
    }

    /* Survival HUD (Minecraft-ish hearts / armor / hunger) */
    #statusHud {
      position: absolute;
      left: 50%;
      bottom: 102px;
      transform: translateX(-50%);
      display: none; /* shown in survival */
      align-items: flex-end;
      justify-content: space-between;
      gap: 40px;
      pointer-events: none;
      filter: drop-shadow(0 2px 0 rgba(0,0,0,.60)) drop-shadow(0 0 6px rgba(0,0,0,.35));
      --uiSprite: none;
    }
    .statusSide { display: grid; gap: 2px; }
    .statusRow { display: flex; gap: 0px; }
    .uiIcon {
      width: 24px; height: 24px;
      background-image: var(--uiSprite);
      background-repeat: no-repeat;
      image-rendering: pixelated;
      opacity: 0.98;
    }


/* Chat */
#chatWrap {
  position: absolute; left: 12px; bottom: 74px;
  width: min(460px, calc(100vw - 24px));
  pointer-events: none;
  font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 14px;
  line-height: 1.45;
  color: #fff;
  text-shadow: 0 2px 0 rgba(0,0,0,.65), 0 0 6px rgba(0,0,0,.35);
}
#chatLog {
  display: grid;
  gap: 4px;
  margin-bottom: 8px;
  max-height: 220px; /* tighter chat height */
  overflow-y: hidden; /* becomes scrollable when chat is open */
  padding-right: 6px;
}
.chatLine {
  display: inline-block;
  background: rgba(0,0,0,.25);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 10px;
  padding: 6px 8px;
  max-width: 100%;
  overflow-wrap: anywhere;
}
#chatInputRow { display: none; pointer-events: auto; }
#chatInput {
  width: 100%;
  appearance: none;
  border: 1px solid rgba(255,255,255,.18);
  background: rgba(0,0,0,.40);
  color: #fff;
  padding: 10px 12px;
  border-radius: 12px;
  outline: none;
  font: inherit;
  line-height: 1.2;
}
#chatHint { margin-top: 6px; opacity: .75; font-size: 10px; }



/* Viewmodel (hand + held block) */
#viewModel {
  position: absolute;
  right: 10px;
  bottom: 0px;
  width: 280px;
  height: 240px;
  pointer-events: none;
}
#heldCube {
  display: none; /* superseded by 3D held block */
  position: absolute;
  right: 92px;
  bottom: 70px;
  width: 60px;
  height: 60px;
  transform-style: preserve-3d;
  transform: perspective(520px) rotateX(-30deg) rotateY(45deg);
}
#heldCube .face {
  position: absolute;
  width: 60px;
  height: 60px;
  background-repeat: no-repeat;
  image-rendering: pixelated;
  backface-visibility: hidden;
}
#heldCube .top   { transform: rotateX(90deg) translateZ(30px); filter: brightness(1.08); }
#heldCube .front { transform: translateZ(30px); filter: brightness(0.96); }
#heldCube .right { transform: rotateY(90deg) translateZ(30px); filter: brightness(0.82); }
#steveHand {
  position: absolute;
  right: -14px;
  bottom: -28px;
  width: 210px;
  height: 210px;
  background-repeat: no-repeat;
  background-size: contain;
  image-rendering: pixelated;
  transform: rotate(12deg);
  transform-origin: 100% 100%;
  opacity: 0.98;
  filter: drop-shadow(0 8px 12px rgba(0,0,0,.35));
}
    .hb-slot {
      position: relative;
      width: 46px; height: 46px; border-radius: 10px;
      border: 2px solid rgba(255,255,255,.22);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.25);
      display: grid; place-items: center;
    }
    .hb-slot.selected { border-color: rgba(255,255,255,.92); }
    .hb-swatch {
      width: 28px; height: 28px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,.30);
      box-shadow: 0 2px 6px rgba(0,0,0,.35);
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }
    .hb-slot .durability, .slot .durability {
      position: absolute;
      left: 5px;
      right: 5px;
      bottom: 4px;
      height: 4px;
      background: rgba(0,0,0,.55);
      border-radius: 999px;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.15);
    }
    .durability .durabilityFill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, rgba(80,220,80,.95), rgba(240,210,60,.95));
      transition: width 120ms ease;
    }

    /* Menu overlay */
    #menuOverlay {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,.35), rgba(0,0,0,.75));
      color: #fff;
      user-select: none;
      z-index: 10;
    }
    #menuPanel {
      width: min(560px, calc(100vw - 24px));
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 12px 40px rgba(0,0,0,.55);
      text-align: center;
    }
    #menuTitle { margin: 0 0 8px; font-size: 18px; font-weight: 900; }
    #menuSub   { margin: 0 0 12px; opacity: .92; line-height: 1.35; }
    .btn {
      width: 100%;
      appearance: none; border: 0;
      background: rgba(255,255,255,.92); color: #000;
      font-weight: 900; font-size: 15px;
      padding: 12px 14px; border-radius: 12px;
      cursor: pointer;
    }
    .tiny { margin-top: 10px; font-size: 12px; opacity: .75; line-height: 1.35; }

    /* Inventory overlay */
    #invOverlay {
      position: fixed; inset: 0;
      display: none;
      place-items: center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,.25), rgba(0,0,0,.85));
      color: #fff;
      user-select: none;
      z-index: 20;
    }
    #invWindow {
      width: min(980px, calc(100vw - 24px));
      height: min(680px, calc(100vh - 24px));
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 18px;
      box-shadow: 0 12px 40px rgba(0,0,0,.60);
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      overflow: hidden;
    }
    #invHeader {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      gap: 12px;
    }
    #invHeader .left { display: flex; align-items: baseline; gap: 10px; flex-wrap: wrap; }
    #invHeader b { font-weight: 900; }
    #invHeader .hint { opacity: .8; font-size: 12px; }
    #invClose {
      appearance: none; border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06); color: #fff;
      padding: 8px 10px; border-radius: 12px;
      cursor: pointer;
      font-weight: 800;
      white-space: nowrap;
    }
    #invTools {
      padding: 10px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    #search {
      appearance: none;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.25);
      color: #fff;
      padding: 10px 12px;
      border-radius: 12px;
      outline: none;
      width: min(420px, 100%);
      font-weight: 700;
    }
    #invTools .tip { font-size: 12px; opacity: .85; }


.modeBadge{
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.18);
  background: rgba(0,0,0,.20);
  font-size: 12px;
  font-weight: 900;
  letter-spacing: .02em;
}

#creativeTools {
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
}
#survivalTools { display: none; }

/* Slot counts (Minecraft-ish bottom-right) */
.slot .count, .hb-slot .count, #invCursor .count {
  position: absolute;
  right: 5px;
  bottom: 3px;
  font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 12px;
  line-height: 1;
  opacity: .98;
  text-shadow: 0 2px 0 rgba(0,0,0,.75), 0 0 6px rgba(0,0,0,.35);
  pointer-events: none;
  user-select: none;
}

/* Inventory cursor (held stack while moving items) */
#invCursor {
  position: fixed;
  width: 44px;
  height: 44px;
  display: none;
  pointer-events: none;
  z-index: 25;
  transform: translate(-50%, -50%);
}
#invCursor .sw {
  width: 28px; height: 28px; border-radius: 7px;
  border: 1px solid rgba(255,255,255,.30);
  box-shadow: 0 2px 8px rgba(0,0,0,.35);
  background-repeat: no-repeat;
  image-rendering: pixelated;
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}
    #invBody { padding: 14px; overflow: auto; }

    .grid { display: grid; grid-template-columns: repeat(9, 44px); justify-content: center; gap: 8px; }
    .slot {
      position: relative;
      width: 44px; height: 44px; border-radius: 10px;
      border: 2px solid rgba(255,255,255,.15);
      background: rgba(0,0,0,.22);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.35), 0 6px 16px rgba(0,0,0,.30);
      display: grid; place-items: center;
      cursor: pointer;
    }
    .slot:hover { background: rgba(255,255,255,.05); }
    .slot.sel { border-color: rgba(255,255,255,.85); }
    .slot .sw {
      width: 28px; height: 28px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,.30);
      box-shadow: 0 2px 8px rgba(0,0,0,.35);
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }
    .labelRow {
      display: flex;
      justify-content: center;
      margin: 8px 0 10px;
      font-size: 12px;
      opacity: .85;
      gap: 10px;
      flex-wrap: wrap;
    }
    .sectionTitle {
      text-align: center;
      font-size: 12px;
      letter-spacing: .08em;
      opacity: .85;
      margin: 6px 0 8px;
      text-transform: uppercase;
    }

    #paletteGrid {
      display: grid;
      grid-template-columns: repeat(9, 44px);
      justify-content: center;
      gap: 8px;
    }
    .palSlot {
      position: relative;
      width: 44px; height: 44px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      display: grid; place-items: center;
      cursor: pointer;
      position: relative;
    }
    .palSlot:hover { border-color: rgba(255,255,255,.35); background: rgba(255,255,255,.06); }
    .palSlot .sw {
      width: 28px; height: 28px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,.28);
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }
    .palSlot[data-name]:hover::after {
      content: attr(data-name);
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 52px;
      background: rgba(0,0,0,.75);
      border: 1px solid rgba(255,255,255,.18);
      color: #fff;
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
    }

    /* Inventory tabs (Minecraft-ish) */
    .tabRow {
      display: none; /* shown in Creative mode */
      gap: 10px;
      padding: 10px 14px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
    }
    .tabBtn {
      appearance: none;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.25);
      color: #fff;
      padding: 8px 10px;
      border-radius: 12px;
      cursor: pointer;
      font: inherit;
      font-size: 12px;
      opacity: .92;
    }
    .tabBtn:hover { background: rgba(255,255,255,.08); }
    .tabBtn.active {
      border-color: rgba(255,255,255,.65);
      background: rgba(255,255,255,.10);
      opacity: 1;
    }
    .pane { display: block; }

    /* Creative sub-tabs (organized blocks / items) */
    .subTabRow {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 8px 0 12px 0;
    }
    .subTabBtn {
      appearance: none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.20);
      color: #fff;
      padding: 6px 8px;
      border-radius: 10px;
      cursor: pointer;
      font: inherit;
      font-size: 11px;
      opacity: .90;
    }
    .subTabBtn:hover { background: rgba(255,255,255,.07); }
    .subTabBtn.active {
      border-color: rgba(255,255,255,.55);
      background: rgba(255,255,255,.10);
      opacity: 1;
    }

    #invFooter {
      padding: 12px 14px;
      border-top: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      font-size: 12px;
      opacity: .9;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    /* Texture pack controls */
    #texPackRow { margin-top: 12px; display: grid; gap: 8px; }
    #texPackRow input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.35);
      color: #fff;
      outline: none;
      font-size: 12px;
    }
    #texPackRow select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.35);
      color: #fff;
      outline: none;
      font-size: 12px;
    }
    #texPackRow .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; }
    #texPackApply { padding: 8px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.22); background: rgba(255,255,255,.08); color: #fff; cursor: pointer; }
    #texPackApply:hover { background: rgba(255,255,255,.12); }
    #texPackMissing {
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px dashed rgba(255,255,255,.22);
      background: rgba(255,255,255,.06);
      font-size: 11px;
      color: rgba(255,255,255,.86);
      display: none;
    }

    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <div id="menuOverlay">
    <div id="menuPanel">
      <div id="menuTitle">Mini INDEV Voxel</div>
      <div id="menuSub">
        Infinite chunk world + pixel textures + less CPU lag.<br/>
        Click <b>Play</b>. If mouse-capture is blocked on <code>file://</code>, it falls back to <b>RMB-drag</b>.
      </div>
      <button id="play" class="btn" type="button">Play</button>
      <div id="texPackRow">
        <div class="tiny"><b>Texture pack</b> preset or zip URL. Default is curated 1.21+ Minecraft assets; Kenney (CC0) remains as a low-bandwidth fallback.</div>
        <select id="texPackPreset" aria-label="Texture pack preset"></select>
        <div class="row">
          <input id="texPackUrl" type="text" spellcheck="false" autocomplete="off" placeholder="Paste texture pack .zip URL (CORS-enabled)"/>
          <button id="texPackApply" type="button">Apply</button>
        </div>
        <div id="texPackMissing" class="tiny" role="status" aria-live="polite"></div>
      </div>

      <div class="tiny">
        Controls: <b>WASD</b> move · <b>Shift</b> sprint · <b>Space</b> jump · <b>R</b> crouch · <b>T</b> chat · <b>LMB</b> break · <b>RMB</b> place · <b>MMB</b> pick · <b>1–9</b> hotbar · <b>E</b> inventory · <b>Esc</b> menu
      </div>
    </div>
  </div>
<div id="invOverlay">
  <div id="invWindow">
    <div id="invHeader">
      <div class="left">
        <b id="invTitle">Inventory</b>
        <span id="invMode" class="modeBadge">Survival</span>
        <span id="invHint" class="hint">Press <b>E</b> to close.</span>
      </div>
      <button id="invClose" type="button">Close</button>
    </div>

    <div id="invTools">
      <div id="creativeTools">
        <input id="search" type="text" placeholder="Search blocks…" autocomplete="off" />
        <div class="tip">Creative: click a block to put a full stack into your selected hotbar slot.</div>
      </div>
      <div id="survivalTools" class="tip">Inventory: click to move stacks · Right-click splits/places 1 · Shift-click moves between hotbar and inventory.</div>
    </div>

    <div id="invBody">
      <div id="invTopTabs" class="tabRow">
        <button id="tabInv" class="tabBtn active" type="button">Inventory</button>
        <button id="tabCreative" class="tabBtn" type="button">Creative</button>
      </div>

      <div id="paneCreative" class="pane">
        <div class="sectionTitle">Creative</div>
        <div id="creativeTabs" class="subTabRow"></div>
        <div id="paletteGrid"></div>
      </div>

      <div id="paneInventory" class="pane">
        <div class="sectionTitle">Player inventory</div>
        <div id="invMain" class="grid"></div>

        <div class="labelRow">
          <span><b>Hotbar</b> (click a slot to select)</span>
          <span>·</span>
          <span>Tip: MMB in-world picks blocks in Creative</span>
        </div>
        <div id="invHotbar" class="grid"></div>
      </div>
    </div>

    <div id="invFooter">
      <div>Survival: blocks you break go into your inventory; placing consumes stacks.</div>
      <div>Creative: infinite placing/breaking; palette + search enabled.</div>
    </div>
  </div>
  <div id="invCursor" aria-hidden="true"></div>
</div>

<div id="fluidTint"></div>
<div id="hitFlash"></div>

  <div id="hud">
    <div id="crosshair"></div>
    <div id="help"></div>

    <div id="statusHud"></div>

<div id="chatWrap">
  <div id="chatLog"></div>
  <div id="chatInputRow">
    <input id="chatInput" type="text" maxlength="160" autocomplete="off" spellcheck="false"
           placeholder="Type message… (Enter to send, Esc to cancel)" />
    <div id="chatHint">Chat: T · Send: Enter · Cancel: Esc</div>
  </div>
</div>

    <div id="viewModel">
      <div id="heldCube">
        <div id="heldFaceTop" class="face top"></div>
        <div id="heldFaceFront" class="face front"></div>
        <div id="heldFaceRight" class="face right"></div>
      </div>
      <div id="steveHand"></div>
    </div>

    <div id="hotbarHud"></div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
  (() => {
    "use strict";

    // ======================================================
    // Blocks (toy creative set) + texture tile assignments
    // ======================================================
    const B = {
      AIR: 0,
      GRASS: 1,
      COBBLE: 2,
      LOG: 3,
      DIRT: 4,
      PLANKS: 5,
      SAND: 6,
      GLASS: 7,
      LEAVES: 8,
      BRICKS: 9,
      OBSIDIAN: 10,
      GOLD: 11,
      DIAMOND: 12,
      TNT: 13,
      WOOL_WHITE: 14,
      WOOL_RED: 15,
      WOOL_BLUE: 16,
      WOOL_GREEN: 17,
      WATER: 18, // decorative
      LAVA: 19,  // decorative
      BEDROCK: 20,
      COAL_ORE: 21,
      IRON_ORE: 22,
      GOLD_ORE: 23,
      DIAMOND_ORE: 24,
      CRAFTING_TABLE: 25,
      FURNACE: 26,

      // Tool placeholders (not placeable yet)
      WOODEN_SWORD: 27,
      WOODEN_PICKAXE: 28,
      WOODEN_AXE: 29,
      WOODEN_SHOVEL: 30,
      WOODEN_HOE: 31,

      STONE_SWORD: 32,
      STONE_PICKAXE: 33,
      STONE_AXE: 34,
      STONE_SHOVEL: 35,
      STONE_HOE: 36,

      IRON_SWORD: 37,
      IRON_PICKAXE: 38,
      IRON_AXE: 39,
      IRON_SHOVEL: 40,
      IRON_HOE: 41,

      DIAMOND_SWORD: 42,
      DIAMOND_PICKAXE: 43,
      DIAMOND_AXE: 44,
      DIAMOND_SHOVEL: 45,
      DIAMOND_HOE: 46,
    };

    const WORLD_H = 512;      // fixed world height (taller so amplified mountains can breathe)
    const SEA_LEVEL = 6;    // water level (lowered)
    // ======================================================
    // Chunk streaming config
    // ======================================================
    const CHUNK = 16;
    const RADIUS = 4;              // view distance in chunks
    const MAX_LOADS_PER_FRAME = 1; // stability > speed

    // ======================================================
    // Player
    // ======================================================
    const PLAYER = {
      radius: 0.32,
      height: 1.72,
      eye: 1.62,
      crouchHeight: 1.35,
      crouchEye: 1.20,
      speed: 5.0,
      jump: 7.42,
      gravity: 22.0,
      terminal: 40.0,
    };

    // ======================================================
    // DOM
    // ======================================================
    const menuOverlay = document.getElementById("menuOverlay");
    const playBtn = document.getElementById("play");
    const invOverlay = document.getElementById("invOverlay");
    const invClose = document.getElementById("invClose");
    const helpEl = document.getElementById("help");
    const hotbarHudEl = document.getElementById("hotbarHud");
    const viewModelEl = document.getElementById("viewModel");
    const heldCubeEl = document.getElementById("heldCube");
    const heldFaceTopEl = document.getElementById("heldFaceTop");
    const heldFaceFrontEl = document.getElementById("heldFaceFront");
    const heldFaceRightEl = document.getElementById("heldFaceRight");
    const steveHandEl = document.getElementById("steveHand");
    const fluidTintEl = document.getElementById("fluidTint");
    const hitFlashEl = document.getElementById("hitFlash");
    const statusHudEl = document.getElementById("statusHud");
    const paletteGridEl = document.getElementById("paletteGrid");
    const chatWrap = document.getElementById("chatWrap");
    const chatLogEl = document.getElementById("chatLog");
    const chatInputRow = document.getElementById("chatInputRow");
    const chatInputEl = document.getElementById("chatInput");
    const invHotbarEl = document.getElementById("invHotbar");
    const searchEl = document.getElementById("search");


    const invMainEl = document.getElementById("invMain");
    const invTitleEl = document.getElementById("invTitle");
    const invModeEl = document.getElementById("invMode");
    const invHintEl = document.getElementById("invHint");
    const invTopTabsEl = document.getElementById("invTopTabs");
    const tabInvBtn = document.getElementById("tabInv");
    const tabCreativeBtn = document.getElementById("tabCreative");
    const paneCreativeEl = document.getElementById("paneCreative");
    const paneInventoryEl = document.getElementById("paneInventory");
    const creativeTabsEl = document.getElementById("creativeTabs");
    const creativeToolsEl = document.getElementById("creativeTools");
    const survivalToolsEl = document.getElementById("survivalTools");
    const invCursorEl = document.getElementById("invCursor");
    function updateViewModelVisibility() {
      if (!viewModelEl) return;
      // We render the arm/held block as real 3D viewmodel meshes.
      viewModelEl.style.display = "none";
    }

    function makeSteveHandSprite() {
      const c = document.createElement("canvas");
      c.width = 64; c.height = 64;
      const ctx = c.getContext("2d", { alpha: true });
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0,0,64,64);

      const skin  = "#d7a56d";
      const skinS = "#c58e5a";
      const sleeve  = "#2d5aa8";
      const sleeveS = "#234a89";
      const outline = "rgba(0,0,0,0.35)";

      function px(x,y,col){ ctx.fillStyle = col; ctx.fillRect(x,y,1,1); }
      function rect(x0,y0,w,h,col){ ctx.fillStyle = col; ctx.fillRect(x0,y0,w,h); }

      // Simple blocky arm: sleeve (top), skin (hand). Shaded on right/bottom.
      rect(18, 14, 40, 22, sleeve);
      rect(18, 36, 40, 24, skin);

      // Sleeve cuff line
      rect(18, 34, 40, 2, sleeveS);

      // Shade right edge
      rect(54, 14, 4, 22, sleeveS);
      rect(54, 36, 4, 24, skinS);

      // Shade bottom
      rect(18, 58, 40, 2, skinS);

      // Outline
      for (let y=14; y<=59; y++) { px(18, y, outline); px(57, y, outline); }
      for (let x=18; x<=57; x++) { px(x, 14, outline); px(x, 59, outline); }
      // Little thumb nub
      rect(14, 44, 6, 10, skin);
      rect(14, 52, 6, 2, skinS);
      for (let y=44; y<=53; y++) { px(14, y, outline); px(19, y, outline); }
      for (let x=14; x<=19; x++) { px(x, 44, outline); px(x, 53, outline); }

      return c.toDataURL("image/png");
    }

    if (steveHandEl) {
      steveHandEl.style.backgroundImage = `url(${makeSteveHandSprite()})`;
    }

    // ======================================================
    // Survival HUD sprite (pixel icons) + status rows
    // ======================================================
    const UI_ICON_TILE = 9;   // native pixel size
    const UI_ICON_PX = 24;    // displayed size

    function makeUiSprite() {
      const c = document.createElement("canvas");
      const cols = 9; // heart f/h/e, hunger f/h/e, armor f/h/e
      c.width = cols * UI_ICON_TILE;
      c.height = UI_ICON_TILE;
      const ctx = c.getContext("2d", { alpha: true });
      ctx.imageSmoothingEnabled = false;

      function p(ix, iy, col) {
        ctx.fillStyle = col;
        ctx.fillRect(ix, iy, 1, 1);
      }
      function drawHeart(x0, kind) {
        // 9x9 pixel-ish heart
        const O = "rgba(60,0,0,0.95)";
        const R = "rgba(200,20,20,0.95)";
        const E = "rgba(0,0,0,0)";
        const map = [
          "..##.##..",
          ".#######.",
          "#########",
          "#########",
          ".#######.",
          "..#####..",
          "...###...",
          "....#....",
          ".........",
        ];
        for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
          const ch = map[y][x];
          if (ch === '#') {
            let fill = R;
            if (kind === "empty") fill = E;
            if (kind === "half" && x >= 5) fill = E;
            if (fill !== E) p(x0+x, y, fill);
            // outline where adjacent is empty
            const on = (fill !== E);
            const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
            if (on) {
              for (const [dx,dy] of neighbors) {
                const xx=x+dx, yy=y+dy;
                const inside = (xx>=0&&xx<9&&yy>=0&&yy<9&&map[yy][xx]==='#');
                if (!inside) { p(x0+x, y, O); break; }
              }
            } else if (kind === "empty") {
              // empty heart outline only
              const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
              let near = false;
              for (const [dx,dy] of neighbors) {
                const xx=x+dx, yy=y+dy;
                if (xx>=0&&xx<9&&yy>=0&&yy<9&&map[yy][xx]==='#') near = true;
              }
              if (near && ch === '.') {
                // no-op
              }
            }
          }
        }
        if (kind === "empty" || kind === "half") {
          // outline only (empty) or outline around filled half
          for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
            if (map[y][x] !== '#') continue;
            const filled = (kind === "full") || (kind === "half" && x < 5);
            const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
            let edge = false;
            for (const [dx,dy] of neighbors) {
              const xx=x+dx, yy=y+dy;
              const inside = (xx>=0&&xx<9&&yy>=0&&yy<9&&map[yy][xx]==='#');
              const filledN = inside ? ((kind === "full") || (kind === "half" && xx < 5)) : false;
              if (!filledN) { edge = true; break; }
            }
            if (edge) p(x0+x, y, O);
            else if (kind === "empty") p(x0+x, y, "rgba(0,0,0,0)");
          }
        }
      }

      function drawArmor(x0, kind) {
        // 9x9 simple chestplate/shield-ish icon
        const O = "rgba(15,15,15,0.95)";
        const G = "rgba(205,205,205,0.95)";
        const E = "rgba(0,0,0,0)";
        const map = [
          "..#####..",
          ".#######.",
          "#########",
          "###...###",
          "###...###",
          "#########",
          ".#######.",
          "..#####..",
          ".........",
        ];
        for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
          if (map[y][x] !== '#') continue;
          let fill = G;
          if (kind === "empty") fill = E;
          if (kind === "half" && x >= 5) fill = E;
          if (fill !== E) p(x0+x, y, fill);
        }
        // outline
        for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
          if (map[y][x] !== '#') continue;
          const filled = (kind === "full") || (kind === "half" && x < 5);
          const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
          let edge = false;
          for (const [dx,dy] of neighbors) {
            const xx=x+dx, yy=y+dy;
            const inside = (xx>=0&&xx<9&&yy>=0&&yy<9&&map[yy][xx]==='#');
            const filledN = inside ? ((kind === "full") || (kind === "half" && xx < 5)) : false;
            if (!filledN) { edge = true; break; }
          }
          if (edge && filled) p(x0+x, y, O);
          if (edge && kind === "empty") p(x0+x, y, "rgba(70,70,70,0.55)");
        }
      }

      function drawHunger(x0, kind) {
        // 9x9 drumstick-ish
        const O = "rgba(25,10,0,0.95)";
        const B = "rgba(210,130,50,0.95)";
        const W = "rgba(240,240,240,0.95)";
        const E = "rgba(0,0,0,0)";
        const map = [
          "...###...",
          "..#####..",
          ".#######.",
          ".#######.",
          "..#####..",
          "...###...",
          "...##....",
          "..####...",
          "...##....",
        ];
        for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
          if (map[y][x] !== '#') continue;
          let fill = B;
          if (y >= 6) fill = W; // bone-ish
          if (kind === "empty") fill = E;
          if (kind === "half" && x >= 5) fill = E;
          if (fill !== E) p(x0+x, y, fill);
        }
        // outline
        for (let y=0;y<9;y++) for (let x=0;x<9;x++) {
          if (map[y][x] !== '#') continue;
          const filled = (kind === "full") || (kind === "half" && x < 5);
          const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
          let edge = false;
          for (const [dx,dy] of neighbors) {
            const xx=x+dx, yy=y+dy;
            const inside = (xx>=0&&xx<9&&yy>=0&&yy<9&&map[yy][xx]==='#');
            const filledN = inside ? ((kind === "full") || (kind === "half" && xx < 5)) : false;
            if (!filledN) { edge = true; break; }
          }
          if (edge && filled) p(x0+x, y, O);
          if (edge && kind === "empty") p(x0+x, y, "rgba(90,45,10,0.55)");
        }
      }

      // draw tiles in one row
      drawHeart(0*UI_ICON_TILE, "full");
      drawHeart(1*UI_ICON_TILE, "half");
      drawHeart(2*UI_ICON_TILE, "empty");
      drawHunger(3*UI_ICON_TILE, "full");
      drawHunger(4*UI_ICON_TILE, "half");
      drawHunger(5*UI_ICON_TILE, "empty");
      drawArmor(6*UI_ICON_TILE, "full");
      drawArmor(7*UI_ICON_TILE, "half");
      drawArmor(8*UI_ICON_TILE, "empty");

      const url = c.toDataURL("image/png");
      return { url, cols };
    }

    const uiSprite = makeUiSprite();
    statusHudEl.style.setProperty("--uiSprite", `url(${uiSprite.url})`);

    statusHudEl.innerHTML = `
      <div class="statusSide">
        <div class="statusRow" id="armorRow"></div>
        <div class="statusRow" id="healthRow"></div>
      </div>
      <div class="statusSide">
        <div class="statusRow" id="hungerRow"></div>
      </div>
    `;
    const armorRowEl = statusHudEl.querySelector("#armorRow");
    const healthRowEl = statusHudEl.querySelector("#healthRow");
    const hungerRowEl = statusHudEl.querySelector("#hungerRow");

    function makeIcon(tileIndex) {
      const s = document.createElement("span");
      s.className = "uiIcon";
      s.style.backgroundSize = `${uiSprite.cols * UI_ICON_PX}px ${UI_ICON_PX}px`;
      s.style.backgroundPosition = `-${tileIndex * UI_ICON_PX}px 0px`;
      return s;
    }

    const uiIcons = {
      heartFull: 0,
      heartHalf: 1,
      heartEmpty: 2,
      hungerFull: 3,
      hungerHalf: 4,
      hungerEmpty: 5,
      armorFull: 6,
      armorHalf: 7,
      armorEmpty: 8,
    };

    const armorIcons = [], healthIcons = [], hungerIcons = [];
    for (let i=0;i<10;i++) {
      const a = makeIcon(uiIcons.armorEmpty); armorRowEl.appendChild(a); armorIcons.push(a);
      const h = makeIcon(uiIcons.heartFull);  healthRowEl.appendChild(h); healthIcons.push(h);
      const u = makeIcon(uiIcons.hungerFull); hungerRowEl.appendChild(u); hungerIcons.push(u);
    }

    // ======================================================
    // Three.js
    // ======================================================
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.domElement.tabIndex = 0;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87b7ff);
    scene.fog = new THREE.FogExp2(0x87b7ff, 0.008);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.05, 900);
    camera.rotation.order = "YXZ";

    scene.add(new THREE.HemisphereLight(0xbad6ff, 0x3a3a3a, 0.85));
    const sun = new THREE.DirectionalLight(0xffffff, 0.85);
    sun.position.set(80, 140, 40);
    scene.add(sun);

    // ======================================================
    // Texture atlas (procedural, embedded)
    // ======================================================
    const TILE = 16;
    const ATLAS_COLS = 8;
    const ATLAS_ROWS = 8;


    const ICON_PX = 28; // UI icon size; keeps tiles aligned/pixel-perfect
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    function rgb(r,g,b){ return `rgb(${r|0},${g|0},${b|0})`; }

    // deterministic hash for pixels / tiles
    function hash32(n){
      n = (n ^ (n >>> 16)) >>> 0;
      n = Math.imul(n, 0x7feb352d) >>> 0;
      n = (n ^ (n >>> 15)) >>> 0;
      n = Math.imul(n, 0x846ca68b) >>> 0;
      n = (n ^ (n >>> 16)) >>> 0;
      return n >>> 0;
    }
    function rnd01(seed){
      return (hash32(seed) & 0xFFFFFF) / 0xFFFFFF;
    }

    function drawNoiseTile(ctx, tx, ty, baseRGB, speckRGB, speckRate, shadeRate, seedBase) {
      const ox = tx * TILE, oy = ty * TILE;
      for (let y=0; y<TILE; y++) for (let x=0; x<TILE; x++) {
        const s = seedBase + x*131 + y*977;
        const r = rnd01(s);
        const sh = (rnd01(s ^ 0x9e3779b9) - 0.5) * shadeRate;
        let rr = baseRGB[0] + sh, gg = baseRGB[1] + sh, bb = baseRGB[2] + sh;
        if (r < speckRate) {
          const k = rnd01(s ^ 0xBADC0DE) * 0.6 + 0.4;
          rr = lerp(rr, speckRGB[0], k);
          gg = lerp(gg, speckRGB[1], k);
          bb = lerp(bb, speckRGB[2], k);
        }
        rr = Math.max(0, Math.min(255, rr));
        gg = Math.max(0, Math.min(255, gg));
        bb = Math.max(0, Math.min(255, bb));
        ctx.fillStyle = rgb(rr,gg,bb);
        ctx.fillRect(ox + x, oy + y, 1, 1);
      }
    }

    function drawPlanks(ctx, tx, ty, seedBase){
      const ox = tx*TILE, oy = ty*TILE;
      // base
      drawNoiseTile(ctx, tx, ty, [196,154,90], [220,188,120], 0.08, 18, seedBase);
      // plank seams
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      for (let i=0; i<3; i++) {
        const yy = oy + 3 + i*5;
        ctx.fillRect(ox, yy, TILE, 1);
      }
      // subtle vertical grain
      for (let x=0; x<TILE; x+=3) {
        const a = 0.05 + rnd01(seedBase + x*19)*0.06;
        ctx.fillStyle = `rgba(70,40,15,${a})`;
        ctx.fillRect(ox+x, oy, 1, TILE);
      }
    }

    function drawCobble(ctx, tx, ty, seedBase){
      const ox = tx*TILE, oy = ty*TILE;
      // base noise
      drawNoiseTile(ctx, tx, ty, [135, 139, 148], [90,90,95], 0.12, 35, seedBase);
      // chunky stones
      for (let i=0; i<18; i++){
        const r = rnd01(seedBase + i*999);
        const x = (rnd01(seedBase + i*123) * (TILE-4))|0;
        const y = (rnd01(seedBase + i*321) * (TILE-4))|0;
        const w = 2 + ((r*3)|0);
        const h = 2 + (((1-r)*3)|0);
        const c = 90 + (r*70)|0;
        ctx.fillStyle = rgb(c,c,c);
        ctx.fillRect(ox+x, oy+y, w, h);
        ctx.fillStyle = "rgba(0,0,0,0.18)";
        ctx.fillRect(ox+x, oy+y+h-1, w, 1);
        ctx.fillRect(ox+x+w-1, oy+y, 1, h);
      }
    }


    function drawOre(ctx, tx, ty, seedBase, speckRGB, speckRate){
      // cobble base + colored specks
      drawCobble(ctx, tx, ty, seedBase);
      const ox = tx*TILE, oy = ty*TILE;
      for (let i=0; i<28; i++){
        const x = (rnd01(seedBase + i*911) * TILE) | 0;
        const y = (rnd01(seedBase + i*733) * TILE) | 0;
        if (rnd01(seedBase ^ (i*97)) > speckRate) continue;
        const k = 0.55 + rnd01(seedBase + i*199) * 0.45;
        const rr = Math.min(255, speckRGB[0] * k);
        const gg = Math.min(255, speckRGB[1] * k);
        const bb = Math.min(255, speckRGB[2] * k);
        ctx.fillStyle = rgb(rr,gg,bb);
        ctx.fillRect(ox + x, oy + y, 1, 1);
        // tiny shadow for depth
        ctx.fillStyle = "rgba(0,0,0,0.18)";
        ctx.fillRect(ox + x, oy + y + 1, 1, 1);
      }
    }

    function drawGrassTop(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [78, 168, 74], [40, 130, 40], 0.10, 22, seedBase);
      // little lighter flecks
      const ox = tx*TILE, oy = ty*TILE;
      for (let i=0;i<14;i++){
        const x = (rnd01(seedBase + i*41) * TILE)|0;
        const y = (rnd01(seedBase + i*57) * TILE)|0;
        ctx.fillStyle = "rgba(255,255,255,0.07)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawGrassSide(ctx, tx, ty, seedBase){
      // dirt base
      drawNoiseTile(ctx, tx, ty, [138, 90, 43], [120, 70, 28], 0.10, 26, seedBase);
      // green top band
      const ox = tx*TILE, oy = ty*TILE;
      for (let y=0; y<5; y++){
        const a = 0.85 - y*0.11;
        ctx.fillStyle = `rgba(80, 175, 76, ${a})`;
        ctx.fillRect(ox, oy+y, TILE, 1);
      }
      // green specks in band
      for (let i=0;i<18;i++){
        const x = (rnd01(seedBase + i*91) * TILE)|0;
        const y = (rnd01(seedBase + i*37) * 5)|0;
        ctx.fillStyle = "rgba(30,90,30,0.35)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawLogSide(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [164, 116, 60], [120, 80, 35], 0.10, 20, seedBase);
      const ox = tx*TILE, oy = ty*TILE;
      // vertical stripes
      for (let x=0; x<TILE; x++){
        const a = 0.05 + rnd01(seedBase + x*17)*0.10;
        ctx.fillStyle = `rgba(70,40,15,${a})`;
        ctx.fillRect(ox+x, oy, 1, TILE);
      }
    }

    function drawLogTop(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [175, 130, 75], [130, 90, 40], 0.08, 18, seedBase);
      // rings (cheap)
      for (let r=2; r<=7; r+=2){
        const a = 0.20 - r*0.015;
        ctx.strokeStyle = `rgba(80,45,20,${a})`;
        ctx.beginPath();
        ctx.arc(ox+8, oy+8, r + rnd01(seedBase+r*133)*0.35, 0, Math.PI*2);
        ctx.stroke();
      }
      // darker bark edge
      ctx.strokeStyle = "rgba(55,30,15,0.35)";
      ctx.strokeRect(ox+0.5, oy+0.5, TILE-1, TILE-1);
    }

    function drawBricks(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [178, 92, 77], [140, 60, 55], 0.08, 20, seedBase);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      for (let y=0; y<TILE; y+=4){
        ctx.fillRect(ox, oy+y, TILE, 1);
      }
      for (let row=0; row<4; row++){
        const y = oy + row*4;
        const offset = (row%2)*4;
        for (let x=offset; x<TILE; x+=8){
          ctx.fillRect(ox+x, y, 1, 4);
        }
      }
    }

    function drawObsidian(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [35, 25, 50], [80, 40, 120], 0.10, 10, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      for (let i=0;i<18;i++){
        const x=(rnd01(seedBase+i*31)*TILE)|0;
        const y=(rnd01(seedBase+i*67)*TILE)|0;
        ctx.fillStyle="rgba(150,90,220,0.10)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawSand(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [218, 203, 131], [240, 230, 170], 0.10, 16, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      for (let i=0;i<10;i++){
        const x=(rnd01(seedBase+i*19)*TILE)|0;
        const y=(rnd01(seedBase+i*23)*TILE)|0;
        ctx.fillStyle="rgba(120,100,40,0.10)";
        ctx.fillRect(ox+x, oy+y, 2, 1);
      }
    }

    function drawLeaves(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [55, 145, 65], [25, 90, 35], 0.14, 22, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      for (let i=0;i<24;i++){
        const x=(rnd01(seedBase+i*53)*TILE)|0;
        const y=(rnd01(seedBase+i*79)*TILE)|0;
        ctx.fillStyle="rgba(0,0,0,0.10)";
        ctx.fillRect(ox+x, oy+y, 1, 1);
      }
    }

    function drawGlass(ctx, tx, ty){
      // Cutout/dithered "see-through" glass:
      // - Most pixels are fully transparent (so you can see through)
      // - A sparse dither + border lines are opaque enough to read as glass
      // This avoids per-instance transparent sorting artifacts (no more x-ray glitches).
      const ox=tx*TILE, oy=ty*TILE;

      // clear tile (fully transparent)
      ctx.clearRect(ox, oy, TILE, TILE);

      // subtle dither dots
      for (let y=0; y<TILE; y++){
        for (let x=0; x<TILE; x++){
          // ordered-ish pattern + a bit of noise
          const k = ((x*3 + y*5) & 7);
          if (k === 0 || k === 5) {
            ctx.fillStyle="rgba(185,230,255,0.70)";
            ctx.fillRect(ox+x, oy+y, 1, 1);
          }
        }
      }

      // crisp border and highlights
      ctx.strokeStyle="rgba(255,255,255,0.95)";
      ctx.strokeRect(ox+0.5, oy+0.5, TILE-1, TILE-1);

      ctx.strokeStyle="rgba(255,255,255,0.75)";
      ctx.beginPath();
      ctx.moveTo(ox+3, oy+2); ctx.lineTo(ox+13, oy+12);
      ctx.moveTo(ox+2, oy+6); ctx.lineTo(ox+10, oy+14);
      ctx.stroke();
    }

    function drawMetal(ctx, tx, ty, base, seedBase){
      drawNoiseTile(ctx, tx, ty, base, [255,255,255], 0.06, 18, seedBase);
      const ox=tx*TILE, oy=ty*TILE;
      ctx.fillStyle="rgba(255,255,255,0.12)";
      ctx.fillRect(ox+2, oy+2, 5, 2);
      ctx.fillRect(ox+3, oy+4, 3, 1);
      ctx.fillStyle="rgba(0,0,0,0.18)";
      ctx.fillRect(ox+1, oy+13, 14, 1);
    }

    function drawTNT(ctx, tx, ty, variant){
      const ox=tx*TILE, oy=ty*TILE;
      if (variant === "top") {
        drawNoiseTile(ctx, tx, ty, [205, 82, 82], [255,255,255], 0.02, 10, 12345);
        ctx.fillStyle="rgba(0,0,0,0.35)";
        ctx.fillRect(ox, oy+5, TILE, 1);
        ctx.fillRect(ox, oy+10, TILE, 1);
      } else if (variant === "bottom") {
        drawNoiseTile(ctx, tx, ty, [150, 60, 60], [255,255,255], 0.01, 10, 54321);
        ctx.fillStyle="rgba(0,0,0,0.25)";
        ctx.fillRect(ox, oy+7, TILE, 1);
      } else {
        // side
        drawNoiseTile(ctx, tx, ty, [215, 88, 88], [255,255,255], 0.02, 10, 9999);
        ctx.fillStyle="rgba(255,255,255,0.55)";
        ctx.fillRect(ox, oy+5, TILE, 6);
        ctx.fillStyle="rgba(0,0,0,0.55)";
        ctx.fillRect(ox, oy+5, TILE, 1);
        ctx.fillRect(ox, oy+10, TILE, 1);
        // fake "TNT" letters (pixel-ish)
        ctx.fillStyle="rgba(0,0,0,0.65)";
        ctx.fillRect(ox+3, oy+7, 10, 2);
      }
    }

    function drawWool(ctx, tx, ty, base, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, base, [255,255,255], 0.06, 12, seedBase);
      // weave
      for (let y=0; y<TILE; y+=2){
        for (let x=(y%4===0?0:1); x<TILE; x+=2){
          ctx.fillStyle="rgba(0,0,0,0.06)";
          ctx.fillRect(ox+x, oy+y, 1, 1);
        }
      }
    }

    function drawWater(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [50, 120, 240], [90, 160, 255], 0.12, 14, seedBase);
      for (let y=0; y<TILE; y++){
        const a = 0.10 + (y/TILE)*0.12;
        ctx.fillStyle = `rgba(255,255,255,${a})`;
        ctx.fillRect(ox, oy+y, TILE, 1);
      }
    }

    function drawLava(ctx, tx, ty, seedBase){
      const ox=tx*TILE, oy=ty*TILE;
      drawNoiseTile(ctx, tx, ty, [255, 120, 40], [255, 220, 120], 0.18, 18, seedBase);
      for (let i=0;i<18;i++){
        const x=(rnd01(seedBase+i*101)*TILE)|0;
        const y=(rnd01(seedBase+i*203)*TILE)|0;
        ctx.fillStyle="rgba(0,0,0,0.12)";
        ctx.fillRect(ox+x, oy+y, 2, 1);
      }
    }

    function drawBedrock(ctx, tx, ty, seedBase){
      drawNoiseTile(ctx, tx, ty, [55,55,55], [25,25,25], 0.22, 30, seedBase);
    }

    function drawCraftingTable(ctx, tx, ty, face, seedBase) {
      const ox = tx*TILE, oy = ty*TILE;
      // wood base
      drawPlanks(ctx, tx, ty, seedBase);
      // darker border
      ctx.fillStyle = "rgba(0,0,0,0.22)";
      ctx.fillRect(ox, oy, TILE, 1);
      ctx.fillRect(ox, oy+TILE-1, TILE, 1);
      ctx.fillRect(ox, oy, 1, TILE);
      ctx.fillRect(ox+TILE-1, oy, 1, TILE);

      if (face === "top") {
        // 3x3 crafting grid (pixel-ish)
        ctx.fillStyle = "rgba(0,0,0,0.28)";
        for (let i=0;i<4;i++){
          const x = ox + 3 + i*3;
          ctx.fillRect(x, oy+3, 1, 10);
        }
        for (let i=0;i<4;i++){
          const y = oy + 3 + i*3;
          ctx.fillRect(ox+3, y, 10, 1);
        }
        // corner metal dots
        ctx.fillStyle = "rgba(210,210,220,0.70)";
        ctx.fillRect(ox+2, oy+2, 1, 1);
        ctx.fillRect(ox+13, oy+2, 1, 1);
        ctx.fillRect(ox+2, oy+13, 1, 1);
        ctx.fillRect(ox+13, oy+13, 1, 1);
      } else if (face === "front") {
        // little "tools" motif
        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.fillRect(ox+3, oy+4, 10, 1);
        ctx.fillRect(ox+3, oy+9, 10, 1);
        ctx.fillStyle = "rgba(255,255,255,0.10)";
        ctx.fillRect(ox+4, oy+5, 8, 3);
      } else {
        // side: subtle vertical bands
        ctx.fillStyle = "rgba(0,0,0,0.10)";
        for (let x=2; x<TILE; x+=4) ctx.fillRect(ox+x, oy+2, 1, TILE-4);
      }
    }

    function drawFurnace(ctx, tx, ty, face, seedBase) {
      const ox = tx*TILE, oy = ty*TILE;
      drawCobble(ctx, tx, ty, seedBase);
      // top dark rim
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(ox, oy, TILE, 2);

      if (face === "front") {
        // mouth opening
        ctx.fillStyle = "rgba(0,0,0,0.65)";
        ctx.fillRect(ox+4, oy+5, 8, 6);
        // inner glow (subtle)
        ctx.fillStyle = "rgba(255,140,40,0.10)";
        ctx.fillRect(ox+5, oy+6, 6, 4);
        // knobs
        ctx.fillStyle = "rgba(210,210,220,0.45)";
        ctx.fillRect(ox+3, oy+3, 2, 2);
        ctx.fillRect(ox+11, oy+3, 2, 2);
      } else if (face === "top") {
        // grate-ish
        ctx.fillStyle = "rgba(0,0,0,0.18)";
        for (let x=3; x<=12; x+=3) ctx.fillRect(ox+x, oy+4, 1, 9);
      } else {
        // side: a couple seams
        ctx.fillStyle = "rgba(0,0,0,0.14)";
        ctx.fillRect(ox+5, oy+3, 1, 10);
        ctx.fillRect(ox+10, oy+3, 1, 10);
      }
    }

    function drawTool(ctx, tx, ty, kind, matRGB, seedBase) {
      const ox = tx*TILE, oy = ty*TILE;
      ctx.clearRect(ox, oy, TILE, TILE);
      ctx.imageSmoothingEnabled = false;

      const M = `rgba(${matRGB[0]},${matRGB[1]},${matRGB[2]},0.98)`;
      const S = "rgba(0,0,0,0.35)";
      const W = "rgba(210,170,120,0.98)"; // handle

      function px(x,y,col){ ctx.fillStyle = col; ctx.fillRect(ox+x, oy+y, 1, 1); }

      // faint outline drop
      for (let y=0;y<TILE;y++) for (let x=0;x<TILE;x++){
        if (rnd01(seedBase + x*17 + y*31) < 0.02) px(x,y,"rgba(255,255,255,0.06)");
      }

      if (kind === "sword") {
        // blade
        for (let y=1;y<=10;y++) { px(8,y,M); px(9,y,M); }
        for (let y=2;y<=10;y++) px(7,y,M);
        // tip
        px(8,0,M); px(9,0,M);
        // guard
        for (let x=6;x<=10;x++) px(x,11,M);
        // handle
        for (let y=12;y<=15;y++) { px(8,y,W); px(9,y,W); }
        // shade
        for (let y=1;y<=10;y++) px(10,y,S);
      } else if (kind === "pickaxe") {
        // handle diagonal
        for (let i=0;i<10;i++) px(5+i,15-i,W);
        // head
        for (let x=2;x<=12;x++) px(x,4,M);
        px(3,5,M); px(11,5,M);
        // shade
        for (let x=2;x<=12;x++) px(x,3,S);
      } else if (kind === "axe") {
        // handle
        for (let y=4;y<=15;y++) { px(9,y,W); px(10,y,W); }
        // head
        for (let y=4;y<=8;y++) { px(6,y,M); px(7,y,M); px(8,y,M); }
        for (let y=5;y<=7;y++) px(5,y,M);
        // shade edge
        for (let y=4;y<=8;y++) px(8,y,S);
      } else if (kind === "shovel") {
        // handle
        for (let y=2;y<=11;y++) { px(9,y,W); px(10,y,W); }
        // spade
        for (let y=11;y<=14;y++) { px(7,y,M); px(8,y,M); px(9,y,M); px(10,y,M); }
        px(8,15,M); px(9,15,M);
        // shade
        for (let y=11;y<=15;y++) px(10,y,S);
      } else if (kind === "hoe") {
        // handle
        for (let y=4;y<=15;y++) { px(9,y,W); px(10,y,W); }
        // hook
        for (let x=4;x<=10;x++) px(x,4,M);
        for (let x=4;x<=7;x++) px(x,5,M);
        // shade
        for (let x=4;x<=10;x++) px(x,3,S);
      }
    }


    // tile registry
    const T = {};
    function setTile(name, idx){ T[name]=idx; }

    function tileXY(idx){ return { tx: idx % ATLAS_COLS, ty: Math.floor(idx / ATLAS_COLS) }; }

    function generateAtlasProcedural() {
      const c = document.createElement("canvas");
      c.width = ATLAS_COLS * TILE;
      c.height = ATLAS_ROWS * TILE;
      const ctx = c.getContext("2d", { alpha: true });

      // assign indices
      let i=0;
            const names = [
        "grass_top",
        "grass_side",
        "dirt",
        "cobble",
        "log_side",
        "log_top",
        "planks",
        "leaves",
        "sand",
        "glass",
        "bricks",
        "obsidian",
        "gold",
        "diamond",
        "tnt_side",
        "tnt_top",
        "tnt_bottom",
        "wool_white",
        "wool_red",
        "wool_blue",
        "wool_green",
        "water",
        "lava",
        "bedrock",
        "coal_ore",
        "iron_ore",
        "gold_ore",
        "diamond_ore",
        "crafting_table_top",
        "crafting_table_side",
        "crafting_table_front",
        "furnace_top",
        "furnace_side",
        "furnace_front",
        "wooden_sword",
        "wooden_pickaxe",
        "wooden_axe",
        "wooden_shovel",
        "wooden_hoe",
        "stone_sword",
        "stone_pickaxe",
        "stone_axe",
        "stone_shovel",
        "stone_hoe",
        "iron_sword",
        "iron_pickaxe",
        "iron_axe",
        "iron_shovel",
        "iron_hoe",
        "diamond_sword",
        "diamond_pickaxe",
        "diamond_axe",
        "diamond_shovel",
        "diamond_hoe"
      ];
      for (const n of names) setTile(n, i++);

      // draw tiles
      {
        const a = tileXY(T.grass_top);  drawGrassTop(ctx, a.tx, a.ty, 101);
        const b = tileXY(T.grass_side); drawGrassSide(ctx, b.tx, b.ty, 202);
        const c2 = tileXY(T.dirt);      drawNoiseTile(ctx, c2.tx, c2.ty, [138, 90, 43], [120, 70, 28], 0.10, 26, 303);
        const d = tileXY(T.cobble);     drawCobble(ctx, d.tx, d.ty, 404);
        const e = tileXY(T.log_side);   drawLogSide(ctx, e.tx, e.ty, 505);
        const f = tileXY(T.log_top);    drawLogTop(ctx, f.tx, f.ty, 606);
        const g = tileXY(T.planks);     drawPlanks(ctx, g.tx, g.ty, 707);
        const h = tileXY(T.leaves);     drawLeaves(ctx, h.tx, h.ty, 808);
        const s = tileXY(T.sand);       drawSand(ctx, s.tx, s.ty, 909);
        const gl = tileXY(T.glass);     drawGlass(ctx, gl.tx, gl.ty);
        const br = tileXY(T.bricks);    drawBricks(ctx, br.tx, br.ty, 1111);
        const ob = tileXY(T.obsidian);  drawObsidian(ctx, ob.tx, ob.ty, 1212);
        const go = tileXY(T.gold);      drawMetal(ctx, go.tx, go.ty, [240, 205, 75], 1313);
        const di = tileXY(T.diamond);   drawMetal(ctx, di.tx, di.ty, [90, 230, 210], 1414);

        const ts = tileXY(T.tnt_side);  drawTNT(ctx, ts.tx, ts.ty, "side");
        const tt = tileXY(T.tnt_top);   drawTNT(ctx, tt.tx, tt.ty, "top");
        const tb = tileXY(T.tnt_bottom);drawTNT(ctx, tb.tx, tb.ty, "bottom");

        const ww = tileXY(T.wool_white);drawWool(ctx, ww.tx, ww.ty, [240,240,240], 1515);
        const wr = tileXY(T.wool_red);  drawWool(ctx, wr.tx, wr.ty, [210,75,75], 1616);
        const wb = tileXY(T.wool_blue); drawWool(ctx, wb.tx, wb.ty, [70,110,220], 1717);
        const wg = tileXY(T.wool_green);drawWool(ctx, wg.tx, wg.ty, [60,175,90], 1818);

        const wa = tileXY(T.water);     drawWater(ctx, wa.tx, wa.ty, 1919);
        const la = tileXY(T.lava);      drawLava(ctx, la.tx, la.ty, 2020);
        const be = tileXY(T.bedrock);   drawBedrock(ctx, be.tx, be.ty, 2121);

        const co = tileXY(T.coal_ore);    drawOre(ctx, co.tx, co.ty, 2301, [40,40,40], 0.32);
        const io = tileXY(T.iron_ore);    drawOre(ctx, io.tx, io.ty, 2401, [210,150,110], 0.28);
        const go2 = tileXY(T.gold_ore);   drawOre(ctx, go2.tx, go2.ty, 2501, [245,205,75], 0.24);
        const do2 = tileXY(T.diamond_ore);drawOre(ctx, do2.tx, do2.ty, 2601, [90,230,210], 0.20);

        // Functional blocks
        const ctT = tileXY(T.crafting_table_top);   drawCraftingTable(ctx, ctT.tx, ctT.ty, "top", 3101);
        const ctS = tileXY(T.crafting_table_side);  drawCraftingTable(ctx, ctS.tx, ctS.ty, "side", 3102);
        const ctF = tileXY(T.crafting_table_front); drawCraftingTable(ctx, ctF.tx, ctF.ty, "front", 3103);

        const fuT = tileXY(T.furnace_top);   drawFurnace(ctx, fuT.tx, fuT.ty, "top", 3201);
        const fuS = tileXY(T.furnace_side);  drawFurnace(ctx, fuS.tx, fuS.ty, "side", 3202);
        const fuF = tileXY(T.furnace_front); drawFurnace(ctx, fuF.tx, fuF.ty, "front", 3203);

        // Tool placeholders (icons only)
        const colWood = [156, 102, 56];
        const colStone = [150, 150, 150];
        const colIron = [205, 205, 215];
        const colDia = [70, 225, 210];

        const wSword = tileXY(T.wooden_sword);    drawTool(ctx, wSword.tx, wSword.ty, "sword", colWood, 3301);
        const wPick = tileXY(T.wooden_pickaxe);  drawTool(ctx, wPick.tx, wPick.ty, "pickaxe", colWood, 3302);
        const wAxe = tileXY(T.wooden_axe);      drawTool(ctx, wAxe.tx, wAxe.ty, "axe", colWood, 3303);
        const wShovel = tileXY(T.wooden_shovel);   drawTool(ctx, wShovel.tx, wShovel.ty, "shovel", colWood, 3304);
        const wHoe = tileXY(T.wooden_hoe);      drawTool(ctx, wHoe.tx, wHoe.ty, "hoe", colWood, 3305);

        const sSword = tileXY(T.stone_sword);     drawTool(ctx, sSword.tx, sSword.ty, "sword", colStone, 3311);
        const sPick = tileXY(T.stone_pickaxe);   drawTool(ctx, sPick.tx, sPick.ty, "pickaxe", colStone, 3312);
        const sAxe = tileXY(T.stone_axe);       drawTool(ctx, sAxe.tx, sAxe.ty, "axe", colStone, 3313);
        const sShovel = tileXY(T.stone_shovel);    drawTool(ctx, sShovel.tx, sShovel.ty, "shovel", colStone, 3314);
        const sHoe = tileXY(T.stone_hoe);       drawTool(ctx, sHoe.tx, sHoe.ty, "hoe", colStone, 3315);

        const iSword = tileXY(T.iron_sword);      drawTool(ctx, iSword.tx, iSword.ty, "sword", colIron, 3321);
        const iPick = tileXY(T.iron_pickaxe);    drawTool(ctx, iPick.tx, iPick.ty, "pickaxe", colIron, 3322);
        const iAxe = tileXY(T.iron_axe);        drawTool(ctx, iAxe.tx, iAxe.ty, "axe", colIron, 3323);
        const iShovel = tileXY(T.iron_shovel);     drawTool(ctx, iShovel.tx, iShovel.ty, "shovel", colIron, 3324);
        const iHoe = tileXY(T.iron_hoe);        drawTool(ctx, iHoe.tx, iHoe.ty, "hoe", colIron, 3325);

        const dSword = tileXY(T.diamond_sword);   drawTool(ctx, dSword.tx, dSword.ty, "sword", colDia, 3331);
        const dPick = tileXY(T.diamond_pickaxe); drawTool(ctx, dPick.tx, dPick.ty, "pickaxe", colDia, 3332);
        const dAxe = tileXY(T.diamond_axe);     drawTool(ctx, dAxe.tx, dAxe.ty, "axe", colDia, 3333);
        const dShovel = tileXY(T.diamond_shovel);  drawTool(ctx, dShovel.tx, dShovel.ty, "shovel", colDia, 3334);
        const dHoe = tileXY(T.diamond_hoe);     drawTool(ctx, dHoe.tx, dHoe.ty, "hoe", colDia, 3335);

      }

      // small atlas padding: crisp borders (optional)
      // no-op; we rely on nearest filtering + exact UVs.

      return c;
    }

    const atlasCanvas = generateAtlasProcedural();
    let atlasURL = atlasCanvas.toDataURL("image/png");

    // Create Three.js texture
    const atlasTex = new THREE.CanvasTexture(atlasCanvas);
    atlasTex.colorSpace = THREE.SRGBColorSpace;
    atlasTex.magFilter = THREE.NearestFilter;
    atlasTex.minFilter = THREE.NearestFilter;
    atlasTex.generateMipmaps = false;
    // ======================================================
    // Texture pack client (online zips)
    // - Default: curated 1.21+ Minecraft assets pack
    // - Kenney "Voxel Pack" (CC0) remains a low-bandwidth fallback
    // - Also supports Minecraft resource packs (expects assets/minecraft/textures/**)
    // ======================================================
    const CURATED_TEXPACK_URL = "https://github.com/PrismarineJS/minecraft-assets/archive/refs/heads/master.zip";
    const KENNEY_TEXPACK_URL = "https://www.kenney.nl/media/pages/assets/voxel-pack/ee6f21f078-1677662501/kenney_voxel-pack.zip";
    const DEFAULT_TEXPACK_URL = CURATED_TEXPACK_URL;
    let texturePackURL = localStorage.getItem("minicraft_texpack_url") || DEFAULT_TEXPACK_URL;
    let lastMissingTextures = [];

    function _blobToBitmap(blob) {
      if (typeof createImageBitmap === "function") return createImageBitmap(blob);
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = URL.createObjectURL(blob);
      });
    }

    function _drawImageIntoTile(ctx, img, sx, sy, sw, sh, tileIdx) {
      const tx = tileIdx % ATLAS_COLS;
      const ty = Math.floor(tileIdx / ATLAS_COLS);
      const dx = tx * TILE, dy = ty * TILE;
      ctx.clearRect(dx, dy, TILE, TILE);
      ctx.drawImage(img, sx, sy, sw, sh, dx, dy, TILE, TILE);
    }

    function _drawImageOverTile(ctx, img, sx, sy, sw, sh, tileIdx) {
      const tx = tileIdx % ATLAS_COLS;
      const ty = Math.floor(tileIdx / ATLAS_COLS);
      const dx = tx * TILE, dy = ty * TILE;
      ctx.drawImage(img, sx, sy, sw, sh, dx, dy, TILE, TILE);
    }

    function _copyAtlasTileIntoTile(ctx, sourceTileIdx, destTileIdx) {
      const srcX = (sourceTileIdx % ATLAS_COLS) * TILE;
      const srcY = Math.floor(sourceTileIdx / ATLAS_COLS) * TILE;
      const tx = destTileIdx % ATLAS_COLS;
      const ty = Math.floor(destTileIdx / ATLAS_COLS);
      const dx = tx * TILE, dy = ty * TILE;
      const tmp = document.createElement("canvas");
      tmp.width = TILE;
      tmp.height = TILE;
      const tmpCtx = tmp.getContext("2d");
      tmpCtx.drawImage(atlasCanvas, srcX, srcY, TILE, TILE, 0, 0, TILE, TILE);
      ctx.clearRect(dx, dy, TILE, TILE);
      ctx.drawImage(tmp, 0, 0, TILE, TILE, dx, dy, TILE, TILE);
    }

    function _isMostlyTransparentBitmap(img) {
      const size = Math.min(img.width || 16, img.height || 16);
      const sample = document.createElement("canvas");
      sample.width = size;
      sample.height = size;
      const sctx = sample.getContext("2d", { willReadFrequently: true });
      sctx.clearRect(0, 0, size, size);
      sctx.drawImage(img, 0, 0, size, size);
      const data = sctx.getImageData(0, 0, size, size).data;
      const total = size * size;
      let opaque = 0;
      for (let i = 3; i < data.length; i += 4) {
        if (data[i] > 16) opaque++;
      }
      return (opaque / total) < 0.5;
    }

    function _setMissingTextures(missing, sourceLabel) {
      lastMissingTextures = missing.slice().sort();
      if (missing.length) {
        console.warn(`[texpack] Missing textures (${sourceLabel}):`, missing);
      }
      try {
        const missingEl = document.getElementById("texPackMissing");
        if (!missingEl) return;
        if (!missing.length) {
          missingEl.style.display = "none";
          missingEl.textContent = "";
          return;
        }
        missingEl.style.display = "block";
        missingEl.textContent = `Missing textures (${sourceLabel}): ${missing.join(", ")}`;
      } catch (_) {}
    }

    function _resetAtlasToProcedural() {
      const fresh = generateAtlasProcedural();
      const ctx = atlasCanvas.getContext("2d", { alpha: true });
      ctx.clearRect(0, 0, atlasCanvas.width, atlasCanvas.height);
      ctx.drawImage(fresh, 0, 0);
      atlasTex.needsUpdate = true;
      atlasURL = atlasCanvas.toDataURL("image/png");
    }

    async function _applyKenneyVoxelPack(zip) {
      const pngFile = zip.file("Spritesheets/spritesheet_tiles.png");
      const xmlFile = zip.file("Spritesheets/spritesheet_tiles.xml");
      if (!pngFile || !xmlFile) throw new Error("Kenney pack: missing tiles spritesheet");

      const [pngBlob, xmlText] = await Promise.all([
        pngFile.async("blob"),
        xmlFile.async("string"),
      ]);

      const img = await _blobToBitmap(pngBlob);

      const doc = new DOMParser().parseFromString(xmlText, "application/xml");
      const map = Object.create(null);
      for (const st of Array.from(doc.getElementsByTagName("SubTexture"))) {
        const name = st.getAttribute("name");
        map[name] = {
          x: +st.getAttribute("x"),
          y: +st.getAttribute("y"),
          w: +st.getAttribute("width"),
          h: +st.getAttribute("height"),
        };
      }

      const ctx = atlasCanvas.getContext("2d", { alpha: true });

      const k = {
        grass_top: "grass_top.png",
        grass_side: "dirt_grass.png",
        dirt: "dirt.png",
        cobble: "greystone.png",
        log_side: "wood.png",
        log_top: "wood.png",
        planks: "wood_red.png",
        leaves: "leaves_transparent.png",
        sand: "sand.png",
        glass: "glass.png",
        bricks: "brick_red.png",
        obsidian: "stone_coal_alt.png",
        wool_white: "cotton_tan.png",
        wool_red: "cotton_red.png",
        wool_blue: "cotton_blue.png",
        wool_green: "cotton_green.png",
        water: "water.png",
        lava: "lava.png",
        bedrock: "greystone.png",
        coal_ore: "stone_coal.png",
        iron_ore: "stone_iron.png",
        gold_ore: "stone_gold.png",
        diamond_ore: "stone_diamond.png",

        crafting_table_top: "wood_red.png",
        crafting_table_side: "wood_red.png",
        crafting_table_front: "wood_red.png",
        furnace_top: "greystone.png",
        furnace_side: "greystone.png",
        furnace_front: "greystone.png",
      };

      const missing = [];
      for (const [ourName, kenName] of Object.entries(k)) {
        if (T[ourName] == null) continue;
        const r = map[kenName];
        if (!r) {
          missing.push(ourName);
          continue;
        }
        _drawImageIntoTile(ctx, img, r.x, r.y, r.w, r.h, T[ourName]);
      }
      _setMissingTextures(missing, "Kenney");
    }

    async function _applyMinecraftResourcePack(zip) {
      // Works with modern (1.13+) and many older packs; tries several fallback paths.
      const ctx = atlasCanvas.getContext("2d", { alpha: true });
      const packRoots = (() => {
        const roots = new Set();
        for (const name of Object.keys(zip.files)) {
          const idx = name.indexOf("assets/minecraft/textures/");
          if (idx >= 0) roots.add(name.slice(0, idx));
        }
        if (!roots.size) roots.add("");
        return Array.from(roots);
      })();

      async function loadFirstWithPath(paths) {
        for (const p of paths) {
          for (const root of packRoots) {
            const f = zip.file(`${root}${p}`);
            if (!f) continue;
            try {
              const blob = await f.async("blob");
              const img = await _blobToBitmap(blob);
              return { img, path: p };
            } catch (_) {}
          }
        }
        return null;
      }

      async function loadFirst(paths) {
        const found = await loadFirstWithPath(paths);
        return found ? found.img : null;
      }

      const tex = {
        grass_top: [
          "assets/minecraft/textures/block/grass_block_top.png",
          "assets/minecraft/textures/blocks/grass_top.png",
          "assets/minecraft/textures/blocks/grass.png",
        ],
        grass_side:[
          "assets/minecraft/textures/block/grass_block_side.png",
          "assets/minecraft/textures/block/grass_block_side_overlay.png",
          "assets/minecraft/textures/blocks/grass_side.png",
        ],
        dirt:      [
          "assets/minecraft/textures/block/dirt.png",
          "assets/minecraft/textures/blocks/dirt.png",
        ],
        cobble:    [
          "assets/minecraft/textures/block/cobblestone.png",
          "assets/minecraft/textures/block/cobble.png",
          "assets/minecraft/textures/blocks/cobblestone.png",
        ],
        log_side:  [
          "assets/minecraft/textures/block/oak_log.png",
          "assets/minecraft/textures/block/oak_log_side.png",
          "assets/minecraft/textures/blocks/log_oak.png",
          "assets/minecraft/textures/blocks/log.png",
        ],
        log_top:   [
          "assets/minecraft/textures/block/oak_log_top.png",
          "assets/minecraft/textures/blocks/log_oak_top.png",
          "assets/minecraft/textures/blocks/log_top.png",
        ],
        planks:    [
          "assets/minecraft/textures/block/oak_planks.png",
          "assets/minecraft/textures/block/planks_oak.png",
          "assets/minecraft/textures/blocks/planks_oak.png",
          "assets/minecraft/textures/blocks/planks.png",
        ],
        leaves:    [
          "assets/minecraft/textures/block/oak_leaves.png",
          "assets/minecraft/textures/block/oak_leaves_opaque.png",
          "assets/minecraft/textures/blocks/leaves_oak.png",
          "assets/minecraft/textures/blocks/leaves.png",
        ],
        sand:      [
          "assets/minecraft/textures/block/sand.png",
          "assets/minecraft/textures/blocks/sand.png",
        ],
        glass:     [
          "assets/minecraft/textures/block/glass.png",
          "assets/minecraft/textures/block/glass_clear.png",
          "assets/minecraft/textures/blocks/glass.png",
        ],
        bricks:    [
          "assets/minecraft/textures/block/bricks.png",
          "assets/minecraft/textures/block/brick.png",
          "assets/minecraft/textures/blocks/brick.png",
        ],
        obsidian:  [
          "assets/minecraft/textures/block/obsidian.png",
          "assets/minecraft/textures/blocks/obsidian.png",
        ],
        gold:      [
          "assets/minecraft/textures/block/gold_block.png",
          "assets/minecraft/textures/block/block_of_gold.png",
          "assets/minecraft/textures/blocks/gold_block.png",
        ],
        diamond:   [
          "assets/minecraft/textures/block/diamond_block.png",
          "assets/minecraft/textures/block/block_of_diamond.png",
          "assets/minecraft/textures/blocks/diamond_block.png",
        ],
        tnt_side:  [
          "assets/minecraft/textures/block/tnt_side.png",
          "assets/minecraft/textures/blocks/tnt_side.png",
        ],
        tnt_top:   [
          "assets/minecraft/textures/block/tnt_top.png",
          "assets/minecraft/textures/blocks/tnt_top.png",
        ],
        tnt_bottom:[
          "assets/minecraft/textures/block/tnt_bottom.png",
          "assets/minecraft/textures/blocks/tnt_bottom.png",
        ],
        wool_white:[
          "assets/minecraft/textures/block/white_wool.png",
          "assets/minecraft/textures/block/wool_white.png",
          "assets/minecraft/textures/blocks/wool_colored_white.png",
        ],
        wool_red:  [
          "assets/minecraft/textures/block/red_wool.png",
          "assets/minecraft/textures/block/wool_red.png",
          "assets/minecraft/textures/blocks/wool_colored_red.png",
        ],
        wool_blue: [
          "assets/minecraft/textures/block/blue_wool.png",
          "assets/minecraft/textures/block/wool_blue.png",
          "assets/minecraft/textures/blocks/wool_colored_blue.png",
        ],
        wool_green:[
          "assets/minecraft/textures/block/green_wool.png",
          "assets/minecraft/textures/block/wool_green.png",
          "assets/minecraft/textures/blocks/wool_colored_green.png",
        ],
        water:     [
          "assets/minecraft/textures/block/water_still.png",
          "assets/minecraft/textures/block/water_flow.png",
          "assets/minecraft/textures/blocks/water_still.png",
          "assets/minecraft/textures/block/water.png",
          "assets/minecraft/textures/blocks/water.png",
        ],
        lava:      [
          "assets/minecraft/textures/block/lava_still.png",
          "assets/minecraft/textures/block/lava_flow.png",
          "assets/minecraft/textures/blocks/lava_still.png",
          "assets/minecraft/textures/block/lava.png",
          "assets/minecraft/textures/blocks/lava.png",
        ],
        bedrock:   [
          "assets/minecraft/textures/block/bedrock.png",
          "assets/minecraft/textures/blocks/bedrock.png",
        ],
        coal_ore:  [
          "assets/minecraft/textures/block/coal_ore.png",
          "assets/minecraft/textures/block/deepslate_coal_ore.png",
          "assets/minecraft/textures/blocks/coal_ore.png",
        ],
        iron_ore:  [
          "assets/minecraft/textures/block/iron_ore.png",
          "assets/minecraft/textures/block/deepslate_iron_ore.png",
          "assets/minecraft/textures/blocks/iron_ore.png",
        ],
        gold_ore:  [
          "assets/minecraft/textures/block/gold_ore.png",
          "assets/minecraft/textures/block/deepslate_gold_ore.png",
          "assets/minecraft/textures/blocks/gold_ore.png",
        ],
        diamond_ore:[
          "assets/minecraft/textures/block/diamond_ore.png",
          "assets/minecraft/textures/block/deepslate_diamond_ore.png",
          "assets/minecraft/textures/blocks/diamond_ore.png",
        ],

        crafting_table_top: [
          "assets/minecraft/textures/block/crafting_table_top.png",
          "assets/minecraft/textures/blocks/crafting_table_top.png",
        ],
        crafting_table_side:[
          "assets/minecraft/textures/block/crafting_table_side.png",
          "assets/minecraft/textures/blocks/crafting_table_side.png",
        ],
        crafting_table_front:[
          "assets/minecraft/textures/block/crafting_table_front.png",
          "assets/minecraft/textures/blocks/crafting_table_front.png",
        ],
        furnace_top: [
          "assets/minecraft/textures/block/furnace_top.png",
          "assets/minecraft/textures/blocks/furnace_top.png",
        ],
        furnace_side:[
          "assets/minecraft/textures/block/furnace_side.png",
          "assets/minecraft/textures/blocks/furnace_side.png",
        ],
        furnace_front:[
          "assets/minecraft/textures/block/furnace_front.png",
          "assets/minecraft/textures/block/furnace_front_off.png",
          "assets/minecraft/textures/blocks/furnace_front.png",
        ],

        wooden_sword: [
          "assets/minecraft/textures/item/wooden_sword.png",
          "assets/minecraft/textures/item/wood_sword.png",
          "assets/minecraft/textures/items/wood_sword.png",
        ],
        wooden_pickaxe: [
          "assets/minecraft/textures/item/wooden_pickaxe.png",
          "assets/minecraft/textures/item/wood_pickaxe.png",
          "assets/minecraft/textures/items/wood_pickaxe.png",
        ],
        wooden_axe: [
          "assets/minecraft/textures/item/wooden_axe.png",
          "assets/minecraft/textures/item/wood_axe.png",
          "assets/minecraft/textures/items/wood_axe.png",
        ],
        wooden_shovel: [
          "assets/minecraft/textures/item/wooden_shovel.png",
          "assets/minecraft/textures/item/wood_shovel.png",
          "assets/minecraft/textures/items/wood_shovel.png",
        ],
        wooden_hoe: [
          "assets/minecraft/textures/item/wooden_hoe.png",
          "assets/minecraft/textures/item/wood_hoe.png",
          "assets/minecraft/textures/items/wood_hoe.png",
        ],

        stone_sword: [
          "assets/minecraft/textures/item/stone_sword.png",
          "assets/minecraft/textures/items/stone_sword.png",
        ],
        stone_pickaxe: [
          "assets/minecraft/textures/item/stone_pickaxe.png",
          "assets/minecraft/textures/items/stone_pickaxe.png",
        ],
        stone_axe: [
          "assets/minecraft/textures/item/stone_axe.png",
          "assets/minecraft/textures/items/stone_axe.png",
        ],
        stone_shovel: [
          "assets/minecraft/textures/item/stone_shovel.png",
          "assets/minecraft/textures/items/stone_shovel.png",
        ],
        stone_hoe: [
          "assets/minecraft/textures/item/stone_hoe.png",
          "assets/minecraft/textures/items/stone_hoe.png",
        ],

        iron_sword: [
          "assets/minecraft/textures/item/iron_sword.png",
          "assets/minecraft/textures/items/iron_sword.png",
        ],
        iron_pickaxe: [
          "assets/minecraft/textures/item/iron_pickaxe.png",
          "assets/minecraft/textures/items/iron_pickaxe.png",
        ],
        iron_axe: [
          "assets/minecraft/textures/item/iron_axe.png",
          "assets/minecraft/textures/items/iron_axe.png",
        ],
        iron_shovel: [
          "assets/minecraft/textures/item/iron_shovel.png",
          "assets/minecraft/textures/items/iron_shovel.png",
        ],
        iron_hoe: [
          "assets/minecraft/textures/item/iron_hoe.png",
          "assets/minecraft/textures/items/iron_hoe.png",
        ],

        diamond_sword: [
          "assets/minecraft/textures/item/diamond_sword.png",
          "assets/minecraft/textures/items/diamond_sword.png",
        ],
        diamond_pickaxe: [
          "assets/minecraft/textures/item/diamond_pickaxe.png",
          "assets/minecraft/textures/items/diamond_pickaxe.png",
        ],
        diamond_axe: [
          "assets/minecraft/textures/item/diamond_axe.png",
          "assets/minecraft/textures/items/diamond_axe.png",
        ],
        diamond_shovel: [
          "assets/minecraft/textures/item/diamond_shovel.png",
          "assets/minecraft/textures/items/diamond_shovel.png",
        ],
        diamond_hoe: [
          "assets/minecraft/textures/item/diamond_hoe.png",
          "assets/minecraft/textures/items/diamond_hoe.png",
        ],
      };

      const overlayConfig = {
        grass_side: {
          overlayHints: ["grass_block_side_overlay.png"],
          basePaths: [
            "assets/minecraft/textures/block/grass_block_side.png",
            "assets/minecraft/textures/blocks/grass_side.png",
          ],
          fallbackTile: "dirt",
        },
      };

      const missing = [];
      for (const [ourName, paths] of Object.entries(tex)) {
        if (T[ourName] == null) continue;
        const overlayEntry = overlayConfig[ourName];
        if (overlayEntry) {
          const found = await loadFirstWithPath(paths);
          if (!found) {
            missing.push(ourName);
            continue;
          }
          const { img, path } = found;
          const s = Math.min(img.width || 16, img.height || 16);
          const overlayHinted = overlayEntry.overlayHints.some((hint) => path.includes(hint));
          const treatAsOverlay = overlayHinted || _isMostlyTransparentBitmap(img);
          if (treatAsOverlay) {
            const baseImg = await loadFirst(overlayEntry.basePaths);
            const dirtImg = await loadFirst(tex.dirt);
            if (baseImg) {
              const baseSize = Math.min(baseImg.width || 16, baseImg.height || 16);
              _drawImageIntoTile(ctx, baseImg, 0, 0, baseSize, baseSize, T[ourName]);
            } else if (dirtImg) {
              const dirtSize = Math.min(dirtImg.width || 16, dirtImg.height || 16);
              _drawImageIntoTile(ctx, dirtImg, 0, 0, dirtSize, dirtSize, T[ourName]);
            } else if (T[overlayEntry.fallbackTile] != null) {
              _copyAtlasTileIntoTile(ctx, T[overlayEntry.fallbackTile], T[ourName]);
            }
            _drawImageOverTile(ctx, img, 0, 0, s, s, T[ourName]);
          } else {
            _drawImageIntoTile(ctx, img, 0, 0, s, s, T[ourName]);
          }
          continue;
        }

        const img = await loadFirst(paths);
        if (!img) {
          missing.push(ourName);
          continue;
        }

        // whole image -> tile
        const s = Math.min(img.width || 16, img.height || 16);
        _drawImageIntoTile(ctx, img, 0, 0, s, s, T[ourName]);
      }
      _setMissingTextures(missing, "Minecraft pack");
    }

    function _refreshAtlasUsersSoon() {
      let tries = 0;
      const tick = () => {
        tries++;
        try {
          if (typeof renderHotbarHud === "function") renderHotbarHud();
          if (typeof renderInvHotbar === "function") renderInvHotbar();
          if (typeof renderPaletteFromUI === "function") renderPaletteFromUI();
          if (typeof updateHeldModel === "function") updateHeldModel();
        } catch (_) {}

        // Some render fns are declared later; try for a short window.
        if ((typeof renderHotbarHud !== "function" || typeof renderInvHotbar !== "function") && tries < 40) {
          setTimeout(tick, 50);
        }
      };
      setTimeout(tick, 0);
    }

    async function applyTexturePackFromURL(url) {
      if (!url) return;
      if (!window.JSZip) {
        console.warn("[texpack] JSZip missing; cannot load texture packs.");
        return;
      }

      try {
        const r = await fetch(url, { mode: "cors" });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const buf = await r.arrayBuffer();
        const zip = await JSZip.loadAsync(buf);

        _resetAtlasToProcedural();

        // Prefer Kenney detection (fast + clean), else try Minecraft-style.
        if (zip.file("Spritesheets/spritesheet_tiles.png") && zip.file("Spritesheets/spritesheet_tiles.xml")) {
          await _applyKenneyVoxelPack(zip);
        } else {
          await _applyMinecraftResourcePack(zip);
        }

        atlasTex.needsUpdate = true;
        atlasURL = atlasCanvas.toDataURL("image/png");
        _refreshAtlasUsersSoon();
        console.log("[texpack] Applied texture pack:", url);
      } catch (e) {
        _setMissingTextures([], "none");
        console.warn("[texpack] Failed to load texture pack:", url, e);
      }
    }


    // Simple UI hook (Menu → Texture pack URL)
    try {
      const texPackInputEl = document.getElementById("texPackUrl");
      const texPackApplyEl = document.getElementById("texPackApply");
      const texPackPresetEl = document.getElementById("texPackPreset");
      const presets = [
        { label: "Minecraft 1.21+ (curated assets)", url: CURATED_TEXPACK_URL },
        { label: "Kenney Voxel (low bandwidth)", url: KENNEY_TEXPACK_URL },
        { label: "Custom URL…", url: "" },
      ];
      if (texPackPresetEl) {
        texPackPresetEl.innerHTML = "";
        for (const preset of presets) {
          const opt = document.createElement("option");
          opt.value = preset.url;
          opt.textContent = preset.label;
          texPackPresetEl.appendChild(opt);
        }
      }
      if (texPackInputEl) texPackInputEl.value = texturePackURL || "";
      if (texPackPresetEl) {
        const matched = presets.find((preset) => preset.url && preset.url === texturePackURL);
        texPackPresetEl.value = matched ? matched.url : "";
      }
      const applyFromUI = () => {
        const u = (texPackInputEl ? texPackInputEl.value : "").trim();
        if (!u) return;
        texturePackURL = u;
        try { localStorage.setItem("minicraft_texpack_url", u); } catch(_) {}
        applyTexturePackFromURL(u);
      };
      if (texPackApplyEl) texPackApplyEl.addEventListener("click", applyFromUI);
      if (texPackInputEl) texPackInputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") { e.preventDefault(); applyFromUI(); }
      });
      if (texPackPresetEl) texPackPresetEl.addEventListener("change", () => {
        const selected = texPackPresetEl.value;
        if (!selected) return;
        if (texPackInputEl) texPackInputEl.value = selected;
        applyFromUI();
      });
    } catch(_) {}

    // Kick off async load. Procedural atlas remains as a fallback if the pack fails.
    applyTexturePackFromURL(texturePackURL);


    // ======================================================
    // UV-mapped box geometries per block
    // ======================================================
    const atlasW = ATLAS_COLS * TILE;
    const atlasH = ATLAS_ROWS * TILE;

    function tileUVRect(tileIdx) {
      const tx = tileIdx % ATLAS_COLS;
      const ty = Math.floor(tileIdx / ATLAS_COLS);
      const u0 = (tx * TILE) / atlasW;
      const v0 = 1 - ((ty + 1) * TILE) / atlasH;
      const u1 = ((tx + 1) * TILE) / atlasW;
      const v1 = 1 - (ty * TILE) / atlasH;
      return {u0,v0,u1,v1};
    }

    function makeUVBox(tilesByFace) {
      // Face order for BoxGeometry: +x, -x, +y, -y, +z, -z (24 uvs, 4 per face)
      const g = new THREE.BoxGeometry(1,1,1);
      const uv = g.attributes.uv;
      const faces = [0,1,2,3,4,5];
      for (const f of faces) {
        const t = tilesByFace[f];
        const r = tileUVRect(t);
        const base = f * 4;
        // BoxGeometry uses 4 verts per face; assign in a consistent winding.
        // (u0,v1) (u1,v1) (u0,v0) (u1,v0) matches typical quad mapping.
        uv.setXY(base + 0, r.u0, r.v1);
        uv.setXY(base + 1, r.u1, r.v1);
        uv.setXY(base + 2, r.u0, r.v0);
        uv.setXY(base + 3, r.u1, r.v0);
      }
      uv.needsUpdate = true;
      return g;
    }

    // Per-block face tiles
    // faces: 0 +x, 1 -x, 2 +y(top), 3 -y(bottom), 4 +z, 5 -z
    function allFaces(tile) { return [tile,tile,tile,tile,tile,tile]; }

    const geomFor = new Map();
    const faceTilesFor = new Map();
    function defGeom(blockId, faceTiles) {
      faceTilesFor.set(blockId, faceTiles);
      geomFor.set(blockId, makeUVBox(faceTiles));
    }

// define tile sets
    defGeom(B.GRASS,  [T.grass_side, T.grass_side, T.grass_top, T.dirt,      T.grass_side, T.grass_side]);
    defGeom(B.DIRT,   allFaces(T.dirt));
    defGeom(B.COBBLE, allFaces(T.cobble));
    defGeom(B.LOG,    [T.log_side,   T.log_side,   T.log_top,   T.log_top,   T.log_side,   T.log_side]);
    defGeom(B.PLANKS, allFaces(T.planks));
    defGeom(B.LEAVES, allFaces(T.leaves));
    defGeom(B.SAND,   allFaces(T.sand));
    defGeom(B.GLASS,  allFaces(T.glass));
    defGeom(B.BRICKS, allFaces(T.bricks));
    defGeom(B.OBSIDIAN, allFaces(T.obsidian));
    defGeom(B.GOLD,   allFaces(T.gold));
    defGeom(B.DIAMOND,allFaces(T.diamond));
    defGeom(B.TNT,    [T.tnt_side,   T.tnt_side,   T.tnt_top,   T.tnt_bottom,T.tnt_side,   T.tnt_side]);
    defGeom(B.WOOL_WHITE, allFaces(T.wool_white));
    defGeom(B.WOOL_RED,   allFaces(T.wool_red));
    defGeom(B.WOOL_BLUE,  allFaces(T.wool_blue));
    defGeom(B.WOOL_GREEN, allFaces(T.wool_green));
    defGeom(B.WATER,  allFaces(T.water));
    defGeom(B.LAVA,   allFaces(T.lava));
    defGeom(B.BEDROCK,allFaces(T.bedrock));
    defGeom(B.COAL_ORE,   allFaces(T.coal_ore));
    defGeom(B.IRON_ORE,   allFaces(T.iron_ore));
    defGeom(B.GOLD_ORE,   allFaces(T.gold_ore));
    defGeom(B.DIAMOND_ORE,allFaces(T.diamond_ore));

    defGeom(B.CRAFTING_TABLE, [T.crafting_table_side, T.crafting_table_side, T.crafting_table_top, T.planks, T.crafting_table_front, T.crafting_table_side]);
    defGeom(B.FURNACE,        [T.furnace_side, T.furnace_side, T.furnace_top, T.cobble, T.furnace_front, T.furnace_side]);

    // Tools (placeholder icons only; not placeable yet)
    defGeom(B.WOODEN_SWORD,   allFaces(T.wooden_sword));
    defGeom(B.WOODEN_PICKAXE, allFaces(T.wooden_pickaxe));
    defGeom(B.WOODEN_AXE,     allFaces(T.wooden_axe));
    defGeom(B.WOODEN_SHOVEL,  allFaces(T.wooden_shovel));
    defGeom(B.WOODEN_HOE,     allFaces(T.wooden_hoe));

    defGeom(B.STONE_SWORD,    allFaces(T.stone_sword));
    defGeom(B.STONE_PICKAXE,  allFaces(T.stone_pickaxe));
    defGeom(B.STONE_AXE,      allFaces(T.stone_axe));
    defGeom(B.STONE_SHOVEL,   allFaces(T.stone_shovel));
    defGeom(B.STONE_HOE,      allFaces(T.stone_hoe));

    defGeom(B.IRON_SWORD,     allFaces(T.iron_sword));
    defGeom(B.IRON_PICKAXE,   allFaces(T.iron_pickaxe));
    defGeom(B.IRON_AXE,       allFaces(T.iron_axe));
    defGeom(B.IRON_SHOVEL,    allFaces(T.iron_shovel));
    defGeom(B.IRON_HOE,       allFaces(T.iron_hoe));

    defGeom(B.DIAMOND_SWORD,  allFaces(T.diamond_sword));
    defGeom(B.DIAMOND_PICKAXE,allFaces(T.diamond_pickaxe));
    defGeom(B.DIAMOND_AXE,    allFaces(T.diamond_axe));
    defGeom(B.DIAMOND_SHOVEL, allFaces(T.diamond_shovel));
    defGeom(B.DIAMOND_HOE,    allFaces(T.diamond_hoe));

    // shared materials
    const matOpaque = new THREE.MeshLambertMaterial({ map: atlasTex });
    const matGlass  = new THREE.MeshLambertMaterial({ map: atlasTex, alphaTest: 0.30, transparent: false, depthWrite: true, depthTest: true });
    const matWater  = new THREE.MeshLambertMaterial({ map: atlasTex, transparent: true, opacity: 0.65, depthWrite: true });
    const matLava   = new THREE.MeshLambertMaterial({ map: atlasTex, transparent: true, opacity: 0.85, depthWrite: true });

    function materialFor(id) {
      if (id === B.GLASS) return matGlass;
      if (id === B.WATER) return matWater;
      if (id === B.LAVA)  return matLava;
      return matOpaque;
    }

// ======================================================
// Player character (Steve) + camera perspectives (P)
// ======================================================
const CAM_MODE = { FIRST: 0, THIRD_BACK: 1, THIRD_FRONT: 2 };
let camMode = CAM_MODE.FIRST;

// Add camera to scene so its children (first-person arm / held block) render.
scene.add(camera);

function cycleCamMode() {
  camMode = (camMode + 1) % 3;
  updateHelp();
}

const SKIN_W = 64, SKIN_H = 64;

function makeSteveSkinCanvas() {
  // Lightweight "Steve-ish" 64x64 skin drawn procedurally (no external assets).
  const c = document.createElement("canvas");
  c.width = SKIN_W; c.height = SKIN_H;
  const ctx = c.getContext("2d", { alpha: true });
  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0, 0, SKIN_W, SKIN_H);

  // Palette (approx Steve)
  const SKIN  = "#d7a56d";
  const SKIN2 = "#c58e5a";
  const HAIR  = "#2b1b13";
  const HAIR2 = "#20110b";
  const SHIRT = "#2d5aa8";
  const SHIRT2= "#234a89";
  const PANTS = "#2b3a6b";
  const PANTS2= "#1f2b52";
  const SHOE  = "#5b5b5b";
  const WHITE = "#ffffff";
  const BLUE  = "#2a7fff";
  const OUT   = "rgba(0,0,0,0.35)";

  function rect(x,y,w,h,col){ ctx.fillStyle = col; ctx.fillRect(x,y,w,h); }
  function px(x,y,col){ ctx.fillStyle = col; ctx.fillRect(x,y,1,1); }

  // Helper to fill all faces for a box part given the vanilla skin layout rects.
  // We'll paint broad regions: head, body, arms, legs.

  // HEAD faces
  // top (8,0 8x8) hair
  rect(8,0,8,8,HAIR);
  // bottom (16,0) darker
  rect(16,0,8,8,HAIR2);
  // sides/back hair
  rect(0,8,32,8,HAIR);
  rect(24,8,8,8,HAIR2);
  // front face skin with hairline
  rect(8,8,8,8,SKIN);
  rect(8,8,8,2,HAIR);
  // eyes
  px(10,11,WHITE); px(11,11,BLUE);
  px(13,11,WHITE); px(14,11,BLUE);
  // mouth
  px(11,14,SKIN2); px(12,14,SKIN2); px(13,14,SKIN2);

  // BODY (20,20 front 8x12) shirt
  rect(20,20,8,12,SHIRT);
  // body back (32,20)
  rect(32,20,8,12,SHIRT2);
  // body sides (16,20 left 4x12, 28,20 right 4x12)
  rect(16,20,4,12,SHIRT2);
  rect(28,20,4,12,SHIRT2);
  // body top/bottom
  rect(20,16,8,4,SHIRT2);
  rect(28,16,8,4,SHIRT2);

  // RIGHT ARM (44,20 front 4x12) sleeve + hand
  rect(44,20,4,12,SHIRT);
  rect(40,20,4,12,SHIRT2);
  rect(48,20,4,12,SHIRT2);
  rect(52,20,4,12,SHIRT2);
  rect(44,16,4,4,SHIRT2); // top
  rect(48,16,4,4,SHIRT2); // bottom
  // add hand tint at bottom 3px of each arm face
  rect(44,29,4,3,SKIN);
  rect(40,29,4,3,SKIN);
  rect(48,29,4,3,SKIN);
  rect(52,29,4,3,SKIN);
  rect(44,20,4,1,SHIRT2); // cuff line

  // LEFT ARM (new format at bottom half): front (36,52 4x12)
  rect(36,52,4,12,SHIRT);
  rect(32,52,4,12,SHIRT2);
  rect(40,52,4,12,SHIRT2);
  rect(44,52,4,12,SHIRT2);
  rect(36,48,4,4,SHIRT2); // top
  rect(40,48,4,4,SHIRT2); // bottom
  rect(36,61,4,3,SKIN);
  rect(32,61,4,3,SKIN);
  rect(40,61,4,3,SKIN);
  rect(44,61,4,3,SKIN);
  rect(36,52,4,1,SHIRT2);

  // RIGHT LEG (4,20 front 4x12) pants + shoes
  rect(4,20,4,12,PANTS);
  rect(0,20,4,12,PANTS2);
  rect(8,20,4,12,PANTS2);
  rect(12,20,4,12,PANTS2);
  rect(4,16,4,4,PANTS2); // top
  rect(8,16,4,4,PANTS2); // bottom
  rect(4,28,4,4,SHOE);
  rect(0,28,4,4,SHOE);
  rect(8,28,4,4,SHOE);
  rect(12,28,4,4,SHOE);

  // LEFT LEG (new format): front (20,52 4x12)
  rect(20,52,4,12,PANTS);
  rect(16,52,4,12,PANTS2);
  rect(24,52,4,12,PANTS2);
  rect(28,52,4,12,PANTS2);
  rect(20,48,4,4,PANTS2); // top
  rect(24,48,4,4,PANTS2); // bottom
  rect(20,60,4,4,SHOE);
  rect(16,60,4,4,SHOE);
  rect(24,60,4,4,SHOE);
  rect(28,60,4,4,SHOE);

  // A light outline on the head front (readability)
  for (let x=8; x<16; x++) { px(x,8,OUT); px(x,15,OUT); }
  for (let y=8; y<16; y++) { px(8,y,OUT); px(15,y,OUT); }

  return c;
}

const steveSkinTex = new THREE.CanvasTexture(makeSteveSkinCanvas());
steveSkinTex.colorSpace = THREE.SRGBColorSpace;
steveSkinTex.magFilter = THREE.NearestFilter;
steveSkinTex.minFilter = THREE.NearestFilter;
steveSkinTex.generateMipmaps = false;

function skinRect(u, v, w, h) {
  const u0 = u / SKIN_W;
  const u1 = (u + w) / SKIN_W;
  const v1 = 1 - (v / SKIN_H);
  const v0 = 1 - ((v + h) / SKIN_H);
  return { u0, u1, v0, v1 };
}

function applyFaceRectUV(uv, faceIndex, r, flipX=false, flipY=false) {
  let {u0,u1,v0,v1} = r;
  if (flipX) { const t=u0; u0=u1; u1=t; }
  if (flipY) { const t=v0; v0=v1; v1=t; }
  const base = faceIndex * 4;
  uv.setXY(base + 0, u0, v1);
  uv.setXY(base + 1, u1, v1);
  uv.setXY(base + 2, u0, v0);
  uv.setXY(base + 3, u1, v0);
}

function makeSkinBox(w, h, d, faceRects) {
  const g = new THREE.BoxGeometry(w, h, d);
  const uv = g.attributes.uv;
  // face order: +x, -x, +y, -y, +z, -z
  for (let f=0; f<6; f++) {
    const fr = faceRects[f];
    applyFaceRectUV(uv, f, skinRect(fr.u, fr.v, fr.w, fr.h), !!fr.flipX, !!fr.flipY);
  }
  uv.needsUpdate = true;
  return g;
}

// Vanilla (classic) Steve UV layout rects (pixels) for each part.
const UV_HEAD = [
  {u:16,v:8,w:8,h:8},  // +x right
  {u:0, v:8,w:8,h:8},  // -x left
  {u:8, v:0,w:8,h:8},  // +y top
  {u:16,v:0,w:8,h:8},  // -y bottom
  {u:8, v:8,w:8,h:8},  // +z front
  {u:24,v:8,w:8,h:8},  // -z back
];
const UV_BODY = [
  {u:28,v:20,w:4,h:12}, // +x right
  {u:16,v:20,w:4,h:12}, // -x left
  {u:20,v:16,w:8,h:4},  // +y top
  {u:28,v:16,w:8,h:4},  // -y bottom
  {u:20,v:20,w:8,h:12}, // +z front
  {u:32,v:20,w:8,h:12}, // -z back
];
const UV_ARM_R = [
  {u:48,v:20,w:4,h:12}, // +x right
  {u:40,v:20,w:4,h:12}, // -x left
  {u:44,v:16,w:4,h:4},  // +y top
  {u:48,v:16,w:4,h:4},  // -y bottom
  {u:44,v:20,w:4,h:12}, // +z front
  {u:52,v:20,w:4,h:12}, // -z back
];
const UV_ARM_L = [
  {u:40,v:52,w:4,h:12}, // +x right
  {u:32,v:52,w:4,h:12}, // -x left
  {u:36,v:48,w:4,h:4},  // +y top
  {u:40,v:48,w:4,h:4},  // -y bottom
  {u:36,v:52,w:4,h:12}, // +z front
  {u:44,v:52,w:4,h:12}, // -z back
];
const UV_LEG_R = [
  {u:8, v:20,w:4,h:12}, // +x right
  {u:0, v:20,w:4,h:12}, // -x left
  {u:4, v:16,w:4,h:4},  // +y top
  {u:8, v:16,w:4,h:4},  // -y bottom
  {u:4, v:20,w:4,h:12}, // +z front
  {u:12,v:20,w:4,h:12}, // -z back
];
const UV_LEG_L = [
  {u:24,v:52,w:4,h:12}, // +x right
  {u:16,v:52,w:4,h:12}, // -x left
  {u:20,v:48,w:4,h:4},  // +y top
  {u:24,v:48,w:4,h:4},  // -y bottom
  {u:20,v:52,w:4,h:12}, // +z front
  {u:28,v:52,w:4,h:12}, // -z back
];

// Build player model (scaled to match PLAYER.height)
const pxUnit = PLAYER.height / 32;
const headW = 8 * pxUnit, headH = 8 * pxUnit, headD = 8 * pxUnit;
const bodyW = 8 * pxUnit, bodyH = 12 * pxUnit, bodyD = 4 * pxUnit;
const armW  = 4 * pxUnit, armH  = 12 * pxUnit, armD  = 4 * pxUnit;
const legW  = 4 * pxUnit, legH  = 12 * pxUnit, legD  = 4 * pxUnit;

const matSkinWorld = new THREE.MeshLambertMaterial({ map: steveSkinTex });
matSkinWorld.map.colorSpace = THREE.SRGBColorSpace;

const playerModel = new THREE.Group();
playerModel.name = "playerModel";

// Body yaw group (Minecraft-ish): rotates separately from head.
const bodyGroup = new THREE.Group();
bodyGroup.name = "playerBody";

// Head pivot at base of head (neck). Allows yaw + pitch.
const headPivot = new THREE.Group();
headPivot.name = "playerHeadPivot";
headPivot.rotation.order = "YXZ";
headPivot.position.set(0, legH + bodyH, 0);

const headMesh = new THREE.Mesh(makeSkinBox(headW, headH, headD, UV_HEAD), matSkinWorld);
headMesh.position.y = headH * 0.5;

const bodyMesh = new THREE.Mesh(makeSkinBox(bodyW, bodyH, bodyD, UV_BODY), matSkinWorld);
bodyMesh.position.y = legH + bodyH * 0.5;

const armRMesh = new THREE.Mesh(makeSkinBox(armW, armH, armD, UV_ARM_R), matSkinWorld);
const armLMesh = new THREE.Mesh(makeSkinBox(armW, armH, armD, UV_ARM_L), matSkinWorld);
const legRMesh = new THREE.Mesh(makeSkinBox(legW, legH, legD, UV_LEG_R), matSkinWorld);
const legLMesh = new THREE.Mesh(makeSkinBox(legW, legH, legD, UV_LEG_L), matSkinWorld);

// --- Limb pivots so rotations happen at shoulders/hips (top of limb), not the middle ---
const armRPivot = new THREE.Group();
armRPivot.position.set((bodyW * 0.5) + (armW * 0.5), legH + bodyH, 0);
armRMesh.position.set(0, -armH * 0.5, 0);
armRPivot.add(armRMesh);

const armLPivot = new THREE.Group();
armLPivot.position.set(-(bodyW * 0.5) - (armW * 0.5), legH + bodyH, 0);
armLMesh.position.set(0, -armH * 0.5, 0);
armLPivot.add(armLMesh);


// Third-person held block (shows selected block in the player's hand)
function cloneWorldMatForBlock(id) {
  let opacity = 1.0;
  if (id === B.GLASS) opacity = 0.50;
  else if (id === B.WATER) opacity = 0.65;
  else if (id === B.LAVA) opacity = 0.85;

  const transparent = opacity < 0.999;
  const m = new THREE.MeshLambertMaterial({ map: atlasTex, transparent, opacity });
  m.fog = true;
  m.depthTest = true;
  m.depthWrite = !transparent;
  return m;
}

const tpHeld = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), cloneWorldMatForBlock(B.DIRT));
tpHeld.scale.setScalar(0.24);
tpHeld.position.set(0.10, -armH + 0.18, -0.10);
tpHeld.rotation.set(-0.15, 0.78, 0.10);
// Attach to the same pivot we swing for the "right-hand" hit.
armLPivot.add(tpHeld);


const legRPivot = new THREE.Group();
legRPivot.position.set(legW * 0.5, legH, 0);
legRMesh.position.set(0, -legH * 0.5, 0);
legRPivot.add(legRMesh);

const legLPivot = new THREE.Group();
legLPivot.position.set(-legW * 0.5, legH, 0);
legLMesh.position.set(0, -legH * 0.5, 0);
legLPivot.add(legLMesh);

headPivot.add(headMesh);
bodyGroup.add(bodyMesh, armRPivot, armLPivot, legRPivot, legLPivot, headPivot);
playerModel.add(bodyGroup);
scene.add(playerModel);
// Simple walk animation (3rd person). Uses actual movement delta for stability.
let walkPhase = 0;
let prevWalkX = 0, prevWalkY = 0, prevWalkZ = 0;
let walkInit = false;

// Minecraft-ish model yaw split:
// - head follows camera yaw+pitch
// - body follows movement direction when moving, otherwise eases toward head
let bodyYaw = 0;
let stillTime = 0;

function wrapAngle(a) {
  a = (a + Math.PI) % (Math.PI * 2);
  if (a < 0) a += Math.PI * 2;
  return a - Math.PI;
}
function angleDiff(a, b) { return wrapAngle(a - b); }
// Exponential smoothing for angles (stable across frame rates).
function approachAngle(cur, target, rate, dt) {
  const t = 1 - Math.exp(-rate * dt);
  return cur + angleDiff(target, cur) * t;
}


function updatePlayerWalk(dt) {
  // Fully velocity-driven animation (no key input).
  // Uses player position deltas to estimate world-space velocity (vx, vy, vz).
  if (!walkInit) {
    prevWalkX = player.pos.x; prevWalkZ = player.pos.z; prevWalkY = player.pos.y;
    walkInit = true;
    bodyYaw = yaw;
  }
  const dx = player.pos.x - prevWalkX;
  const dy = player.pos.y - prevWalkY;
  const dz = player.pos.z - prevWalkZ;
  prevWalkX = player.pos.x; prevWalkY = player.pos.y; prevWalkZ = player.pos.z;

  const invDt = (dt > 1e-6) ? (1 / dt) : 0;
  const vx = dx * invDt;
  const vy = dy * invDt;
  const vz = dz * invDt;

  const speedH = Math.sqrt(vx*vx + vz*vz);
  const grounded = !!player.onGround;

  // ======================================================
  // Minecraft-ish head/body split:
  //  - head follows camera yaw + pitch
  //  - body follows movement direction when moving
  //  - when idle, body slowly eases toward head after a short delay
  //  - if head twists too far, body catches up so the head stays within a limit
  // ======================================================
  const moving = speedH > 0.04;

  if (moving) {
    stillTime = 0;
    const moveYaw = Math.atan2(-vx, -vz);
    bodyYaw = approachAngle(bodyYaw, moveYaw, 10.0, dt);
  } else {
    stillTime += dt;
    if (stillTime > 0.25) {
      bodyYaw = approachAngle(bodyYaw, yaw, 2.2, dt);
    }
  }

  // Keep head twist within a Minecraft-ish limit by pulling body toward head.
  const MAX_HEAD = 45 * Math.PI / 180; // limit body/head yaw difference to 45°
  let relYaw = angleDiff(yaw, bodyYaw);
  if (Math.abs(relYaw) > MAX_HEAD) {
    const desiredBody = yaw - Math.sign(relYaw) * MAX_HEAD;
    bodyYaw = approachAngle(bodyYaw, desiredBody, 12.0, dt);
    relYaw = angleDiff(yaw, bodyYaw);
  }

  bodyGroup.rotation.y = bodyYaw + Math.PI;
  headPivot.rotation.y = relYaw;
  // Model pitch axis is inverted relative to camera pitch.
  headPivot.rotation.x = -pitch;

  // ======================================================
  // Limb animation (velocity-driven).
  // Use horizontal (XZ) speed magnitude. If we used world-X only, the walk cycle
  // would nearly vanish whenever motion is mostly along Z (depends on facing/route).
  // No body/head bobbing (stable height like Minecraft).
  // ======================================================
  const speedMove = speedH;
  const movingMove = speedMove > 0.02;

  const pace = grounded ? 0.30 : 0.12; // slower overall; even slower in air
  if (movingMove) {
    walkPhase += speedMove * dt * pace;
  }

  // If not moving horizontally, keep limbs neutral (no "air-walk" on vertical-only jumps).
  const base = movingMove ? Math.sin(walkPhase * Math.PI * 2) : 0;

  const maxRun = (PLAYER.speed * 1.75);
  const t = Math.min(1.0, speedMove / (maxRun || 1));
  // Tune swing: walking slightly more pronounced, sprinting less extreme.
  // (walk speed ~ PLAYER.speed -> t≈0.57 when maxRun = speed*1.75)
  const t0 = 0.62;
  const walkPeak = 0.90;
  const runAmp = 0.78;
  let amp = (t <= t0)
    ? (t / t0) * walkPeak
    : (walkPeak + ((t - t0) / (1 - t0)) * (runAmp - walkPeak));

  if (!grounded) amp *= 0.35;

  const swing = base * amp * 1.4; // walk a bit wider, sprint less wild

  const vNorm = Math.max(-1, Math.min(1, vy / (PLAYER.jump || 1)));
  const jumpPose = movingMove ? vNorm : 0; // only pose-swing when moving horizontally

  armRPivot.rotation.x = -swing - jumpPose * 0.45;
  armLPivot.rotation.x =  swing - jumpPose * 0.45;
// When attacking, don't let movement "momentum" (walk cycle) distort the swing.
// Minecraft's hit animation reads as consistent even while moving.
if (attackT > 0) {
  armLPivot.rotation.x *= 0.15; // damp walk contribution on the swing arm during attack
}

  legRPivot.rotation.x =  swing + jumpPose * 0.25;
  legLPivot.rotation.x = -swing + jumpPose * 0.25;


  // Attack swing (third person) + tiny body recoil.
  // NOTE: "right hand" in camera view may correspond to the model's left pivot depending on facing,
  // so we drive the arm that visually matches the on-screen right-hand hit.
  // Third-person attack: circular (Minecraft-ish) swing in rotation-space.
  // Use an envelope so it always returns exactly to the idle pose.
  const atkP = (ATTACK_DUR <= 0) ? 1 : (attackT > 0 ? (1 - (attackT / ATTACK_DUR)) : 0);
  const atkT = Math.max(0, Math.min(1, atkP));
  const atkEnv = Math.sin(atkT * Math.PI); // 0 -> 1 -> 0
  const atkTheta = -atkT * Math.PI * 2;    // counterclockwise loop

  // Reset per-frame additives so nothing accumulates across taps.
  armRPivot.rotation.z = 0;
  armLPivot.rotation.z = 0;
  armRPivot.rotation.y = 0;
  armLPivot.rotation.y = 0;
  bodyMesh.rotation.y = 0;

  // Additive so walk/run stays intact
  // Make third-person attack swing longer (2x rotation) and slower (see ATTACK_DUR).
  // Circle/oval: combine X/Z with a 90° phase shift.
  // X carries the main down-swing; Z/Y add the “around” feel.
  // More “round” like Minecraft: a down-biased oval rather than a diagonal jab.
  // (X = down/forward; Z/Y = around/side)
  armLPivot.rotation.x += -atkEnv * (1.70 + 1.00 * Math.cos(atkTheta));
  armLPivot.rotation.z +=  atkEnv * (0.55 * Math.sin(atkTheta));
  armLPivot.rotation.y +=  atkEnv * (0.09 * Math.sin(atkTheta + Math.PI * 0.5));

  // Only the torso should yaw a bit (no bobbing / no leg/head yaw)
  bodyMesh.rotation.y += atkEnv * 0.10;
}


// First-person arm (real mesh) + held block (real textured cube)
const matSkinVM = new THREE.MeshBasicMaterial({ map: steveSkinTex, fog: false, transparent: true, opacity: 1.0 });
    matSkinVM.depthTest = false;
    matSkinVM.depthWrite = false;

const FP_ARM_BASE_POS = new THREE.Vector3(0.62, -0.38, -0.72); // moved further right
const FP_ARM_BASE_ROT = new THREE.Euler(-0.55, 0.55, 0.18 + Math.PI); // flipped 180° (roll)

const fpArm = new THREE.Mesh(makeSkinBox(armW, armH, armD, UV_ARM_R), matSkinVM);
fpArm.renderOrder = 9999;
// Position relative to camera (right side) and rotate inward
fpArm.position.copy(FP_ARM_BASE_POS);
fpArm.rotation.copy(FP_ARM_BASE_ROT);

// Held block (block-only viewmodel when selected; arm-only when empty).
const FP_HELD_POS_WITH_ARM = new THREE.Vector3(0.46, -0.30, -0.82); // in-hand
const FP_HELD_ROT_WITH_ARM = new THREE.Euler(-0.25, 0.75, 0.12);
const FP_HELD_SCALE_WITH_ARM = 0.2067;

const FP_HELD_POS_NO_ARM = new THREE.Vector3(0.70, -0.24, -0.64); // bigger + closer + more right
const FP_HELD_ROT_NO_ARM = new THREE.Euler(-0.18, 0.92, 0.10);
const FP_HELD_SCALE_NO_ARM = 0.34;

// Mutable bases (swap depending on whether a block is selected)
let fpHeldBasePos = FP_HELD_POS_WITH_ARM.clone();
let fpHeldBaseRot = FP_HELD_ROT_WITH_ARM.clone();
let fpHeldBaseScale = FP_HELD_SCALE_WITH_ARM;


const fpHeld = new THREE.Mesh(geomFor.get(B.GRASS) || new THREE.BoxGeometry(1,1,1), matOpaque.clone());
fpHeld.renderOrder = 10000;
fpHeld.position.copy(fpHeldBasePos);
fpHeld.rotation.copy(fpHeldBaseRot);
fpHeld.scale.setScalar(fpHeldBaseScale);
fpHeld.frustumCulled = false;

// Make held block always visible (like Minecraft viewmodel)
fpHeld.material.transparent = true;
fpHeld.material.opacity = 1.0;
fpHeld.material.depthTest = false;
fpHeld.material.depthWrite = false;
fpHeld.material.fog = false;

const fpRig = new THREE.Group();
fpRig.renderOrder = 9998;
fpRig.add(fpArm);
fpRig.add(fpHeld);
camera.add(fpRig);

// Viewmodel swing (break/place/pick/any click)
// First-person: Minecraft-ish counterclockwise oval swing.
// Third-person: also drives a subtle right-hand "attack" swing + tiny body recoil.
let swingT = 0;
let attackT = 0;
const SWING_DUR = 0.28;
const ATTACK_DUR = 0.26;

function triggerSwing() {
  swingT = SWING_DUR;
  attackT = ATTACK_DUR;
}

function applyViewmodelSwing(dt) {
  // dt is seconds
  if (swingT > 0) swingT = Math.max(0, swingT - dt);
  if (attackT > 0) attackT = Math.max(0, attackT - dt);

  // Progress 0..1 (0=start, 1=end)
  const tt = (SWING_DUR <= 0) ? 1 : (1 - (swingT / SWING_DUR));
  const p = Math.max(0, Math.min(1, tt));

  // Envelope so it starts/ends exactly at the base pose.
  const a = Math.sin(p * Math.PI); // 0 -> 1 -> 0

  // Counterclockwise oval in (x,y) as p increases.
  const theta = p * Math.PI * 2;
  const ex = Math.cos(theta);
  const ey = Math.sin(theta);

  // Ellipse radii (tuned to feel like MC without being wild)
  const rx = 0.080;
  const ry = 0.085;

  // Slight forward/back coupling so it doesn't look like a flat 2D sticker.
  const ez = Math.sin(theta + Math.PI * 0.5); // leads the arc a bit

  // Arm
  fpArm.position.set(
    FP_ARM_BASE_POS.x + a * (rx * ex) + a * 0.010,
    FP_ARM_BASE_POS.y + a * (ry * ey) - a * 0.028,
    FP_ARM_BASE_POS.z + a * (0.030 * ez) + a * 0.014
  );
  fpArm.rotation.set(
    FP_ARM_BASE_ROT.x - a * 0.92 - a * 0.28 * ey,
    FP_ARM_BASE_ROT.y + a * 0.10 + a * 0.10 * ex,
    FP_ARM_BASE_ROT.z - a * 0.38 + a * 0.30 * ex
  );

  // Held block follows, a bit heavier/slower
  fpHeld.position.set(
    fpHeldBasePos.x + a * (rx * 1.18 * ex) + a * 0.012,
    fpHeldBasePos.y + a * (ry * 1.20 * ey) - a * 0.040,
    fpHeldBasePos.z + a * (0.040 * ez) + a * 0.022
  );
  fpHeld.rotation.set(
    fpHeldBaseRot.x - a * 0.84 - a * 0.24 * ey,
    fpHeldBaseRot.y + a * 0.10 + a * 0.08 * ex,
    fpHeldBaseRot.z - a * 0.28 + a * 0.26 * ex
  );
}

function cloneViewMatForBlock(id) {
  // Viewmodel renders after world (including transparents) to avoid "hand becomes transparent".
  // Force it into the transparent render list + high renderOrder; opacity still controls block look.
  let opacity = 1.0;
  if (id === B.GLASS) opacity = 0.50;
  else if (id === B.WATER) opacity = 0.65;
  else if (id === B.LAVA) opacity = 0.85;

  const m = new THREE.MeshBasicMaterial({ map: atlasTex, transparent: true, opacity, fog: false });
  m.depthTest = false;
  m.depthWrite = false;
  return m;
}

function updateHeldBlock3D() {
  if (!fpHeld) return;
  const id = selectedBlock();

  // Minecraft-ish: empty hand shows arm; selecting a block shows only the block (no arm).
  if (typeof fpArm !== "undefined" && fpArm) fpArm.visible = (id === B.AIR);
  fpHeld.visible = (id !== B.AIR);

  // Swap viewmodel pose for block-only mode (bigger/closer/right).
  if (id === B.AIR) {
    fpHeldBasePos.copy(FP_HELD_POS_WITH_ARM);
    fpHeldBaseRot.copy(FP_HELD_ROT_WITH_ARM);
    fpHeldBaseScale = FP_HELD_SCALE_WITH_ARM;
  } else {
    fpHeldBasePos.copy(FP_HELD_POS_NO_ARM);
    fpHeldBaseRot.copy(FP_HELD_ROT_NO_ARM);
    fpHeldBaseScale = FP_HELD_SCALE_NO_ARM;
  }
  fpHeld.position.copy(fpHeldBasePos);
  fpHeld.rotation.copy(fpHeldBaseRot);
  fpHeld.scale.setScalar(fpHeldBaseScale);

  const g = geomFor.get(id) || geomFor.get(B.DIRT);
  if (g) fpHeld.geometry = g;
  try { fpHeld.material.dispose(); } catch(_) {}
      fpHeld.material = cloneViewMatForBlock(id);
      fpHeld.material.needsUpdate = true;

  // Third-person: show selected block in the player's hand.
  if (typeof tpHeld !== "undefined" && tpHeld) {
    tpHeld.visible = (id !== B.AIR);
    if (tpHeld.visible) {
      const tg = geomFor.get(id) || geomFor.get(B.DIRT);
      if (tg) tpHeld.geometry = tg;
      try { tpHeld.material.dispose(); } catch(_) {}
      tpHeld.material = cloneWorldMatForBlock(id);
      tpHeld.material.needsUpdate = true;
    }
  }
}


// Cached vectors to avoid per-frame allocations
const _eyePos = new THREE.Vector3();
const _desiredCam = new THREE.Vector3();
const _toCam = new THREE.Vector3();
const _dir = new THREE.Vector3();
const _lookEuler = new THREE.Euler(0,0,0,"YXZ");
const _lookDir = new THREE.Vector3();

function updateCameraRig() {
  _eyePos.set(player.pos.x, player.pos.y + PLAYER.eye, player.pos.z);
  _lookEuler.set(pitch, yaw, 0, "YXZ");
  _lookDir.set(0, 0, -1).applyEuler(_lookEuler).normalize();

  // Update player model (only visible in 3rd person)
  playerModel.position.set(player.pos.x, player.pos.y, player.pos.z);
if (camMode === CAM_MODE.FIRST) {
    camera.position.copy(_eyePos);
    camera.rotation.x = pitch;
    camera.rotation.y = yaw;
    camera.rotation.z = 0;
    fpRig.visible = true;
    playerModel.visible = false;
    return;
  }

  fpRig.visible = false;
  playerModel.visible = true;

  const dist = (camMode === CAM_MODE.THIRD_BACK) ? 3.6 : 3.2;
  const up = 0.22;

  if (camMode === CAM_MODE.THIRD_BACK) {
    _desiredCam.copy(_eyePos).addScaledVector(_lookDir, -dist);
    _desiredCam.y += up;
  } else {
    _desiredCam.copy(_eyePos).addScaledVector(_lookDir, dist);
    _desiredCam.y += up;
  }

  // Prevent camera clipping into blocks (simple voxel raycast)
  _toCam.copy(_desiredCam).sub(_eyePos);
  const dLen = _toCam.length();
  if (dLen > 0.001) {
    _dir.copy(_toCam).multiplyScalar(1 / dLen);
    const hit = voxelRaycast(_eyePos, _dir, dLen);
    if (hit) {
      const safe = Math.max(0.6, hit.dist - 0.18);
      _desiredCam.copy(_eyePos).addScaledVector(_dir, safe);
    }
  }

  camera.position.copy(_desiredCam);

  if (camMode === CAM_MODE.THIRD_BACK) {
    camera.rotation.x = pitch;
    camera.rotation.y = yaw;
    camera.rotation.z = 0;
  } else {
    camera.lookAt(_eyePos);
  }
}

        // palette list with icons + names (organized)
    const BLOCK_LIST = [
      { id: B.GRASS, name: "Grass", icon: T.grass_top, cat: "nature" },
      { id: B.DIRT, name: "Dirt", icon: T.dirt, cat: "nature" },
      { id: B.SAND, name: "Sand", icon: T.sand, cat: "nature" },
      { id: B.LOG, name: "Oak Log", icon: T.log_top, cat: "nature" },
      { id: B.LEAVES, name: "Leaves", icon: T.leaves, cat: "nature" },
      { id: B.WATER, name: "Water (static)", icon: T.water, cat: "nature" },
      { id: B.LAVA, name: "Lava (static)", icon: T.lava, cat: "nature" },
      { id: B.COBBLE, name: "Cobblestone", icon: T.cobble, cat: "building" },
      { id: B.PLANKS, name: "Oak Planks", icon: T.planks, cat: "building" },
      { id: B.BRICKS, name: "Bricks", icon: T.bricks, cat: "building" },
      { id: B.GLASS, name: "Glass", icon: T.glass, cat: "building" },
      { id: B.OBSIDIAN, name: "Obsidian", icon: T.obsidian, cat: "building" },
      { id: B.BEDROCK, name: "Bedrock", icon: T.bedrock, cat: "building" },
      { id: B.WOOL_WHITE, name: "White Wool", icon: T.wool_white, cat: "decoration" },
      { id: B.WOOL_RED, name: "Red Wool", icon: T.wool_red, cat: "decoration" },
      { id: B.WOOL_BLUE, name: "Blue Wool", icon: T.wool_blue, cat: "decoration" },
      { id: B.WOOL_GREEN, name: "Green Wool", icon: T.wool_green, cat: "decoration" },
      { id: B.TNT, name: "TNT", icon: T.tnt_side, cat: "decoration" },
      { id: B.GOLD, name: "Gold Block", icon: T.gold, cat: "decoration" },
      { id: B.DIAMOND, name: "Diamond Block", icon: T.diamond, cat: "decoration" },
      { id: B.COAL_ORE, name: "Coal Ore", icon: T.coal_ore, cat: "ores" },
      { id: B.IRON_ORE, name: "Iron Ore", icon: T.iron_ore, cat: "ores" },
      { id: B.GOLD_ORE, name: "Gold Ore", icon: T.gold_ore, cat: "ores" },
      { id: B.DIAMOND_ORE, name: "Diamond Ore", icon: T.diamond_ore, cat: "ores" },
      { id: B.CRAFTING_TABLE, name: "Crafting Table", icon: T.crafting_table_front, cat: "functional" },
      { id: B.FURNACE, name: "Furnace", icon: T.furnace_front, cat: "functional" },
      { id: B.WOODEN_SWORD, name: "Wooden Sword", icon: T.wooden_sword, cat: "tools" },
      { id: B.WOODEN_PICKAXE, name: "Wooden Pickaxe", icon: T.wooden_pickaxe, cat: "tools" },
      { id: B.WOODEN_AXE, name: "Wooden Axe", icon: T.wooden_axe, cat: "tools" },
      { id: B.WOODEN_SHOVEL, name: "Wooden Shovel", icon: T.wooden_shovel, cat: "tools" },
      { id: B.WOODEN_HOE, name: "Wooden Hoe", icon: T.wooden_hoe, cat: "tools" },
      { id: B.STONE_SWORD, name: "Stone Sword", icon: T.stone_sword, cat: "tools" },
      { id: B.STONE_PICKAXE, name: "Stone Pickaxe", icon: T.stone_pickaxe, cat: "tools" },
      { id: B.STONE_AXE, name: "Stone Axe", icon: T.stone_axe, cat: "tools" },
      { id: B.STONE_SHOVEL, name: "Stone Shovel", icon: T.stone_shovel, cat: "tools" },
      { id: B.STONE_HOE, name: "Stone Hoe", icon: T.stone_hoe, cat: "tools" },
      { id: B.IRON_SWORD, name: "Iron Sword", icon: T.iron_sword, cat: "tools" },
      { id: B.IRON_PICKAXE, name: "Iron Pickaxe", icon: T.iron_pickaxe, cat: "tools" },
      { id: B.IRON_AXE, name: "Iron Axe", icon: T.iron_axe, cat: "tools" },
      { id: B.IRON_SHOVEL, name: "Iron Shovel", icon: T.iron_shovel, cat: "tools" },
      { id: B.IRON_HOE, name: "Iron Hoe", icon: T.iron_hoe, cat: "tools" },
      { id: B.DIAMOND_SWORD, name: "Diamond Sword", icon: T.diamond_sword, cat: "tools" },
      { id: B.DIAMOND_PICKAXE, name: "Diamond Pickaxe", icon: T.diamond_pickaxe, cat: "tools" },
      { id: B.DIAMOND_AXE, name: "Diamond Axe", icon: T.diamond_axe, cat: "tools" },
      { id: B.DIAMOND_SHOVEL, name: "Diamond Shovel", icon: T.diamond_shovel, cat: "tools" },
      { id: B.DIAMOND_HOE, name: "Diamond Hoe", icon: T.diamond_hoe, cat: "tools" },
    ];

    const WEAPON_STATS = {
      [B.WOODEN_SWORD]: { damage: 4, reach: 3.1, cooldown: 0.55, durability: 59 },
      [B.WOODEN_AXE]: { damage: 3, reach: 2.9, cooldown: 0.7, durability: 59 },
      [B.WOODEN_PICKAXE]: { damage: 2, reach: 2.7, cooldown: 0.65, durability: 59 },
      [B.WOODEN_SHOVEL]: { damage: 1, reach: 2.6, cooldown: 0.6, durability: 59 },
      [B.WOODEN_HOE]: { damage: 1, reach: 2.6, cooldown: 0.6, durability: 59 },
      [B.STONE_SWORD]: { damage: 5, reach: 3.2, cooldown: 0.55, durability: 131 },
      [B.STONE_AXE]: { damage: 4, reach: 3.0, cooldown: 0.7, durability: 131 },
      [B.STONE_PICKAXE]: { damage: 3, reach: 2.8, cooldown: 0.65, durability: 131 },
      [B.STONE_SHOVEL]: { damage: 2, reach: 2.7, cooldown: 0.6, durability: 131 },
      [B.STONE_HOE]: { damage: 2, reach: 2.7, cooldown: 0.6, durability: 131 },
      [B.IRON_SWORD]: { damage: 6, reach: 3.3, cooldown: 0.5, durability: 250 },
      [B.IRON_AXE]: { damage: 5, reach: 3.1, cooldown: 0.65, durability: 250 },
      [B.IRON_PICKAXE]: { damage: 4, reach: 2.9, cooldown: 0.6, durability: 250 },
      [B.IRON_SHOVEL]: { damage: 3, reach: 2.8, cooldown: 0.55, durability: 250 },
      [B.IRON_HOE]: { damage: 3, reach: 2.8, cooldown: 0.55, durability: 250 },
      [B.DIAMOND_SWORD]: { damage: 7, reach: 3.4, cooldown: 0.5, durability: 1561 },
      [B.DIAMOND_AXE]: { damage: 6, reach: 3.2, cooldown: 0.6, durability: 1561 },
      [B.DIAMOND_PICKAXE]: { damage: 5, reach: 3.0, cooldown: 0.6, durability: 1561 },
      [B.DIAMOND_SHOVEL]: { damage: 4, reach: 2.9, cooldown: 0.55, durability: 1561 },
      [B.DIAMOND_HOE]: { damage: 4, reach: 2.9, cooldown: 0.55, durability: 1561 },
    };

    const DEFAULT_ATTACK_STATS = { damage: 1, reach: 2.5, cooldown: 0.45, durability: 0 };

    function weaponStatsFor(id) {
      return WEAPON_STATS[id] || DEFAULT_ATTACK_STATS;
    }

    function maxDurabilityFor(id) {
      return WEAPON_STATS[id]?.durability ?? 0;
    }

    function blockName(id) {
      if (id === B.AIR) return "Empty";
      const f = BLOCK_LIST.find(b => b.id === id);
      return f ? f.name : "?";
    }
    function blockIcon(id) {
      if (id === B.AIR) return null;
      const f = BLOCK_LIST.find(b => b.id === id);
      return f ? f.icon : T.dirt;
    }

    function applyTileStyle(el, tileIdx) {
      // IMPORTANT: scale atlas so a 16px tile maps cleanly into the UI icon box.
      // Otherwise a 28x28 element would show parts of neighboring tiles (glitchy icons).
      const tx = tileIdx % ATLAS_COLS;
      const ty = Math.floor(tileIdx / ATLAS_COLS);
      el.style.backgroundImage = `url(${atlasURL})`;
      el.style.backgroundRepeat = "no-repeat";
      el.style.backgroundSize = `${ATLAS_COLS*ICON_PX}px ${ATLAS_ROWS*ICON_PX}px`;
      el.style.backgroundPosition = `-${tx*ICON_PX}px -${ty*ICON_PX}px`;
    }


    // Like applyTileStyle(), but lets us choose the on-screen tile pixel size (used for held block cube faces).
    function applyTileStyleSized(el, tileIdx, px) {
      const tx = tileIdx % ATLAS_COLS;
      const ty = Math.floor(tileIdx / ATLAS_COLS);
      el.style.backgroundImage = `url(${atlasURL})`;
      el.style.backgroundRepeat = "no-repeat";
      el.style.backgroundSize = `${ATLAS_COLS*px}px ${ATLAS_ROWS*px}px`;
      el.style.backgroundPosition = `-${tx*px}px -${ty*px}px`;
    }


    function setSlotSwatch(el, blockId) {
      if (!el) return;
      if (blockId === B.AIR) {
        el.style.backgroundImage = "none";
        el.style.backgroundColor = "transparent";
        return;
      }
      applyTileStyle(el, blockIcon(blockId));
    }


    // ======================================================
    // Look controls
    // ======================================================
    let lookMode = "drag";
    let yaw = 0, pitch = 0;
    const SENS = 0.0025;
    const PITCH_LIMIT = Math.PI/2 - 0.01;

    function applyLook() { camera.rotation.y = yaw; camera.rotation.x = pitch; }
    function rotateBy(dx, dy) {
      yaw   -= dx * SENS;
      pitch -= dy * SENS;
      pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      applyLook();
    }
    function isLocked() { return document.pointerLockElement === renderer.domElement; }

    let rmbDown = false;
    let rmbMoved = 0;
    let rmbStartT = 0;
    let lastX = 0, lastY = 0;

    function startDragLook(clientX, clientY) {
      rmbDown = true; rmbMoved = 0; rmbStartT = performance.now();
      lastX = clientX; lastY = clientY;
      renderer.domElement.style.cursor = "none";
      updateHelp();
      updateViewModelVisibility();
    }
    function stopDragLook() {
      rmbDown = false;
      renderer.domElement.style.cursor = "";
      updateHelp();
      updateViewModelVisibility();
    }

    // ======================================================
    // UI state
    // ======================================================
    let inventoryOpen = false;

    let chatOpen = false;
    const chatMessages = [];
    const CHAT_MAX = 30;
    const CHAT_SHOW_MS = 12000;

    // ======================================================
    // Game mode + Survival stats
    // ======================================================
    let gameMode = "survival"; // "creative" | "survival"
    const SURV_MAX = 20; // 20 HP (10 hearts) / 20 hunger (10 drumsticks)
    let health = SURV_MAX;
    let hunger = SURV_MAX;
    let armor = 0; // reserved (no armor items yet)
    let exhaustion = 0; // drains hunger over time
    let regenTimer = 0;
    let starveTimer = 0;
    let lavaHurtTimer = 0; // lava DPS tick accumulator

    // fall tracking (survival)
    let fallPeakY = 0;
    let lastInWater = false;
    let lastInLava = false;
    let waterBreachTimer = 0; // brief boost when exiting water
    let wasOnGround = false;

    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    function renderStatusHud() {
      const show = (gameMode === "survival");
      statusHudEl.style.display = show ? "flex" : "none";
      if (!show) return;

      // Armor row is only shown in Minecraft when armor > 0.
      armorRowEl.style.display = (armor > 0) ? "flex" : "none";

      for (let i=0;i<10;i++) {
        const a = armor - i*2;
        armorIcons[i].style.backgroundPosition = `-${(a>=2?uiIcons.armorFull:(a===1?uiIcons.armorHalf:uiIcons.armorEmpty))*UI_ICON_PX}px 0px`;

        const hp = health - i*2;
        healthIcons[i].style.backgroundPosition = `-${(hp>=2?uiIcons.heartFull:(hp===1?uiIcons.heartHalf:uiIcons.heartEmpty))*UI_ICON_PX}px 0px`;

        const hu = hunger - i*2;
        hungerIcons[i].style.backgroundPosition = `-${(hu>=2?uiIcons.hungerFull:(hu===1?uiIcons.hungerHalf:uiIcons.hungerEmpty))*UI_ICON_PX}px 0px`;
      }
    }


    // Initial HUD state
    renderStatusHud();

    function setGameMode(mode, announce=true) {
      const m = (mode === "c" ? "creative" : mode === "s" ? "survival" : mode);
      if (m !== "creative" && m !== "survival") return false;
      if (gameMode === m) { renderStatusHud(); return true; }
      gameMode = m;
      if (gameMode === "survival") {
        // Survival: ensure flight is off and reset fall tracking.
        flyMode = false;
        fallPeakY = player ? player.pos.y : 0;
        wasOnGround = false;
      }
      if (announce) {
        addChatMessage(`Set own game mode to ${gameMode === "creative" ? "Creative" : "Survival"}`);
      }
      renderStatusHud();
      try { updateInvModeUI(); if (inventoryOpen) refreshInventoryUI(); } catch(_) {}
      updateHelp();
      return true;
    }

    function damagePlayer(amount, cause="") {
      if (gameMode !== "survival") return;
      const a = Math.max(0, amount|0);
      if (!a) return;
      health = clamp(health - a, 0, SURV_MAX);
      renderStatusHud();
      if (health <= 0) {
        addChatMessage("You died");
        // Respawn at local surface.
        try {
          health = SURV_MAX;
          hunger = SURV_MAX;
          exhaustion = 0;
          regenTimer = 0;
          starveTimer = 0;
          const sx = Math.floor(player.pos.x);
          const sz = Math.floor(player.pos.z);
          const top = surfaceY(sx, sz);
          player.pos.set(sx + 0.5, top + 2.0, sz + 0.5);
          player.velY = 0;
          player.onGround = false;
          fallPeakY = player.pos.y;
          syncCamera();
        } catch (_) {
          // If anything about spawn isn't ready, just reset stats.
        }
        renderStatusHud();
      }
    }
    function exitPointerLock() {
      try { if (document.pointerLockElement) document.exitPointerLock(); } catch (_) {}
    }
    function gameActive() { return menuOverlay.style.display === "none" && !inventoryOpen && !chatOpen; }

    function setMenu(open) {
      menuOverlay.style.display = open ? "grid" : "none";
      if (open && chatOpen) setChat(false);
      lmbHeld = false; rmbHeld = false;
      if (open) exitPointerLock();
      updateHelp();
      updateViewModelVisibility();
    }
    function setInventory(open) {
      inventoryOpen = open;
      if (open && chatOpen) setChat(false);
      invOverlay.style.display = open ? "grid" : "none";
      if (!open) { try { if (invCursorEl) invCursorEl.style.display = "none"; } catch(_) {} }
      lmbHeld = false; rmbHeld = false;
      if (open) {
        invActiveTab = (gameMode === "creative") ? "creative" : "inventory";
        exitPointerLock();
        rmbDown = false;
        renderer.domElement.style.cursor = "";
        try { refreshInventoryUI(); } catch(_) {}
        setTimeout(() => { try { if (gameMode === "creative" && invActiveTab === "creative") searchEl && searchEl.focus(); } catch(_) {} }, 0);
      }
      updateHelp();
      updateViewModelVisibility();
    }

// ======================================================
// Chat (Minecraft-ish)
// ======================================================
function addChatMessage(text) {
  chatMessages.push({ text, t: performance.now() });
  if (chatMessages.length > CHAT_MAX) chatMessages.splice(0, chatMessages.length - CHAT_MAX);
  renderChat();
}

function renderChat() {
  const now = performance.now();
  const showAll = chatOpen;

  // If the user has scrolled up in open chat, don't yank them back down.
  const wasAtBottom = !showAll ? true
    : (chatLogEl.scrollTop + chatLogEl.clientHeight >= chatLogEl.scrollHeight - 6);

  chatLogEl.innerHTML = "";

  if (showAll) {
    // Show full recent history (CHAT_MAX), scrollable.
    for (const m of chatMessages) {
      const div = document.createElement("div");
      div.className = "chatLine";
      div.style.opacity = "1";
      div.textContent = m.text;
      chatLogEl.appendChild(div);
    }
    chatLogEl.style.overflowY = "auto";
  } else {
    // Show a few recent lines with fade-out.
    const lines = [];
    for (let i = chatMessages.length - 1; i >= 0; i--) {
      const m = chatMessages[i];
      const age = now - m.t;
      if (age > CHAT_SHOW_MS) break;

      const op = Math.max(0, Math.min(1, 1 - age / CHAT_SHOW_MS));
      lines.push({ text: m.text, op });

      // Keep the on-screen chat compact (about half the previous height).
      if (lines.length >= 6) break;
    }
    lines.reverse();

    for (const l of lines) {
      const div = document.createElement("div");
      div.className = "chatLine";
      div.style.opacity = String(l.op);
      div.textContent = l.text;
      chatLogEl.appendChild(div);
    }

    chatLogEl.style.overflowY = "hidden";
    chatLogEl.scrollTop = chatLogEl.scrollHeight;
  }

  chatInputRow.style.display = chatOpen ? "block" : "none";
  chatWrap.style.pointerEvents = chatOpen ? "auto" : "none";

  // Auto-scroll to bottom when opening chat / sending messages (unless user scrolled up).
  if (chatOpen && wasAtBottom) {
    chatLogEl.scrollTop = chatLogEl.scrollHeight;
  }
}

function setChat(open) {
  chatOpen = open;
  if (open) {
    exitPointerLock();
    rmbDown = false;
    renderer.domElement.style.cursor = "";
    setTimeout(() => { try { chatInputEl.focus(); } catch(_) {} }, 0);
  } else {
    try { chatInputEl.blur(); } catch(_) {}
    if (menuOverlay.style.display === "none" && !inventoryOpen) resumeGameTryLock();
  }
  renderChat();
  updateHelp();
  updateViewModelVisibility();
}

function handleChatSend(msg) {
  // Commands
  if (msg.startsWith("/")) {
    const parts = msg.slice(1).trim().split(/\s+/).filter(Boolean);
    const cmd = (parts[0] || "").toLowerCase();
    if (cmd === "gamemode" || cmd === "gm") {
      const arg = (parts[1] || "").toLowerCase();
      if (!arg) {
        addChatMessage("Usage: /gamemode <survival|s|creative|c>");
        return;
      }
      if (arg === "survival" || arg === "s" || arg === "0") {
        setGameMode("survival");
        return;
      }
      if (arg === "creative" || arg === "c" || arg === "1") {
        setGameMode("creative");
        return;
      }
      addChatMessage(`Unknown game mode: ${arg}`);
      return;
    }
    addChatMessage(`Unknown command: ${msg}`);
    return;
  }

  addChatMessage(msg);
}

chatInputEl.addEventListener("keydown", (e) => {
  if (e.code === "Enter") {
    e.preventDefault();
    const msg = chatInputEl.value.trim();
    if (msg) handleChatSend(msg);
    chatInputEl.value = "";
    setChat(false);
  } else if (e.code === "Escape") {
    e.preventDefault();
    chatInputEl.value = "";
    setChat(false);
  }
  e.stopPropagation();
});

    function requestPointerLock() {
      try { renderer.domElement.requestPointerLock(); } catch (_) {}
    }
    function resumeGameTryLock() {
      if (!gameActive()) return;
      lookMode = "drag";
      requestPointerLock();
      setTimeout(() => { if (!isLocked()) lookMode = "drag"; updateHelp(); }, 180);
    }

    function startGame() {
      setMenu(false);
      setInventory(false);
      renderer.domElement.focus({ preventScroll: true });
      resumeGameTryLock();
      updateHelp();
    }

    playBtn.addEventListener("click", (e) => { e.preventDefault(); startGame(); });
    invClose.addEventListener("click", (e) => { e.preventDefault(); setInventory(false); resumeGameTryLock(); });
    if (tabInvBtn) tabInvBtn.addEventListener("click", (e) => { e.preventDefault(); invActiveTab = "inventory"; refreshInventoryUI(); });
    if (tabCreativeBtn) tabCreativeBtn.addEventListener("click", (e) => { e.preventDefault(); if (gameMode === "creative") { invActiveTab = "creative"; refreshInventoryUI(); searchEl && searchEl.focus(); } });
    renderer.domElement.addEventListener("mousedown", () => { if (gameActive() && !isLocked()) resumeGameTryLock(); });

    document.addEventListener("pointerlockchange", () => {
      if (isLocked()) lookMode = "pointerlock";
      else if (lookMode === "pointerlock" && gameActive()) setMenu(true);
      updateHelp();
    });
    document.addEventListener("pointerlockerror", () => { lookMode = "drag"; updateHelp(); });

    // ======================================================
    // Input
    // ======================================================
    const keys = new Set();

// Creative fly mode (double-tap Space to toggle)
let flyMode = false;
let lastSpaceTapTime = 0;
const DOUBLE_SPACE_MS = 260;
const FLY_SPEED_MULT = 3.0; // ~3x run speed (run = sprint speed)

function toggleFly() {
  if (gameMode !== "creative") return;
  flyMode = !flyMode;
  // Ensure stable transitions
  try { player.velY = 0; player.onGround = false; } catch(_) {}
  updateHelp();
}


// Mouse hold actions (continuous mine/place)
let lmbHeld = false;
let rmbHeld = false;
let lastMineTime = 0;
let lastPlaceTime = 0;
const MINE_INTERVAL_MS = 110;  // continuous mining rate
const PLACE_INTERVAL_MS = 120; // continuous placing rate


    window.addEventListener("keydown", (e) => {

// Chat toggle
if (chatOpen) {
  if (e.code === "Escape") { e.preventDefault(); setChat(false); return; }
  return; // don't feed movement/hotkeys while chatting
}
if (e.code === "KeyT") {
  e.preventDefault();
  keys.delete("KeyT");
  if (menuOverlay.style.display !== "none") return;
  if (inventoryOpen) return;
  setChat(true);
  return;
}

if (e.code === "KeyP") {
  e.preventDefault();
  keys.delete("KeyP");
  if (menuOverlay.style.display !== "none") return;
  if (inventoryOpen) return;
  cycleCamMode();
  return;
}

      if (e.code === "KeyE" || e.code === "Escape") e.preventDefault();
      keys.add(e.code);

      if (e.code === "KeyE") {
        keys.delete("KeyE");
        if (menuOverlay.style.display !== "none") return;
        setInventory(!inventoryOpen);
        if (!inventoryOpen) resumeGameTryLock();
        return;
      }

      if (e.code === "Escape" && !isLocked()) {
        keys.delete("Escape");
        if (inventoryOpen) { setInventory(false); resumeGameTryLock(); }
        else setMenu(true);
        return;
      }

      if (e.code.startsWith("Digit")) {
        const n = Number(e.code.slice(5));
        if (n >= 1 && n <= 9) selectHotbar(n - 1);
      }

      // Double-tap Space to toggle creative fly mode
      if (e.code === "Space" && !e.repeat && gameActive() && gameMode === "creative") {
        e.preventDefault();
        const now = performance.now();
        if (now - lastSpaceTapTime <= DOUBLE_SPACE_MS) {
          lastSpaceTapTime = 0;
          toggleFly();
        } else {
          lastSpaceTapTime = now;
        }
      }
    });
    window.addEventListener("keyup", (e) => keys.delete(e.code));
    window.addEventListener("contextmenu", (e) => e.preventDefault());

    window.addEventListener("mousemove", (e) => {
      if (!gameActive()) return;
      if (isLocked()) { rotateBy(e.movementX || 0, e.movementY || 0); return; }
      if (lookMode === "drag" && rmbDown) {
        const dx = (typeof e.movementX === "number") ? e.movementX : (e.clientX - lastX);
        const dy = (typeof e.movementY === "number") ? e.movementY : (e.clientY - lastY);
        lastX = e.clientX; lastY = e.clientY;
        rmbMoved += Math.abs(dx) + Math.abs(dy);
        rotateBy(dx, dy);
      }
    }, { passive: true });

    // ======================================================
    // Minecraft-ish fractal world gen (FBM + ridged noise)
    // - Much larger scale features (real mountains)
    // - Taller WORLD_H so peaks don't get squashed
    // - Column memo so meshing doesn't re-run noise per-voxel
    // ======================================================
        // World seed (random by default; set ?seed=12345 to reproduce)
    const WORLD_SEED = (() => {
      const qs = new URLSearchParams(location.search);
      const raw = qs.get("seed");

      function fnv1a32(str) {
        let h = 0x811c9dc5;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 0x01000193);
        }
        return h >>> 0;
      }

      if (raw !== null && raw !== "") {
        const n = Number(raw);
        if (Number.isFinite(n)) return (n >>> 0);
        return fnv1a32(raw);
      }

      try {
        const a = new Uint32Array(1);
        crypto.getRandomValues(a);
        return a[0] >>> 0;
      } catch (_) {
        return ((Date.now() ^ (Math.random() * 0xFFFFFFFF)) >>> 0);
      }
    })();


    
function smoothstep(edge0, edge1, x) {
  const t = clamp01((x - edge0) / (edge1 - edge0));
  return t * t * (3 - 2 * t);
}

function hash2i(x, z) {
      const SA = WORLD_SEED | 0;
      const SB = Math.imul(WORLD_SEED, 0x9e3779b9) | 0;
      let n = Math.imul(((x | 0) ^ SA), 374761393) + Math.imul(((z | 0) ^ SB), 668265263);
n = (n ^ (n >>> 13)) >>> 0;
      n = Math.imul(n, 1274126177) >>> 0;
      n = (n ^ (n >>> 16)) >>> 0;
      return n >>> 0;
    }
    function hash2f(x, z) { return hash2i(x, z) / 4294967295; }

    function hash3i(x, y, z) {
      // Mix 3D coords with WORLD_SEED (stable + fast)
      const SA = WORLD_SEED | 0;
      const SB = Math.imul(WORLD_SEED, 0x9e3779b9) | 0;
      const SC = Math.imul(WORLD_SEED ^ 0x85ebca6b, 0xc2b2ae35) | 0;
      let n =
        Math.imul(((x|0) ^ SA), 374761393) +
        Math.imul(((z|0) ^ SB), 668265263) +
        Math.imul(((y|0) ^ SC), 2147483647);
      n = (n ^ (n >>> 13)) >>> 0;
      n = Math.imul(n, 1274126177) >>> 0;
      n = (n ^ (n >>> 16)) >>> 0;
      return n >>> 0;
    }
    function hash3f(x, y, z) { return hash3i(x, y, z) / 4294967295; }


    function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    function grad2(h, x, y) {
      // 8-ish gradient directions (cheap + stable)
      switch (h & 7) {
        case 0: return  x + y;
        case 1: return -x + y;
        case 2: return  x - y;
        case 3: return -x - y;
        case 4: return  x;
        case 5: return -x;
        case 6: return  y;
        default: return -y;
      }
    }
    function grad3(h, x, y, z) {
      // 12-ish gradient directions
      switch (h & 15) {
        case 0:  return  x + y;
        case 1:  return -x + y;
        case 2:  return  x - y;
        case 3:  return -x - y;
        case 4:  return  x + z;
        case 5:  return -x + z;
        case 6:  return  x - z;
        case 7:  return -x - z;
        case 8:  return  y + z;
        case 9:  return -y + z;
        case 10: return  y - z;
        case 11: return -y - z;
        case 12: return  x + y;
        case 13: return -x + y;
        case 14: return  x - y;
        default: return -x - y;
      }
    }
    function perlin2(x, y) {
      const xi = Math.floor(x), yi = Math.floor(y);
      const xf = x - xi,      yf = y - yi;
      const u = fade(xf),     v = fade(yf);

      const aa = hash2i(xi,     yi);
      const ba = hash2i(xi + 1, yi);
      const ab = hash2i(xi,     yi + 1);
      const bb = hash2i(xi + 1, yi + 1);

      const x1 = lerp(grad2(aa, xf,     yf),     grad2(ba, xf - 1, yf),     u);
      const x2 = lerp(grad2(ab, xf,     yf - 1), grad2(bb, xf - 1, yf - 1), u);
      // roughly normalize into [-1,1]
      return lerp(x1, x2, v) * 0.70710678;
    }
    function perlin3(x, y, z) {
      const xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
      const xf = x - xi,      yf = y - yi,      zf = z - zi;
      const u = fade(xf),     v = fade(yf),     w = fade(zf);

      const aaa = hash3i(xi,     yi,     zi);
      const baa = hash3i(xi + 1, yi,     zi);
      const aba = hash3i(xi,     yi + 1, zi);
      const bba = hash3i(xi + 1, yi + 1, zi);
      const aab = hash3i(xi,     yi,     zi + 1);
      const bab = hash3i(xi + 1, yi,     zi + 1);
      const abb = hash3i(xi,     yi + 1, zi + 1);
      const bbb = hash3i(xi + 1, yi + 1, zi + 1);

      const x1 = lerp(grad3(aaa, xf,     yf,     zf),     grad3(baa, xf - 1, yf,     zf),     u);
      const x2 = lerp(grad3(aba, xf,     yf - 1, zf),     grad3(bba, xf - 1, yf - 1, zf),     u);
      const y1 = lerp(x1, x2, v);

      const x3 = lerp(grad3(aab, xf,     yf,     zf - 1), grad3(bab, xf - 1, yf,     zf - 1), u);
      const x4 = lerp(grad3(abb, xf,     yf - 1, zf - 1), grad3(bbb, xf - 1, yf - 1, zf - 1), u);
      const y2 = lerp(x3, x4, v);

      return lerp(y1, y2, w) * 0.70710678;
    }

    function fbm2(x, y, octaves = 5, lacunarity = 2.0, gain = 0.5) {
      let sum = 0, amp = 1, freq = 1, norm = 0;
      for (let i = 0; i < octaves; i++) {
        sum += amp * perlin2(x * freq, y * freq);
        norm += amp;
        amp *= gain;
        freq *= lacunarity;
      }
      return sum / (norm || 1);
    }
    function fbm3(x, y, z, octaves = 4, lacunarity = 2.0, gain = 0.5) {
      let sum = 0, amp = 1, freq = 1, norm = 0;
      for (let i = 0; i < octaves; i++) {
        sum += amp * perlin3(x * freq, y * freq, z * freq);
        norm += amp;
        amp *= gain;
        freq *= lacunarity;
      }
      return sum / (norm || 1);
    }

    function ridged2(x, y, octaves = 4, lacunarity = 2.0, gain = 0.55) {
      let sum = 0, amp = 0.9, freq = 1, norm = 0;
      for (let i = 0; i < octaves; i++) {
        let n = perlin2(x * freq, y * freq);
        n = 1.0 - Math.abs(n);
        n *= n;
        sum += n * amp;
        norm += amp;
        amp *= gain;
        freq *= lacunarity;
      }
      return sum / (norm || 1);
    }

    // Column memo to avoid doing noise repeatedly for each y in the same (x,z) column.
    // This keeps WORLD_H large without tanking chunk meshing.
    const BIOME = {
      PLAINS: 0,
      FOREST: 1,
      DESERT: 2,
      MOUNTAIN: 3,
      TAIGA: 4,
      SNOWY: 5,
      SWAMP: 6,
    };
    const columnMemo = new Map(); // "x,z" -> {top, biome, tree, cactus, riverMask, ravineMask, marker}

function getColumn(x, z) {
  const key = x + "," + z;
  let c = columnMemo.get(key);
  if (c) return c;

  // ==========================================================
  // Minecraft-ish terrain shaping (lite, but more faithful):
  // - "Continentalness" at very low frequency => big landmasses
  // - "Erosion" controls how rough/flat regions feel
  // - "Peaks" are a selective overlay so mountains aren't spammy
  // ==========================================================

  // Continentalness (big features, avoids "archipelago world")
  const cont = fbm2(x * 0.00055, z * 0.00055, 5, 2.02, 0.5); // ~[-1,1]
  let cont01 = (cont + 1) * 0.5; // [0,1]
  // Bias slightly toward land so the default isn't endless ocean.
  cont01 = clamp01(Math.pow(cont01, 0.62));

  // Land mask: 0 = open ocean, 1 = deep inland
  const land = smoothstep(0.36, 0.62, cont01);

  // Erosion (flat vs rugged)
  const eros = fbm2(x * 0.00105 + 190.0, z * 0.00105 - 75.0, 4, 2.0, 0.5); // ~[-1,1]
  const eros01 = (eros + 1) * 0.5;
  // rough=1 in low-erosion zones (rugged), rough=0 in high-erosion zones (flat)
  const rough = 1.0 - smoothstep(0.35, 0.78, eros01);

  // Mid-frequency hills/undulation
  const hills = fbm2(x * 0.0046, z * 0.0046, 5, 2.0, 0.5); // ~[-1,1]

  // Ridged peaks field (used only when the mountain mask allows)
  const ridBase = ridged2(x * 0.0026, z * 0.0026, 5, 2.0, 0.55); // [0,1]
  const ridSharp = Math.pow(ridBase, 1.9);

  // Temperature / moisture => base biomes
  const temp  = fbm2(x * 0.0012 + 100.0, z * 0.0012 - 40.0, 3, 2.0, 0.5);
  const moist = fbm2(x * 0.0012 - 50.0,  z * 0.0012 + 80.0, 3, 2.0, 0.5);
  const temp01 = (temp + 1) * 0.5;
  const moist01 = (moist + 1) * 0.5;
  const baseForest = (moist > 0.22); // forest coverage knob

  // Plains flatter than forests; both modulated by erosion.
  const baseHillsAmp = baseForest ? 38 : 16;
  const hillsAmp = baseHillsAmp * (0.45 + 0.55 * rough);

  // Mountain mask (rarer + prefers inland + prefers rugged zones)
  const m0 = fbm2(x * 0.00110 + 300.0, z * 0.00110 - 120.0, 3, 2.0, 0.5); // ~[-1,1]
  const m01 = (m0 + 1) * 0.5;
  let mMask = smoothstep(0.78, 0.93, m01);
  mMask = Math.pow(mMask, 2.2);
  // Keep mountains off coasts/ocean and bias them to rugged regions.
  mMask *= smoothstep(0.55, 0.98, land);
  mMask *= (0.35 + 0.65 * rough);

  // Breakup field: cut passes/valleys so ranges aren't continuous walls.
  const b0 = fbm2(x * 0.0017 - 50.0, z * 0.0017 + 90.0, 3, 2.0, 0.5); // ~[-1,1]
  const b01 = (b0 + 1) * 0.5;
  const gap = smoothstep(0.55, 0.80, b01);
  mMask *= (1.0 - gap * 0.75);

  // Base elevation:
  // - oceans have a floor below sea level
  // - inland rises gently above sea level to form continents, not islands
  const oceanFloor = -72; // below SEA_LEVEL (clamped later)
  const inlandRise = 34;  // above SEA_LEVEL
  let base = SEA_LEVEL + lerp(oceanFloor, inlandRise, land);

  // Final top height
  let top = Math.floor(
    base
    + hills * hillsAmp
    + (mMask * ridSharp) * 380
  );

  // Rivers/valleys: carve narrow channels so lowlands become water/sand corridors.
  const r0 = fbm2(x * 0.0022 + 900.0, z * 0.0022 - 600.0, 4, 2.0, 0.5); // ~[-1,1]
  const r01 = (r0 + 1) * 0.5;
  const riverMask = 1.0 - smoothstep(0.78, 0.92, r01); // 1 near "river line", 0 elsewhere
  const riverDepth = riverMask * 18;
  top = Math.floor(top - riverDepth);

  top = Math.max(1, Math.min(WORLD_H - 5, top));

  // Terrain class:
  // 0 plains, 1 forest, 2 desert, 3 mountains, 4 taiga, 5 snowy, 6 swamp
  let biome = baseForest ? BIOME.FOREST : BIOME.PLAINS;
  if (temp01 > 0.72 && moist01 < 0.32) biome = BIOME.DESERT;
  else if (temp01 < 0.18) biome = BIOME.SNOWY;
  else if (temp01 < 0.35) biome = BIOME.TAIGA;
  else if (moist01 > 0.78 && land > 0.35 && top <= SEA_LEVEL + 10) biome = BIOME.SWAMP;

  // Mountains only on sharp/high ridgelines.
  const isMountainPeak = (mMask > 0.50) && (ridSharp > 0.66) && (top > SEA_LEVEL + 22);
  if (isMountainPeak) biome = BIOME.MOUNTAIN;

  // Hilliness proxy: helps place "rare trees on hills" while keeping plains mostly empty.
  const hilliness = clamp01(Math.abs(hills) * 0.55 + ridSharp * 0.55);

  // Trees (avoid mountains + avoid underwater)
  let tree = null;
  let cactus = null;
  if (top >= SEA_LEVEL + 1 && top <= WORLD_H - 10) {
    const r = hash2f(x * 3, z * 3);
    if (biome === BIOME.DESERT) {
      const p = 0.010;
      if (r < p) {
        const height = 2 + Math.floor(hash2f(x + 17, z - 9) * 3); // 2..4
        cactus = { top, height };
      }
    } else if (biome !== BIOME.MOUNTAIN) {
      // Prefer hills: plains almost bare; hills have rare trees; forests still have more (but not spammy).
      const hillOK = (hilliness > 0.40);
      let p = 0.0014; // very rare on flat plains
      let type = "oak";
      if (biome === BIOME.FOREST) { p = 0.020; type = "oak"; }
      else if (biome === BIOME.TAIGA) { p = 0.016; type = "pine"; }
      else if (biome === BIOME.SNOWY) { p = 0.008; type = "pine"; }
      else if (biome === BIOME.SWAMP) { p = 0.018; type = "swamp"; }
      else if (hillOK) { p = 0.010; type = "oak"; }

      if (r < p) {
        let trunkH = 4 + Math.floor(hash2f(x - 11, z + 7) * 4); // 4..7
        if (type === "pine") trunkH = 6 + Math.floor(hash2f(x + 13, z + 5) * 5); // 6..10
        if (type === "swamp") trunkH = 3 + Math.floor(hash2f(x - 21, z + 3) * 3); // 3..5
        const ly = Math.min(WORLD_H - 2, top + trunkH);
        tree = { top, trunkH, ly, type };
      }
    }
  }

  let marker = null;
  if (!tree && !cactus && top >= SEA_LEVEL + 2 && hash2f(x * 19, z * 19) < 0.00018) {
    marker = { y: top + 1 };
  }

  const rav0 = fbm2(x * 0.0036 + 1200.0, z * 0.0036 - 500.0, 3, 2.0, 0.5);
  const rav01 = (rav0 + 1) * 0.5;
  const ravineMask = 1.0 - smoothstep(0.82, 0.94, rav01);

  c = { top, biome, tree, cactus, riverMask, ravineMask, marker };
  columnMemo.set(key, c);
  if (columnMemo.size > 60000) columnMemo.clear(); // bounded memory, deterministic refill
  return c;
}

    function surfaceY(x, z) { return getColumn(x, z).top; }
    function treeInfo(tx, tz) { return getColumn(tx, tz).tree; }

    function baseBlockAt(x, y, z) {
      if (y < 0 || y >= WORLD_H) return B.AIR;
      if (y === 0) return B.BEDROCK;

      function oreInStone() {
        // Only replace stone/cobble layers (not dirt/sand/etc). Simple depth-biased distribution.
        const r = hash3f(x, y, z);
        if (y <= 12 && r < 0.0045) return B.DIAMOND_ORE;
        if (y <= 26 && r < 0.0075) return B.GOLD_ORE;
        if (y <= 54 && r < 0.0150) return B.IRON_ORE;
        if (y <= 92 && r < 0.0220) return B.COAL_ORE;
        return oreInStone();
      }

      const col = getColumn(x, z);
      const top = col.top;
      const biome = col.biome;

      if (col.marker && y === col.marker.y) return B.BRICKS;

      // trunk
      const ti = col.tree;
      if (ti && y > ti.top && y <= ti.top + ti.trunkH) return B.LOG;

      // leaves (keep the previous "plus" canopy style)
      if (y >= 4) {
        for (let dz = -2; dz <= 2; dz++) {
          for (let dx = -2; dx <= 2; dx++) {
            const tx = x + dx;
            const tz = z + dz;
            const inf = treeInfo(tx, tz);
            if (!inf) continue;
            const adx = Math.abs(dx);
            const adz = Math.abs(dz);
            const treeType = inf.type || "oak";
            if (treeType === "pine") {
              const relY = y - (inf.top + inf.trunkH);
              if (relY <= 0 && relY >= -3) {
                const radius = 2 - Math.abs(relY);
                if (adx <= radius && adz <= radius && (adx + adz) > 0) return B.LEAVES;
              }
              continue;
            }
            if (treeType === "swamp") {
              const canopyY = inf.top + inf.trunkH;
              if (y === canopyY || y === canopyY - 1) {
                if (adx <= 2 && adz <= 2 && (adx + adz) > 0) return B.LEAVES;
              } else if (y === canopyY - 2) {
                if (adx <= 1 && adz <= 1 && (adx + adz) > 0) return B.LEAVES;
              }
              continue;
            }
            if (y !== inf.ly) continue;
            if ((adx === 0 && adz <= 1) || (adz === 0 && adx <= 1)) {
              if (!(adx === 0 && adz === 0)) return B.LEAVES;
            }
          }
        }
      }

      if (col.cactus && y > col.cactus.top && y <= col.cactus.top + col.cactus.height) {
        return B.WOOL_GREEN;
      }

      // above ground
      if (y > top) {
        // oceans/lakes: fill up to SEA_LEVEL
        if (top < SEA_LEVEL && y <= SEA_LEVEL) return B.WATER;
        return B.AIR;
      }

      const beach = (top <= SEA_LEVEL + 1);

      if (col.riverMask > 0.68 && y >= SEA_LEVEL - 2) {
        if (y <= SEA_LEVEL) return B.WATER;
        return B.AIR;
      }

      if (col.ravineMask > 0.70 && y < top && y >= Math.max(2, top - 44)) {
        const depthT = (y - (top - 44)) / 44;
        const width = 0.7 - depthT * 0.45;
        const r = Math.abs(fbm2(x * 0.02 + 200.0, z * 0.02 - 350.0, 2, 2.0, 0.5));
        if (r > width) return (y <= SEA_LEVEL ? B.WATER : B.AIR);
      }

      if (y < SEA_LEVEL - 4 && y > 2) {
        const cave = fbm3(x * 0.055, y * 0.055, z * 0.055, 3, 2.2, 0.5);
        const pocket = fbm3(x * 0.11 + 50.0, y * 0.11, z * 0.11 - 20.0, 2, 2.0, 0.5);
        if (cave > 0.28 && pocket > 0.05) return B.AIR;
      }

      const surface =
        beach ? B.SAND :
        (biome === BIOME.MOUNTAIN ? B.COBBLE :
          biome === BIOME.DESERT ? B.SAND :
          biome === BIOME.SNOWY ? B.WOOL_WHITE :
          biome === BIOME.SWAMP ? B.DIRT :
          B.GRASS);

      if (y === top) return surface;

      const depth = top - y;

      // sands: deeper sand before stone
      if (surface === B.SAND) {
        if (depth <= 4) return B.SAND;
        return B.COBBLE;
      }

      // mountains: more stone showing
      if (biome === BIOME.MOUNTAIN) {
        if (depth <= 1) return B.COBBLE;
        if (depth <= 3) return B.DIRT;
        return B.COBBLE;
      }

      // plains/forest
      if (surface === B.WOOL_WHITE) {
        if (depth <= 2) return B.DIRT;
        return B.COBBLE;
      }
      if (depth <= 2) return B.DIRT;
      return B.COBBLE;
    }


    // ======================================================
    // Chunk edits only (infinite world persistence in-memory)
    // ======================================================
    const chunkEdits = new Map(); // "cx,cz" -> Map(localIndex -> blockId)
    const chunkEditMaxY = new Map(); // \"cx,cz\" -> highest edited Y (for mesh scan cap)
    function chunkKey(cx, cz) { return cx + "," + cz; }

    function floorDiv(a, b) {
      const q = Math.trunc(a / b);
      return (a < 0 && a % b !== 0) ? (q - 1) : q;
    }
    function mod(a, b) {
      const m = a % b;
      return m < 0 ? m + b : m;
    }
    function localIndex(lx, y, lz) {
      return (y * CHUNK + lz) * CHUNK + lx;
    }

    function getEdit(cx, cz, lx, y, lz) {
      const m = chunkEdits.get(chunkKey(cx, cz));
      if (!m) return null;
      const v = m.get(localIndex(lx, y, lz));
      return (v === undefined) ? null : v;
    }

    function setEdit(wx, y, wz, blockId) {
      const cx = floorDiv(wx, CHUNK);
      const cz = floorDiv(wz, CHUNK);
      const lx = mod(wx, CHUNK);
      const lz = mod(wz, CHUNK);
      const key = chunkKey(cx, cz);
      let m = chunkEdits.get(key);
      if (!m) { m = new Map(); chunkEdits.set(key, m); }
      m.set(localIndex(lx, y, lz), blockId);
      // Track highest edited altitude so chunk meshing doesn't scan empty sky.
      if (blockId !== B.AIR) {
        const prev = chunkEditMaxY.get(key);
        if (prev === undefined || y > prev) chunkEditMaxY.set(key, y);
      }
    }

    function getBlock(wx, y, wz) {
      if (y < 0 || y >= WORLD_H) return B.AIR;
      const cx = floorDiv(wx, CHUNK);
      const cz = floorDiv(wz, CHUNK);
      const lx = mod(wx, CHUNK);
      const lz = mod(wz, CHUNK);
      const ev = getEdit(cx, cz, lx, y, lz);
      if (ev !== null) return ev;
      return baseBlockAt(wx, y, wz);
    }

    function isSolid(t) { return t !== B.AIR; }

    // Blocks that are visually "non-occluding" (you should still see blocks behind them).
    // If we treat these as fully solid for chunk exposure tests, blocks behind glass/water/lava
    // can disappear from the mesh and look like "x-ray" glitches.
    function isTransparentBlock(t) {
      return (t === B.GLASS || t === B.WATER || t === B.LAVA);
    }
    function occludesFace(cur, neigh) {
      // true means "neigh hides cur's face between the two blocks"
      if (!isSolid(neigh)) return false;

      const curTrans = isTransparentBlock(cur);
      const neighTrans = isTransparentBlock(neigh);

      if (!curTrans) {
        // Opaque blocks should still show faces next to transparent blocks (glass/water/lava),
        // so only opaque neighbors occlude.
        return !neighTrans;
      }

      // Transparent blocks: opaque neighbors occlude them (water against stone shouldn't draw an interior face).
      if (!neighTrans) return true;

      // Two transparent blocks only occlude if they're the same "medium" (water-water, glass-glass, lava-lava).
      return neigh === cur;
    }

    // ======================================================
    // Entities (targets + mobs)
    // ======================================================
    const entityGroup = new THREE.Group();
    scene.add(entityGroup);

    const ENTITY_TYPES = {
      target: { name: "Target Dummy", kind: "target", color: 0xffd27a, size: { w: 0.8, h: 1.4, d: 0.5 }, health: 14 },
      hostile: { name: "Hostile Slime", kind: "hostile", color: 0xff6b6b, size: { w: 0.9, h: 0.9, d: 0.9 }, health: 10 },
      passive: { name: "Passive Moo", kind: "passive", color: 0x7ee081, size: { w: 1.0, h: 1.0, d: 1.2 }, health: 12 },
    };

    const entities = [];
    let nextEntityId = 1;

    function groundYAt(wx, wz) {
      for (let y = WORLD_H - 2; y >= 0; y--) {
        if (isSolid(getBlock(wx, y, wz))) return y + 1;
      }
      return SEA_LEVEL + 1;
    }

    function spawnEntity(typeKey, wx, wz) {
      const def = ENTITY_TYPES[typeKey];
      if (!def) return null;
      const y = groundYAt(wx, wz);
      const size = new THREE.Vector3(def.size.w, def.size.h, def.size.d);
      const pos = new THREE.Vector3(wx, y, wz);
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(size.x, size.y, size.z),
        new THREE.MeshStandardMaterial({ color: def.color, roughness: 0.8, metalness: 0.05 })
      );
      mesh.position.set(pos.x, pos.y + size.y / 2, pos.z);
      mesh.castShadow = false;
      mesh.receiveShadow = true;
      entityGroup.add(mesh);
      const ent = {
        id: nextEntityId++,
        type: typeKey,
        kind: def.kind,
        name: def.name,
        pos,
        size,
        health: def.health,
        maxHealth: def.health,
        mesh,
      };
      entities.push(ent);
      return ent;
    }

    function removeEntity(ent) {
      const idx = entities.indexOf(ent);
      if (idx !== -1) entities.splice(idx, 1);
      if (ent.mesh) entityGroup.remove(ent.mesh);
    }

    function entityAabb(ent) {
      const halfX = ent.size.x * 0.5;
      const halfZ = ent.size.z * 0.5;
      const min = new THREE.Vector3(ent.pos.x - halfX, ent.pos.y, ent.pos.z - halfZ);
      const max = new THREE.Vector3(ent.pos.x + halfX, ent.pos.y + ent.size.y, ent.pos.z + halfZ);
      return { min, max };
    }

    // ======================================================
    // Chunk objects + meshing (faster build via local voxel cache)
    // ======================================================
    const chunks = new Map(); // key -> {cx,cz, meshes:[]}

    function disposeChunk(chunk) {
      for (const m of chunk.meshes) {
        scene.remove(m);
        // Only dispose geometries that are generated per-chunk (face-only transparent meshes).
        if (m && m.userData && m.userData._chunkGeo && m.geometry) {
          try { m.geometry.dispose(); } catch (_) {}
        }
      }
      chunk.meshes.length = 0;
    }

function estimateChunkYMax(cx, cz) {
  const wx0 = cx * CHUNK;
  const wz0 = cz * CHUNK;

  // Always include at least around sea level so shores/water surface mesh correctly.
  let maxY = SEA_LEVEL + 10;

  for (let lz=0; lz<CHUNK; lz++) for (let lx=0; lx<CHUNK; lx++) {
    const wx = wx0 + lx;
    const wz = wz0 + lz;
    const col = getColumn(wx, wz);
    let t = col.top;
    if (col.tree) t = Math.max(t, col.top + col.tree.trunkH + 4);
    if (t > maxY) maxY = t;
  }

  const k = chunkKey(cx, cz);
  const editMax = chunkEditMaxY.get(k);
  if (editMax !== undefined) maxY = Math.max(maxY, editMax + 3);

  // Margin for player edits / overhangs (cheap safety).
  maxY = Math.min(WORLD_H - 1, maxY + 6);
  maxY = Math.max(24, maxY);
  return maxY | 0;
}

        function buildChunkMeshes(cx, cz) {
      const wx0 = cx * CHUNK;
      const wz0 = cz * CHUNK;

      // cache voxel values for the chunk (avoid scanning empty sky)
      const yMax = estimateChunkYMax(cx, cz);

      // cache voxel values for the chunk (16*16*(H) = small, avoids scanning empty sky)
      const H = Math.min(WORLD_H, yMax + 3);
      const data = new Uint8Array(CHUNK * CHUNK * H);
      const idx = (lx, lz, y) => (y * CHUNK + lz) * CHUNK + lx;

      for (let y=0; y<H; y++) {
        for (let lz=0; lz<CHUNK; lz++) for (let lx=0; lx<CHUNK; lx++) {
          const wx = wx0 + lx;
          const wz = wz0 + lz;
          data[idx(lx,lz,y)] = getBlock(wx, y, wz);
        }
      }

      function getLocal(lx,lz,y){
        if (y < 0) return B.AIR;
        if (lx>=0 && lx<CHUNK && lz>=0 && lz<CHUNK && y>=0 && y<H) return data[idx(lx,lz,y)];
        // neighbor chunk OR above cached range
        const wx = wx0 + lx;
        const wz = wz0 + lz;
        return getBlock(wx, y, wz);
      }

      // ------------------------------------------------------
      // Opaque blocks: keep instancing (fast)
      // Transparent blocks (glass/water/lava): build face-only meshes
      // so sides between adjacent transparent blocks are never visible.
      // ------------------------------------------------------

      const positions = new Map(); // opaque id -> array of {x,y,z}

      // face-only buffers for transparent blocks
      function makeBuf(){ return { pos: [], norm: [], uv: [], idx: [], v: 0 }; }
      const tbuf = new Map([
        [B.GLASS, makeBuf()],
        [B.WATER, makeBuf()],
        [B.LAVA,  makeBuf()],
      ]);

      // Transparent face visibility:
      // - Glass never draws internal faces against any solid neighbor (prevents "cross-transparency" holes).
      // - Water/Lava draw faces against AIR and against GLASS so they remain visible behind glass.
      // - Water beats Lava at water-lava boundaries to avoid coplanar z-fighting artifacts.
      function transFaceVisible(cur, neigh) {
        if (neigh === B.AIR) return true;

        if (cur === B.GLASS) return false;

        if (cur === B.WATER) {
          if (neigh === B.WATER) return false;
          if (neigh === B.LAVA)  return true;   // water wins boundary
          if (neigh === B.GLASS) return true;   // visible behind glass
          return false; // against opaque solids: hidden
        }

        if (cur === B.LAVA) {
          if (neigh === B.LAVA)  return false;
          if (neigh === B.WATER) return false;  // water wins boundary
          if (neigh === B.GLASS) return true;   // visible behind glass
          return false;
        }

        return false;
      }

      function pushFace(buf, x, y, z, face, tileIdx) {
        const r = tileUVRect(tileIdx);
        let nx=0, ny=0, nz=0;

        // 4 vertices per face (positions)
        // Vertex order is chosen so triangles are CCW when viewed from outside.
        let v0, v1, v2, v3;
        switch (face) {
          case 0: // +X
            nx=1;
            v0=[x+1, y+1, z  ]; v1=[x+1, y+1, z+1]; v2=[x+1, y,   z  ]; v3=[x+1, y,   z+1];
            break;
          case 1: // -X
            nx=-1;
            v0=[x, y+1, z+1]; v1=[x, y+1, z  ]; v2=[x, y,   z+1]; v3=[x, y,   z  ];
            break;
          case 2: // +Y (top)
            ny=1;
            // IMPORTANT: winding must be CCW when viewed from above (+Y), otherwise the face is back-culled.
            v0=[x,   y+1, z+1]; v1=[x+1, y+1, z+1]; v2=[x,   y+1, z  ]; v3=[x+1, y+1, z  ];
            break;
          case 3: // -Y (bottom)
            ny=-1;
            // CCW when viewed from below (-Y).
            v0=[x,   y, z  ]; v1=[x+1, y, z  ]; v2=[x,   y, z+1]; v3=[x+1, y, z+1];
            break;
          case 4: // +Z
            nz=1;
            v0=[x+1, y+1, z+1]; v1=[x,   y+1, z+1]; v2=[x+1, y,   z+1]; v3=[x,   y,   z+1];
            break;
          default: // 5 -Z
            nz=-1;
            v0=[x,   y+1, z  ]; v1=[x+1, y+1, z  ]; v2=[x,   y,   z  ]; v3=[x+1, y,   z  ];
            break;
        }

        const base = buf.v;

        buf.pos.push(...v0, ...v1, ...v2, ...v3);
        for (let i=0;i<4;i++) buf.norm.push(nx,ny,nz);

        // UVs: (u0,v1) (u1,v1) (u0,v0) (u1,v0)
        buf.uv.push(r.u0, r.v1,  r.u1, r.v1,  r.u0, r.v0,  r.u1, r.v0);

        // two triangles
        buf.idx.push(base, base+1, base+2,  base+2, base+1, base+3);

        buf.v += 4;
      }

      for (let lz=0; lz<CHUNK; lz++) for (let lx=0; lx<CHUNK; lx++) {
        const wx = wx0 + lx;
        const wz = wz0 + lz;

        for (let y=0; y<=yMax; y++) {
          const t = getLocal(lx,lz,y);
          if (!isSolid(t)) continue;

          // Transparent blocks: draw only faces that are actually visible (AIR, and fluids behind glass).
          if (isTransparentBlock(t)) {
            const buf = tbuf.get(t);
            if (!buf) continue;

            const tiles = faceTilesFor.get(t) || faceTilesFor.get(B.DIRT);

            // Neighbor offsets in the same face order as the tile array:
            // 0 +x, 1 -x, 2 +y, 3 -y, 4 +z, 5 -z
            const n0 = getLocal(lx+1,lz,y);
            const n1 = getLocal(lx-1,lz,y);
            const n2 = getLocal(lx,lz,y+1);
            const n3 = getLocal(lx,lz,y-1);
            const n4 = getLocal(lx,lz+1,y);
            const n5 = getLocal(lx,lz-1,y);

            if (transFaceVisible(t, n0)) pushFace(buf, wx, y, wz, 0, tiles[0]);
            if (transFaceVisible(t, n1)) pushFace(buf, wx, y, wz, 1, tiles[1]);
            if (transFaceVisible(t, n2)) pushFace(buf, wx, y, wz, 2, tiles[2]);
            if (transFaceVisible(t, n3)) pushFace(buf, wx, y, wz, 3, tiles[3]);
            if (transFaceVisible(t, n4)) pushFace(buf, wx, y, wz, 4, tiles[4]);
            if (transFaceVisible(t, n5)) pushFace(buf, wx, y, wz, 5, tiles[5]);

            continue;
          }

          // Opaque blocks: keep the existing "exposed block" test and instancing.
          const exposed =
            !occludesFace(t, getLocal(lx+1,lz,y)) || !occludesFace(t, getLocal(lx-1,lz,y)) ||
            !occludesFace(t, getLocal(lx,lz,y+1)) || !occludesFace(t, getLocal(lx,lz,y-1)) ||
            !occludesFace(t, getLocal(lx,lz+1,y)) || !occludesFace(t, getLocal(lx,lz-1,y));

          if (!exposed) continue;

          if (!positions.has(t)) positions.set(t, []);
          positions.get(t).push({x: wx, y, z: wz});
        }
      }

      const meshes = [];
      const mtx = new THREE.Matrix4();

      // Opaque instanced meshes
      for (const [id, list] of positions.entries()) {
        const g = geomFor.get(id) || geomFor.get(B.DIRT);
        const mat = materialFor(id);
        const mesh = new THREE.InstancedMesh(g, mat, list.length);
        mesh.frustumCulled = true;
        for (let i=0; i<list.length; i++) {
          const p = list[i];
          mtx.makeTranslation(p.x + 0.5, p.y + 0.5, p.z + 0.5);
          mesh.setMatrixAt(i, mtx);
        }
        mesh.instanceMatrix.needsUpdate = true;
        meshes.push(mesh);
      }

      // Transparent face-only meshes
      function makeMeshFromBuf(id, buf) {
        if (!buf || buf.v === 0) return null;
        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.BufferAttribute(new Float32Array(buf.pos), 3));
        g.setAttribute("normal",   new THREE.BufferAttribute(new Float32Array(buf.norm), 3));
        g.setAttribute("uv",       new THREE.BufferAttribute(new Float32Array(buf.uv), 2));
        // indices
        const IndexArr = (buf.v > 65535) ? Uint32Array : Uint16Array;
        g.setIndex(new THREE.BufferAttribute(new IndexArr(buf.idx), 1));
        g.computeBoundingSphere();
        const mesh = new THREE.Mesh(g, materialFor(id));
        mesh.userData._chunkGeo = true;
        mesh.frustumCulled = true;
        return mesh;
      }

      for (const [id, buf] of tbuf.entries()) {
        const mesh = makeMeshFromBuf(id, buf);
        if (mesh) meshes.push(mesh);
      }

      return meshes;
    }

    function loadChunk(cx, cz) {
      const key = chunkKey(cx, cz);
      if (chunks.has(key)) return;
      const chunk = { cx, cz, meshes: [] };
      chunk.meshes = buildChunkMeshes(cx, cz);
      for (const m of chunk.meshes) scene.add(m);
      chunks.set(key, chunk);
    }

    function rebuildChunk(cx, cz) {
      const key = chunkKey(cx, cz);
      const chunk = chunks.get(key);
      if (!chunk) return;
      disposeChunk(chunk);
      chunk.meshes = buildChunkMeshes(cx, cz);
      for (const m of chunk.meshes) scene.add(m);
    }

    function markChunksDirtyForBlock(wx, wz) {
      const cx = floorDiv(wx, CHUNK);
      const cz = floorDiv(wz, CHUNK);
      rebuildChunk(cx, cz);

      const lx = mod(wx, CHUNK);
      const lz = mod(wz, CHUNK);
      if (lx === 0) rebuildChunk(cx - 1, cz);
      if (lx === CHUNK - 1) rebuildChunk(cx + 1, cz);
      if (lz === 0) rebuildChunk(cx, cz - 1);
      if (lz === CHUNK - 1) rebuildChunk(cx, cz + 1);
    }

    function updateChunkStreaming(playerX, playerZ) {
      const pcx = floorDiv(Math.floor(playerX), CHUNK);
      const pcz = floorDiv(Math.floor(playerZ), CHUNK);

      const want = new Set();
      for (let dz=-RADIUS; dz<=RADIUS; dz++) for (let dx=-RADIUS; dx<=RADIUS; dx++) {
        want.add(chunkKey(pcx + dx, pcz + dz));
      }

      // unload
      for (const [key, chunk] of chunks.entries()) {
        if (!want.has(key)) {
          disposeChunk(chunk);
          chunks.delete(key);
        }
      }

      // load missing nearest-first (limited per frame)
      const missing = [];
      for (let dz=-RADIUS; dz<=RADIUS; dz++) for (let dx=-RADIUS; dx<=RADIUS; dx++) {
        const cx = pcx + dx, cz = pcz + dz;
        const key = chunkKey(cx, cz);
        if (!chunks.has(key)) missing.push({cx, cz, d2: dx*dx + dz*dz});
      }
      missing.sort((a,b) => a.d2 - b.d2);

      for (let i=0; i<Math.min(MAX_LOADS_PER_FRAME, missing.length); i++) {
        loadChunk(missing[i].cx, missing[i].cz);
      }
    }

    // ======================================================
    // Highlight
    // ======================================================
    const highlight = new THREE.Mesh(
      new THREE.BoxGeometry(1.01, 1.01, 1.01),
      new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.35 })
    );
    highlight.visible = false;
    scene.add(highlight);

    function blockCenter(x,y,z) { return new THREE.Vector3(x+0.5, y+0.5, z+0.5); }

    // ======================================================
    // Fast voxel raycast (DDA): replaces Three.js raycaster
    // ======================================================
    function voxelRaycast(origin, dir, maxDist) {
      // origin: Vector3; dir: normalized Vector3
      let x = Math.floor(origin.x);
      let y = Math.floor(origin.y);
      let z = Math.floor(origin.z);

      const stepX = dir.x > 0 ? 1 : -1;
      const stepY = dir.y > 0 ? 1 : -1;
      const stepZ = dir.z > 0 ? 1 : -1;

      const tDeltaX = dir.x === 0 ? 1e30 : Math.abs(1 / dir.x);
      const tDeltaY = dir.y === 0 ? 1e30 : Math.abs(1 / dir.y);
      const tDeltaZ = dir.z === 0 ? 1e30 : Math.abs(1 / dir.z);

      const nextVoxelBoundary = (p, i, step) => step > 0 ? (i + 1) : i; // boundary coordinate
      let tMaxX = dir.x === 0 ? 1e30 : (nextVoxelBoundary(origin.x, x, stepX) - origin.x) / dir.x;
      let tMaxY = dir.y === 0 ? 1e30 : (nextVoxelBoundary(origin.y, y, stepY) - origin.y) / dir.y;
      let tMaxZ = dir.z === 0 ? 1e30 : (nextVoxelBoundary(origin.z, z, stepZ) - origin.z) / dir.z;

      // If we start inside a solid block, count it.
      if (y >= 0 && y < WORLD_H && isSolid(getBlock(x,y,z))) {
        return { x, y, z, nx: 0, ny: 0, nz: 0, dist: 0 };
      }

      let nx=0, ny=0, nz=0;
      let t = 0;

      // upper bound on steps
      const maxSteps = 256;
      for (let i=0; i<maxSteps; i++) {
        if (t > maxDist) break;

        if (tMaxX < tMaxY && tMaxX < tMaxZ) {
          x += stepX;
          t = tMaxX;
          tMaxX += tDeltaX;
          nx = -stepX; ny = 0; nz = 0;
        } else if (tMaxY < tMaxZ) {
          y += stepY;
          t = tMaxY;
          tMaxY += tDeltaY;
          nx = 0; ny = -stepY; nz = 0;
        } else {
          z += stepZ;
          t = tMaxZ;
          tMaxZ += tDeltaZ;
          nx = 0; ny = 0; nz = -stepZ;
        }

        if (y < 0 || y >= WORLD_H) continue;
        const b = getBlock(x, y, z);
        if (isSolid(b)) {
          return { x, y, z, nx, ny, nz, dist: t };
        }
      }
      return null;
    }

    // ======================================================
    // Player physics
    // ======================================================
    const player = { pos: new THREE.Vector3(0.5, WORLD_H - 4, 0.5), velY: 0, onGround: false, crouching: false };

    
// Collision: water/lava are non-colliding so you can swim through them.
function isCollidable(t) { return (t !== B.AIR && t !== B.WATER && t !== B.LAVA); }

function currentHeight() { return player.crouching ? PLAYER.crouchHeight : PLAYER.height; }
function currentEye() { return player.crouching ? PLAYER.crouchEye : PLAYER.eye; }

function aabbCollidesAt(feetPos, h) {
  const r=PLAYER.radius;
  const minX=feetPos.x-r, maxX=feetPos.x+r;
  const minY=feetPos.y,   maxY=feetPos.y+h;
  const minZ=feetPos.z-r, maxZ=feetPos.z+r;

  const x0=Math.floor(minX), x1=Math.floor(maxX);
  const y0=Math.floor(minY), y1=Math.floor(maxY);
  const z0=Math.floor(minZ), z1=Math.floor(maxZ);

  for (let x=x0; x<=x1; x++) for (let y=y0; y<=y1; y++) for (let z=z0; z<=z1; z++) {
    const t = getBlock(x,y,z);
    if (!isCollidable(t)) continue;
    if ((minX < x+1 && maxX > x) && (minY < y+1 && maxY > y) && (minZ < z+1 && maxZ > z)) return true;
  }
  return false;
}

function aabbCollides(feetPos) { return aabbCollidesAt(feetPos, currentHeight()); }

function tryMoveAxis(axis, amount) {
  if (!amount) return false;
  player.pos[axis] += amount;
  if (aabbCollides(player.pos)) { player.pos[axis] -= amount; return true; }
  return false;
}

function playerOverlapsBlock(x,y,z) {
  const r=PLAYER.radius, h=currentHeight();
  const minX=player.pos.x-r, maxX=player.pos.x+r;
  const minY=player.pos.y,   maxY=player.pos.y+h;
  const minZ=player.pos.z-r, maxZ=player.pos.z+r;
  return (minX < x+1 && maxX > x) && (minY < y+1 && maxY > y) && (minZ < z+1 && maxZ > z);
}

function getPlayerFluidState() {
  const r=PLAYER.radius, h=currentHeight();
  const minX=player.pos.x-r, maxX=player.pos.x+r;
  const minY=player.pos.y,   maxY=player.pos.y+h;
  const minZ=player.pos.z-r, maxZ=player.pos.z+r;

  const x0=Math.floor(minX), x1=Math.floor(maxX);
  const y0=Math.floor(minY), y1=Math.floor(maxY);
  const z0=Math.floor(minZ), z1=Math.floor(maxZ);

  let water = false, lava = false;
  for (let x=x0; x<=x1; x++) for (let y=y0; y<=y1; y++) for (let z=z0; z<=z1; z++) {
    const t = getBlock(x,y,z);
    if (t === B.WATER) water = true;
    else if (t === B.LAVA) lava = true;
    if (water && lava) return { water, lava };
  }
  return { water, lava };
}

function syncCamera() { camera.position.set(player.pos.x, player.pos.y + currentEye(), player.pos.z); }
syncCamera();
    applyLook();

    // Spawn demo entities near the player spawn.
    spawnEntity("target", Math.round(player.pos.x + 3), Math.round(player.pos.z + 2));
    spawnEntity("hostile", Math.round(player.pos.x - 4), Math.round(player.pos.z + 1));
    spawnEntity("passive", Math.round(player.pos.x + 2), Math.round(player.pos.z - 4));

    // ======================================================
// Inventory (Minecraft-ish stacks)
// ======================================================
const HOTBAR_SIZE = 9;
const INV_SIZE = 36; // 9 hotbar + 27 main
const STACK_MAX = 64;

// Each slot is null or { id:number, count:number }
const invSlots = new Array(INV_SIZE).fill(null);
let hotbarIndex = 0;

// Cursor stack for click/drag moving (only active while inventory is open)
let cursorStack = null;

// Inventory/creative tabs
let invActiveTab = "inventory"; // "inventory" | "creative"
const CREATIVE_CATS = [
  { key: "building", label: "Building" },
  { key: "nature", label: "Nature" },
  { key: "decoration", label: "Decor" },
  { key: "ores", label: "Ores" },
  { key: "functional", label: "Functional" },
  { key: "tools", label: "Tools" },
];
let creativeCat = "building";


function normItem(it) {
  if (!it) return null;
  const id = (it.id|0);
  const count = (it.count|0);
  if (id === B.AIR || count <= 0) return null;
  const maxDur = maxDurabilityFor(id);
  const rawDur = (typeof it.durability === "number") ? it.durability : maxDur;
  const durability = maxDur > 0 ? Math.max(1, Math.min(maxDur, rawDur)) : 0;
  return { id, count: Math.min(STACK_MAX, count), durability: durability || undefined };
}
function slotId(i) { return invSlots[i]?.id ?? B.AIR; }
function slotCount(i) { return invSlots[i]?.count ?? 0; }
function slotDurability(i) { return invSlots[i]?.durability ?? 0; }

function setSlot(i, it) {
  invSlots[i] = normItem(it);
}

function selectedItem() { return invSlots[hotbarIndex]; }
function isToolId(id) { return id >= B.WOODEN_SWORD && id <= B.DIAMOND_HOE; }
function isPlaceableId(id) { return !isToolId(id); }

function damageSelectedWeapon(amount = 1) {
  const s = invSlots[hotbarIndex];
  if (!s) return;
  const maxDur = maxDurabilityFor(s.id);
  if (!maxDur) return;
  if (typeof s.durability !== "number") s.durability = maxDur;
  s.durability -= amount;
  if (s.durability <= 0) {
    s.count -= 1;
    if (s.count <= 0) {
      invSlots[hotbarIndex] = null;
    } else {
      s.durability = maxDur;
    }
  }
}

function selectedBlock() {
  if (slotCount(hotbarIndex) <= 0) return B.AIR;
  const id = slotId(hotbarIndex);
  return isPlaceableId(id) ? id : B.AIR;
}

function addToInventory(blockId, count) {
  let left = Math.max(0, count|0);
  if (!left || blockId === B.AIR) return 0;

  // Merge into existing stacks first.
  for (let i=0;i<INV_SIZE && left>0;i++) {
    const s = invSlots[i];
    if (!s || s.id !== blockId || s.count >= STACK_MAX) continue;
    const can = Math.min(STACK_MAX - s.count, left);
    s.count += can;
    left -= can;
  }
  // Fill empties.
  for (let i=0;i<INV_SIZE && left>0;i++) {
    const s = invSlots[i];
    if (s) continue;
    const put = Math.min(STACK_MAX, left);
    invSlots[i] = { id: blockId, count: put };
    left -= put;
  }
  return left; // remaining
}

function canAddToInventory(blockId, count) {
  let left = Math.max(0, count|0);
  if (!left || blockId === B.AIR) return true;

  for (let i=0;i<INV_SIZE && left>0;i++) {
    const s = invSlots[i];
    if (s && s.id === blockId && s.count < STACK_MAX) {
      left -= (STACK_MAX - s.count);
    }
  }
  for (let i=0;i<INV_SIZE && left>0;i++) {
    if (!invSlots[i]) left -= STACK_MAX;
  }
  return left <= 0;
}

function consumeFromSelected(n=1) {
  if (gameMode === "creative") return true;
  const s = invSlots[hotbarIndex];
  if (!s || s.count < n) return false;
  s.count -= n;
  if (s.count <= 0) invSlots[hotbarIndex] = null;
  return true;
}

function setSelectedCreative(blockId) {
  if (blockId === B.AIR) { invSlots[hotbarIndex] = null; return; }
  const maxDur = maxDurabilityFor(blockId);
  invSlots[hotbarIndex] = { id: blockId, count: STACK_MAX, durability: maxDur || undefined };
}

function updateInvModeUI() {
  if (!invModeEl) return;
  const isC = (gameMode === "creative");
  invModeEl.textContent = isC ? "Creative" : "Survival";

  // Top tabs only exist in Creative (Minecraft-ish).
  if (invTopTabsEl) invTopTabsEl.style.display = isC ? "flex" : "none";
  if (!isC) invActiveTab = "inventory";

  if (tabInvBtn) tabInvBtn.classList.toggle("active", invActiveTab === "inventory");
  if (tabCreativeBtn) tabCreativeBtn.classList.toggle("active", invActiveTab === "creative");

  const showCreative = isC && invActiveTab === "creative";
  const showInv = invActiveTab === "inventory";

  if (paneCreativeEl) paneCreativeEl.style.display = showCreative ? "block" : "none";
  if (paneInventoryEl) paneInventoryEl.style.display = showInv ? "block" : "none";

  if (creativeToolsEl) creativeToolsEl.style.display = showCreative ? "flex" : "none";
  if (survivalToolsEl) survivalToolsEl.style.display = showInv ? "block" : "none";
}

function renderCount(el, n) {
  const old = el.querySelector(".count");
  if (old) old.remove();
  if (!n || n <= 1) return;
  const c = document.createElement("div");
  c.className = "count";
  c.textContent = String(n);
  el.appendChild(c);
}

function renderDurability(el, slot) {
  const old = el.querySelector(".durability");
  if (old) old.remove();
  if (!slot) return;
  const maxDur = maxDurabilityFor(slot.id);
  if (!maxDur) return;
  const current = Math.max(0, Math.min(maxDur, slot.durability ?? maxDur));
  const d = document.createElement("div");
  d.className = "durability";
  const fill = document.createElement("div");
  fill.className = "durabilityFill";
  fill.style.width = `${Math.max(0, Math.min(1, current / maxDur)) * 100}%`;
  d.appendChild(fill);
  el.appendChild(d);
}

function renderHotbarHud() {
  hotbarHudEl.innerHTML = "";
  for (let i=0; i<HOTBAR_SIZE; i++) {
    const d = document.createElement("div");
    d.className = "hb-slot" + (i === hotbarIndex ? " selected" : "");
    const sw = document.createElement("div");
    sw.className = "hb-swatch";
    setSlotSwatch(sw, slotId(i));
    d.appendChild(sw);
    renderCount(d, slotCount(i));
    renderDurability(d, invSlots[i]);
    hotbarHudEl.appendChild(d);
  }
  updateHeldModel();
}

function renderInvHotbar() {
  invHotbarEl.innerHTML = "";
  for (let i=0; i<HOTBAR_SIZE; i++) {
    const d = document.createElement("div");
    d.className = "slot" + (i === hotbarIndex ? " sel" : "");
    const sw = document.createElement("div");
    sw.className = "sw";
    setSlotSwatch(sw, slotId(i));
    d.appendChild(sw);
    renderCount(d, slotCount(i));
    renderDurability(d, invSlots[i]);
    d.addEventListener("mousedown", (e) => handleSlotMouseDown(i, e));
invHotbarEl.appendChild(d);
  }
}

function renderInvMain() {
  if (!invMainEl) return;
  invMainEl.innerHTML = "";
  for (let i=9; i<INV_SIZE; i++) {
    const d = document.createElement("div");
    d.className = "slot";
    const sw = document.createElement("div");
    sw.className = "sw";
    setSlotSwatch(sw, slotId(i));
    d.appendChild(sw);
    renderCount(d, slotCount(i));
    renderDurability(d, invSlots[i]);
    d.addEventListener("mousedown", (e) => handleSlotMouseDown(i, e));
    invMainEl.appendChild(d);
  }
}

function selectHotbar(i) {
  hotbarIndex = Math.max(0, Math.min(HOTBAR_SIZE - 1, i));
  renderHotbarHud();
  renderInvHotbar();
  renderChat();
  updateHelp();
  try { if (typeof updateHeldBlock3D === "function") updateHeldBlock3D(); } catch(_) {}
}

const HELD_TILE_PX = 60;

function updateHeldModel() {
  if (!viewModelEl) return;
  updateViewModelVisibility();
  if (viewModelEl.style.display === "none") return;

  const bid = selectedBlock();
  if (heldCubeEl) heldCubeEl.style.display = (bid === B.AIR) ? "none" : "block";
  if (bid === B.AIR) return;

  const ft = faceTilesFor.get(bid) || allFaces(blockIcon(bid));
  if (heldFaceTopEl)   applyTileStyleSized(heldFaceTopEl,   ft[2], HELD_TILE_PX);
  if (heldFaceFrontEl) applyTileStyleSized(heldFaceFrontEl, ft[4], HELD_TILE_PX);
  if (heldFaceRightEl) applyTileStyleSized(heldFaceRightEl, ft[0], HELD_TILE_PX);
}

function putInSelectedSlot(blockId) {
  if (gameMode !== "creative") return;
  setSelectedCreative(blockId);
  renderHotbarHud();
  renderInvHotbar();
  renderInvMain();
  updateHelp();
  try { if (typeof updateHeldBlock3D === "function") updateHeldBlock3D(); } catch(_) {}
}

function renderCursor() {
  if (!invCursorEl) return;
  const it = normItem(cursorStack);
  if (!it) {
    invCursorEl.style.display = "none";
    invCursorEl.innerHTML = "";
    return;
  }
  invCursorEl.innerHTML = "";
  const sw = document.createElement("div");
  sw.className = "sw";
  setSlotSwatch(sw, it.id);
  invCursorEl.appendChild(sw);
  if (it.count > 1) {
    const c = document.createElement("div");
    c.className = "count";
    c.textContent = String(it.count);
    invCursorEl.appendChild(c);
  }
  invCursorEl.style.display = "block";
}

function refreshInventoryUI() {
  updateInvModeUI();
  renderHotbarHud();
  renderInvHotbar();
  renderInvMain();
  renderCursor();
  // Creative palette is filtered via search + category tabs.
  if (gameMode === "creative" && invActiveTab === "creative") { buildCreativeTabs(); renderPaletteFromUI(); }
}

// Keep the cursor following the mouse while inventory is open.
if (invOverlay) {
  invOverlay.addEventListener("mousemove", (e) => {
    if (!inventoryOpen || !invCursorEl) return;
    invCursorEl.style.left = e.clientX + "px";
    invCursorEl.style.top  = e.clientY + "px";
  });
  invOverlay.addEventListener("contextmenu", (e) => e.preventDefault());
}

function tryMoveToRange(fromIdx, toStart, toEnd) {
  const src = invSlots[fromIdx];
  if (!src) return false;

  let left = src.count;

  // Merge first.
  for (let i=toStart; i<=toEnd && left>0; i++) {
    const t = invSlots[i];
    if (!t || t.id !== src.id || t.count >= STACK_MAX || (t.durability ?? 0) !== (src.durability ?? 0)) continue;
    const can = Math.min(STACK_MAX - t.count, left);
    t.count += can;
    left -= can;
  }
  // Fill empties.
  for (let i=toStart; i<=toEnd && left>0; i++) {
    const t = invSlots[i];
    if (t) continue;
    const put = Math.min(STACK_MAX, left);
    invSlots[i] = { id: src.id, count: put };
    left -= put;
  }

  if (left === src.count) return false; // nothing moved
  src.count = left;
  if (src.count <= 0) invSlots[fromIdx] = null;
  return true;
}

function handleSlotMouseDown(idx, e) {
  // Only while inventory is open.
  if (!inventoryOpen) return;
  if (e.button !== 0 && e.button !== 2) return;
  e.preventDefault();

  // Shift-click: quick-move between hotbar and main inventory.
  if (e.shiftKey && e.button === 0) {
    const moved = (idx < HOTBAR_SIZE)
      ? tryMoveToRange(idx, 9, INV_SIZE-1)
      : tryMoveToRange(idx, 0, HOTBAR_SIZE-1);
    if (moved) refreshInventoryUI();
    return;
  }

  const right = (e.button === 2);
  const s = normItem(invSlots[idx]);
  const c = normItem(cursorStack);

  // Right click behavior (split stack / place 1)
  if (right) {
    if (!c && s) {
      // Pick up half (ceil) into cursor
      const take = Math.ceil(s.count / 2);
      cursorStack = { id: s.id, count: take, durability: s.durability };
      const rem = s.count - take;
      invSlots[idx] = rem > 0 ? { id: s.id, count: rem, durability: s.durability } : null;
      refreshInventoryUI();
      return;
    }
    if (c) {
      // Place 1 into empty slot, or add 1 to matching stack
      if (!s) {
        invSlots[idx] = { id: c.id, count: 1, durability: c.durability };
        c.count -= 1;
        cursorStack = (c.count > 0) ? c : null;
        refreshInventoryUI();
        return;
      }
      if (s.id === c.id && s.count < STACK_MAX && (s.durability ?? 0) === (c.durability ?? 0)) {
        s.count += 1;
        c.count -= 1;
        cursorStack = (c.count > 0) ? c : null;
        invSlots[idx] = s;
        refreshInventoryUI();
        return;
      }
      // Different item: do nothing on right-click (Minecraft-like).
      return;
    }
    return;
  }

  // Left click behavior
  if (!c && s) {
    // Pick up full stack
    cursorStack = { id: s.id, count: s.count, durability: s.durability };
    invSlots[idx] = null;
    refreshInventoryUI();
    return;
  }

  if (c) {
    if (!s) {
      // Place full stack into empty slot
      invSlots[idx] = { id: c.id, count: c.count, durability: c.durability };
      cursorStack = null;
      refreshInventoryUI();
      return;
    }

    if (s.id === c.id && s.count < STACK_MAX && (s.durability ?? 0) === (c.durability ?? 0)) {
      const can = Math.min(STACK_MAX - s.count, c.count);
      s.count += can;
      c.count -= can;
      invSlots[idx] = s;
      cursorStack = (c.count > 0) ? c : null;
      refreshInventoryUI();
      return;
    }

    // Swap
    invSlots[idx] = { id: c.id, count: c.count, durability: c.durability };
    cursorStack = { id: s.id, count: s.count, durability: s.durability };
    refreshInventoryUI();
    return;
  }
}

function buildCreativeTabs() {
  if (!creativeTabsEl) return;
  creativeTabsEl.innerHTML = "";
  for (const c of CREATIVE_CATS) {
    const b = document.createElement("button");
    b.type = "button";
    b.className = "subTabBtn" + (c.key === creativeCat ? " active" : "");
    b.textContent = c.label;
    b.addEventListener("click", () => {
      creativeCat = c.key;
      if (searchEl) searchEl.value = "";
      renderPaletteFromUI();
      buildCreativeTabs();
    });
    creativeTabsEl.appendChild(b);
  }
}

function renderPaletteFromUI() {
  if (gameMode !== "creative") return;
  const q = (searchEl ? searchEl.value : "").trim();
  const cat = q ? "search" : creativeCat;
  renderPalette(q, cat);
}

function renderPalette(filterText = "", catKey = "building") {
  if (!paletteGridEl) return;

  const q = (filterText || "").trim().toLowerCase();
  paletteGridEl.innerHTML = "";

  let list = BLOCK_LIST;
  if (catKey && catKey !== "search") list = list.filter(b => b.cat === catKey);
  if (q) list = list.filter(b => b.name.toLowerCase().includes(q));

  for (const it of list) {
    const d = document.createElement("div");
    d.className = "palSlot";
    d.dataset.name = it.name;
    const sw = document.createElement("div");
    sw.className = "sw";
    applyTileStyle(sw, it.icon);
    d.appendChild(sw);
    d.addEventListener("click", () => {
      if (gameMode !== "creative") return;
      putInSelectedSlot(it.id);
    });
    paletteGridEl.appendChild(d);
  }
}

if (searchEl) searchEl.addEventListener("input", () => {
  if (gameMode === "creative" && invActiveTab === "creative") { buildCreativeTabs(); renderPaletteFromUI(); }
});


// Initial render (start survival, empty inventory)
updateInvModeUI();
buildCreativeTabs();
renderPaletteFromUI();
renderHotbarHud();
renderInvHotbar();
renderInvMain();
try { updateHeldBlock3D(); } catch(_) {}

// ======================================================
    // Block interactions (use DDA hit)
    // ======================================================
    let lastAttackAt = 0;
    let hitFlashTimer = null;

    function triggerHitFlash() {
      if (!hitFlashEl) return;
      hitFlashEl.classList.add("active");
      if (hitFlashTimer) clearTimeout(hitFlashTimer);
      hitFlashTimer = setTimeout(() => {
        hitFlashEl.classList.remove("active");
      }, 120);
    }

    function rayAabb(origin, dir, min, max, maxDist) {
      let tmin = 0;
      let tmax = maxDist;
      const axes = ["x", "y", "z"];
      for (const axis of axes) {
        const o = origin[axis];
        const d = dir[axis];
        const minA = min[axis];
        const maxA = max[axis];
        if (Math.abs(d) < 1e-6) {
          if (o < minA || o > maxA) return null;
        } else {
          let t1 = (minA - o) / d;
          let t2 = (maxA - o) / d;
          if (t1 > t2) { const tmp = t1; t1 = t2; t2 = tmp; }
          tmin = Math.max(tmin, t1);
          tmax = Math.min(tmax, t2);
          if (tmax < tmin) return null;
        }
      }
      return tmin;
    }

    function raycastEntity(origin, dir, maxDist) {
      let closest = null;
      for (const ent of entities) {
        if (!ent || ent.health <= 0) continue;
        const { min, max } = entityAabb(ent);
        const dist = rayAabb(origin, dir, min, max, maxDist);
        if (dist === null || dist > maxDist) continue;
        if (!closest || dist < closest.dist) {
          closest = {
            entity: ent,
            dist,
            point: origin.clone().addScaledVector(dir, dist),
          };
        }
      }
      return closest;
    }

    function attemptAttack() {
      const now = performance.now();
      const held = selectedItem();
      const stats = weaponStatsFor(held?.id ?? B.AIR);
      if (now - lastAttackAt < stats.cooldown * 1000) return false;

      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      dir.normalize();
      const hit = raycastEntity(camera.position, dir, stats.reach);
      if (!hit) return false;

      lastAttackAt = now;
      hit.entity.health = Math.max(0, hit.entity.health - stats.damage);
      triggerSwing();
      triggerHitFlash();

      if (stats.durability > 0) damageSelectedWeapon(1);

      if (hit.entity.health <= 0) {
        addChatMessage(`${hit.entity.name} defeated`);
        removeEntity(hit.entity);
      }

      renderHotbarHud();
      if (inventoryOpen) refreshInventoryUI();
      return true;
    }

    function currentHit() {
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      dir.normalize();
      return voxelRaycast(camera.position, dir, 7.0);
    }

    function breakAt(hit) {
  if (!hit) return false;
  if (hit.y === 0) return false; // bedrock floor
  const t = getBlock(hit.x, hit.y, hit.z);
  if (t === B.AIR) return false;

  if (gameMode === "survival") {
    // Simple MC-ish drop mapping (no item entities yet, so we only break if we can store it).
    let drop = t;
    if (t === B.GRASS) drop = B.DIRT;
    if (t === B.WATER || t === B.LAVA || t === B.BEDROCK) drop = B.AIR;

    if (drop !== B.AIR && !canAddToInventory(drop, 1)) {
      addChatMessage("Inventory full");
      return false;
    }

    setEdit(hit.x, hit.y, hit.z, B.AIR);
    if (drop !== B.AIR) addToInventory(drop, 1);
  } else {
    // Creative: instant break, no inventory constraints.
    setEdit(hit.x, hit.y, hit.z, B.AIR);
  }

  markChunksDirtyForBlock(hit.x, hit.z);
  triggerSwing();

  // Keep UI in sync.
  renderHotbarHud();
  if (inventoryOpen) refreshInventoryUI();
  return true;
}

    function placeAt(hit) {
  if (!hit) return false;
  const bid = selectedBlock();
  if (bid === B.AIR) return false;

  const px = hit.x + hit.nx;
  const py = hit.y + hit.ny;
  const pz = hit.z + hit.nz;
  if (py < 0 || py >= WORLD_H) return false;
  if (getBlock(px, py, pz) !== B.AIR) return false;
  if (playerOverlapsBlock(px, py, pz)) return false;

  if (gameMode === "survival") {
    if (!consumeFromSelected(1)) return false;
  }

  setEdit(px, py, pz, bid);
  markChunksDirtyForBlock(px, pz);
  triggerSwing();

  renderHotbarHud();
  if (inventoryOpen) refreshInventoryUI();
  return true;
}

    function pickBlockIntoSlot(hit) {
  if (!hit) return;
  const t = getBlock(hit.x, hit.y, hit.z);
  if (t === B.AIR) return;

  if (gameMode === "creative") {
    // Creative: "Pick Block" creates/sets a stack in the selected hotbar slot.
    setSelectedCreative(t);
    renderHotbarHud();
    if (inventoryOpen) refreshInventoryUI();
  } else {
    // Survival: only selects an existing hotbar stack if present.
    for (let i=0;i<HOTBAR_SIZE;i++) {
      if (slotId(i) === t && slotCount(i) > 0) { selectHotbar(i); break; }
    }
  }
  triggerSwing();
}

    window.addEventListener("mousedown", (e) => {
      if (!gameActive()) return;
    
      if (e.button === 0) { // break (continuous while held)
        const attacked = attemptAttack();
        if (!attacked) {
          lmbHeld = true;
          const hit = currentHit();
          breakAt(hit);
          lastMineTime = performance.now();
        }
      }
    
      if (e.button === 1) { // pick
        const hit = currentHit();
        pickBlockIntoSlot(hit);
      }
    
      if (e.button === 2) { // place (continuous while held) OR drag look fallback
        if (isLocked()) {
          rmbHeld = true;
          const hit = currentHit();
          placeAt(hit);
          lastPlaceTime = performance.now();
        } else {
          startDragLook(e.clientX, e.clientY);
        }
      }
    });
    
    window.addEventListener("mouseup", (e) => {
      if (e.button === 0) {
        lmbHeld = false;
        return;
      }
    
      if (e.button !== 2) return;
    
      // RMB release
      rmbHeld = false;
    
      if (!gameActive()) return;
    
      // If pointer-lock is active, RMB was placing; no drag-look click logic needed.
      if (isLocked()) return;
    
      // Drag-look click-to-place fallback
      if (!rmbDown) return;
    
      const dt = performance.now() - rmbStartT;
      const moved = rmbMoved;
      stopDragLook();
    
      if (dt < 300 && moved < 10) {
        const hit = currentHit();
        placeAt(hit);
      }
    });
    
    window.addEventListener("blur", () => { lmbHeld = false; rmbHeld = false; try { stopDragLook(); } catch(_){} });

    // ======================================================
    // HUD help
    // ======================================================
    function updateHelp() {
      const state = inventoryOpen ? "Inventory" : (menuOverlay.style.display !== "none" ? "Menu" : (isLocked() ? "Mouse Look" : "Drag Look"));
      const sel = selectedBlock();
      const selCount = slotCount(hotbarIndex);
      const pcx = floorDiv(Math.floor(player.pos.x), CHUNK);
      const pcz = floorDiv(Math.floor(player.pos.z), CHUNK);

      const lockHint = (!inventoryOpen && menuOverlay.style.display === "none" && !isLocked())
        ? "Click canvas to recapture (or RMB-drag to look)\n"
        : "";

      const isFly = (flyMode && gameMode === "creative");
      const fluidNow = (!isFly && gameActive()) ? getPlayerFluidState() : { water:false, lava:false };
      const swimHint = (!isFly && (fluidNow.water || fluidNow.lava))
        ? "Swimming: Space up · R down · Shift swim fast\n"
        : "";

      helpEl.textContent =
        `Mini INDEV Voxel — Infinite + Textures\n` +
        `State: ${state}\n` +
        `Camera: ${camMode===CAM_MODE.FIRST?"First-person":(camMode===CAM_MODE.THIRD_BACK?"Third-person (back)":"Third-person (front)")}\n` +
        `Gamemode: ${gameMode === "creative" ? "Creative" : "Survival"}\n` +
        `Move: ${(flyMode && gameMode === "creative") ? "Fly" : "Walk"}\n` +
        `Seed: ${WORLD_SEED}
` + `Selected: [${hotbarIndex+1}] ${blockName(sel)}${gameMode==="creative"?"":(selCount>1?` x${selCount}`:"")}
` +
        `Chunk: (${pcx}, ${pcz})  Loaded: ${chunks.size}\n` +
        (isFly
          ? `WASD move · Space up · Shift down · Double Space fly · T chat · LMB break · RMB place · MMB pick · 1–9 hotbar · E inventory · Esc menu\n`
          : (gameMode === "creative"
              ? `WASD move · Shift sprint · Space jump · R crouch · Double Space fly · T chat · LMB break · RMB place · MMB pick · 1–9 hotbar · E inventory · Esc menu\n`
              : `WASD move · Shift sprint · Space jump · R crouch · T chat · LMB break · RMB place · MMB pick · 1–9 hotbar · E inventory · Esc menu\n`
            )) +
        swimHint +
        `Perf: voxel DDA picking + chunk-local caches\n` +
        lockHint;
    }

    // ======================================================
    // Resize
    // ======================================================
    window.addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ======================================================
    // Spawn + initial chunks
    // ======================================================
    (function spawnOnSurface() {
      function goodSpawn(x, z) {
        const top = surfaceY(x, z);
        if (top < SEA_LEVEL + 1) return false; // dry land only
        const t = getBlock(x, top, z);
        if (t === B.WATER || t === B.LAVA) return false;

        // avoid nasty cliffs right at spawn
        const d1 = Math.abs(surfaceY(x + 1, z) - top);
        const d2 = Math.abs(surfaceY(x - 1, z) - top);
        const d3 = Math.abs(surfaceY(x, z + 1) - top);
        const d4 = Math.abs(surfaceY(x, z - 1) - top);
        if (Math.max(d1, d2, d3, d4) > 3) return false;

        // headroom (should already be air, but keep it explicit)
        if (getBlock(x, top + 1, z) !== B.AIR) return false;
        if (getBlock(x, top + 2, z) !== B.AIR) return false;
        return true;
      }

      let sx = 0, sz = 0;
      if (!goodSpawn(sx, sz)) {
        let found = false;
        const maxR = 192;
        for (let r = 4; r <= maxR && !found; r += 4) {
          for (let dz = -r; dz <= r && !found; dz += 4) {
            for (let dx = -r; dx <= r && !found; dx += 4) {
              const x = sx + dx, z = sz + dz;
              if (goodSpawn(x, z)) { sx = x; sz = z; found = true; }
            }
          }
        }
      }

      const top = surfaceY(sx, sz);
      player.pos.set(sx + 0.5, top + 2.0, sz + 0.5);
      syncCamera();
    })();

    (function primeChunks() {
      const pcx = floorDiv(Math.floor(player.pos.x), CHUNK);
      const pcz = floorDiv(Math.floor(player.pos.z), CHUNK);

      // Warm-start a small neighborhood immediately (fast startup even with taller WORLD_H).
      const WARM_RADIUS = 1;
      for (let dz=-WARM_RADIUS; dz<=WARM_RADIUS; dz++) for (let dx=-WARM_RADIUS; dx<=WARM_RADIUS; dx++) {
        loadChunk(pcx + dx, pcz + dz);
      }
      updateHelp();
    })();

    // ======================================================
    // Main loop
    // ======================================================
    const clock = new THREE.Clock();
    let hudTimer = 0;

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());

      if (gameActive()) {
        const forward = (keys.has("KeyW") ? 1 : 0) - (keys.has("KeyS") ? 1 : 0);
        const strafe  = (keys.has("KeyD") ? 1 : 0) - (keys.has("KeyA") ? 1 : 0);

        const dir = new THREE.Vector3();
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        camDir.y = 0; camDir.normalize();
        const right = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0,1,0)).normalize();

        dir.addScaledVector(camDir, forward);
        dir.addScaledVector(right, strafe);
        const moveLenSq = dir.lengthSq();
        if (moveLenSq > 0) dir.normalize();
        const moving = (moveLenSq > 0);

        if (flyMode && gameMode === "creative") {
          // Creative flight: no gravity, fast movement, Space up / Shift down.
          const flyMove = (PLAYER.speed * 1.75 * FLY_SPEED_MULT) * dt; // ~3x run speed
          tryMoveAxis("x", dir.x * flyMove);
          tryMoveAxis("z", dir.z * flyMove);

          const up = keys.has("Space") ? 1 : 0;
          const down = (keys.has("ShiftLeft") || keys.has("ShiftRight")) ? 1 : 0;
          const vy = (up - down) * flyMove;

          player.velY = 0;
          player.onGround = false;
          if (vy) tryMoveAxis("y", vy);
        
} else {
  // Swimming: water/lava are non-colliding "fluids" with buoyancy + drag.
  const fluid = getPlayerFluidState();
  const inWater = fluid.water;
  const inLava = fluid.lava && !inWater; // water wins if both overlap
  const inFluid = inWater || inLava;

  // Fluid entry damping (prevents "water-as-land" sprint-jump feel)
  if (inWater && !lastInWater) {
    player.velY = Math.max(player.velY, -6.0);
    fallPeakY = player.pos.y; // cancel fall carryover into water
  }
  if (inLava && !lastInLava) {
    player.velY = Math.max(player.velY, -5.0);
    fallPeakY = player.pos.y;
  }
  // Water exit "breach" assist: higher-but-slower jump out of water.
  // Trigger when leaving water while holding Space.
  if (!inWater && lastInWater) {
    if (keys.has("Space") && player.velY > 0.1) waterBreachTimer = 0.28;
  }
  if (inWater) waterBreachTimer = 0; // no stacking while submerged

  lastInWater = inWater;
  lastInLava = inLava;

  // Crouch (R) is land-only. In fluid, R is "sink".
  const wantCrouch = !inFluid && keys.has("KeyR");
  if (wantCrouch) {
    player.crouching = true;
  } else if (player.crouching) {
    if (!aabbCollidesAt(player.pos, PLAYER.height)) player.crouching = false;
  }
  if (inFluid) player.crouching = false;

  // Shift = sprint on land AND "swim fast" in fluids.
  const sprinting = (keys.has("ShiftLeft") || keys.has("ShiftRight")) && moving;
  const sprint = sprinting ? 1.75 : 1.0;

  const crouchMult = player.crouching ? 0.35 : 1.0;
  const fluidMult = inWater ? 0.45 : (inLava ? 0.30 : 1.0);
  const move = (PLAYER.speed * sprint * crouchMult * fluidMult) * dt;
          tryMoveAxis("x", dir.x * move);
          tryMoveAxis("z", dir.z * move);

          const prevGround = player.onGround;
          if (gameMode === "survival" && prevGround) {
            fallPeakY = player.pos.y;
          }

          
// Reset fall tracking when in fluid (prevents fall damage on water entry).
if (gameMode === "survival" && inFluid) {
  fallPeakY = player.pos.y;
}

let didJump = false;

if (inWater) {
  // Buoyancy + drag (stable: no "skipping" off the surface)
  player.velY -= PLAYER.gravity * 0.20 * dt;
  player.velY += 3.0 * dt; // buoyancy (reduced so you sink)
  player.velY *= (1 - Math.min(0.90, dt * 7.0)); // strong vertical drag
  player.velY = Math.max(-7.0, Math.min(6.5, player.velY));

  // Space: rise/float up (gentle), R: sink
  if (keys.has("Space")) player.velY = Math.max(player.velY, 3.0);
  const down = keys.has("KeyR");
  if (down) player.velY = Math.min(player.velY, -3.6);
} else if (inLava) {
  // Lava is "thicker": slower buoyancy + more drag
  player.velY -= PLAYER.gravity * 0.24 * dt;
  player.velY += 3.0 * dt;
  player.velY *= (1 - Math.min(0.85, dt * 5.0));
  player.velY = Math.max(-6.5, Math.min(6.5, player.velY));

  if (keys.has("Space")) player.velY = Math.max(player.velY, 3.0);
  const down = keys.has("KeyR");
  if (down) player.velY = Math.min(player.velY, -3.2);
} else {
  player.velY -= PLAYER.gravity * dt;
  player.velY = Math.max(-PLAYER.terminal, player.velY);

  if (player.onGround && keys.has("Space")) {
    player.velY = PLAYER.jump;
    player.onGround = false;
    didJump = true;
  }
}

          // Water breach assist: higher but slower jump out of water.
          if (waterBreachTimer > 0 && !inWater && !inLava) {
            waterBreachTimer = Math.max(0, waterBreachTimer - dt);
            player.velY += 14.0 * dt;
            player.velY *= (1 - Math.min(0.55, dt * 3.0));
            player.velY = Math.min(player.velY, 4.0);
          }

          player.onGround = false;
          const dy = player.velY * dt;
          const collidedY = tryMoveAxis("y", dy);
          if (collidedY && dy < 0) { player.onGround = true; player.velY = 0; }
          else if (collidedY && dy > 0) { player.velY = 0; }

          // Survival: fall damage on landing
          if (gameMode === "survival") {
            if (!inFluid && !prevGround && !player.onGround) {
              // track peak while airborne (jump apex or step-off start)
              fallPeakY = Math.max(fallPeakY, player.pos.y);
            }
            if (!inFluid && !prevGround && player.onGround && dy < 0) {
              const fallDist = (fallPeakY - player.pos.y);
              const dmg = Math.floor(fallDist - 3.0);
              if (dmg > 0) damagePlayer(dmg, "fall");
            }

            // Lava damage (Survival)
            if (inLava) {
              lavaHurtTimer += dt;
              while (lavaHurtTimer >= 0.5) {
                lavaHurtTimer -= 0.5;
                damagePlayer(2, "lava"); // 1 heart per tick
              }
            } else {
              lavaHurtTimer = 0;
            }

            // Hunger drain + regen + starvation
            const hungerBefore = hunger;
            const healthBefore = health;

            // Exhaustion: moving costs, sprint costs more, jumps cost a chunk
            const baseEx = moving ? 0.08 : 0.01; // per second
            exhaustion += dt * baseEx * (sprinting ? 2.2 : 1.0);
            if (didJump) exhaustion += 0.35;

            while (exhaustion >= 4.0) {
              exhaustion -= 4.0;
              hunger = Math.max(0, hunger - 1);
            }

            if (hunger >= 18 && health < SURV_MAX) {
              regenTimer += dt;
              if (regenTimer >= 4.0) {
                regenTimer = 0;
                health = Math.min(SURV_MAX, health + 1);
                hunger = Math.max(0, hunger - 1);
              }
            } else {
              regenTimer = 0;
            }

            if (hunger <= 0) {
              starveTimer += dt;
              if (starveTimer >= 4.0) {
                starveTimer = 0;
                if (health > 1) health -= 1;
              }
            } else {
              starveTimer = 0;
            }

            if (health !== healthBefore || hunger !== hungerBefore) renderStatusHud();
          }
        }

        updatePlayerWalk(dt);
        applyViewmodelSwing(dt);
        updateCameraRig();

        // Fluid screen tint (subtle underwater cue)
        if (fluidTintEl) {
          const ex = Math.floor(camera.position.x);
          const ey = Math.floor(camera.position.y);
          const ez = Math.floor(camera.position.z);
          const eyeT = getBlock(ex, ey, ez);
          if (eyeT === B.WATER) {
            fluidTintEl.style.background = "rgba(18, 70, 190, 0.42)";
            fluidTintEl.style.opacity = "1";
          } else if (eyeT === B.LAVA) {
            fluidTintEl.style.background = "rgba(255, 90, 20, 0.14)";
            fluidTintEl.style.opacity = "1";
          } else {
            fluidTintEl.style.opacity = "0";
          }
        }


updateChunkStreaming(player.pos.x, player.pos.z);

// Continuous mine/place while holding mouse buttons
{
  const now = performance.now();
  if (lmbHeld && (now - lastMineTime) >= MINE_INTERVAL_MS) {
    const hit = currentHit();
    breakAt(hit);
    lastMineTime = now;
  }
  if (rmbHeld && isLocked() && (now - lastPlaceTime) >= PLACE_INTERVAL_MS) {
    const hit = currentHit();
    placeAt(hit);
    lastPlaceTime = now;
  }
}

// highlight using DDA hit (no raycaster)
        const hit = currentHit();
        if (hit && getBlock(hit.x, hit.y, hit.z) !== B.AIR) {
          highlight.visible = true;
          highlight.position.copy(blockCenter(hit.x, hit.y, hit.z));
        } else {
          highlight.visible = false;
        }
      } else {
        highlight.visible = false;
      }

      renderer.render(scene, camera);

      hudTimer += dt;
      if (hudTimer > 0.15) { hudTimer = 0; updateHelp(); renderStatusHud(); renderChat(); }
    }
    animate();

    // Start at menu
    setMenu(true);

  })();
  </script>
</body>
</html>
